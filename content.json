{"meta":{"title":"大道至简","subtitle":"以不变应万变","description":"不积跬步无以至千里","author":"iki","url":"http://www.matosiki.site"},"pages":[{"title":"","date":"2020-08-20T14:27:35.661Z","updated":"2020-08-20T14:27:35.661Z","comments":true,"path":"404/404.html","permalink":"http://www.matosiki.site/404/404.html","excerpt":"","text":""},{"title":"","date":"2020-08-20T14:27:35.662Z","updated":"2020-08-20T14:27:35.662Z","comments":true,"path":"404/index.html","permalink":"http://www.matosiki.site/404/","excerpt":"","text":"_ __ _ _ | | &#x2F; _(_) | | _ __ __ _ __ _ ___ _ __ ___ | |_ | |_ _ _ __ __| || &#39;_ \\ &#x2F; _&#96; |&#x2F; _&#96; |&#x2F; _ \\ | &#39;_ \\ &#x2F; _ \\| __| | _| | &#39;_ \\ &#x2F; _&#96; || |_) | (_| | (_| | __&#x2F; | | | | (_) | |_ | | | | | | | (_| || .__&#x2F; \\__,_|\\__, |\\___| |_| |_|\\___&#x2F; \\__| |_| |_|_| |_|\\__,_|| | __&#x2F; | |_| _ _ |___&#x2F;_ _ | || | &#x2F; _ \\| || | | || |_| | | | || |_ |__ _| | | |__ _| | | | |_| | | | |_| \\___&#x2F; |_|"},{"title":"个人简历","date":"2020-08-20T14:27:35.662Z","updated":"2020-08-20T14:27:35.662Z","comments":true,"path":"about/index.html","permalink":"http://www.matosiki.site/about/","excerpt":"","text":"我是虾,不皮皮虾的的那种!! 基本介绍 性别男，取向女 geek爱好者，脑洞大，敢尝试，乐意思考，有梦想，爱生活，会运动，敢拼搏，敢说敢做，有爱心，知道人情世故崇尚知行合一的做事方法,喜欢我思故我在的人生态度,实践不积跬步,无以至千里的学习方式,践行终生学习的理念.### 个人广告词- 我思故我在### 曾经 喜欢我☝关注我"}],"posts":[{"title":"blog/linux/linux安装使用zsh和oh my zsh","slug":"blog/linux/linux安装使用zsh和oh my zsh","date":"2020-07-21T05:31:39.335Z","updated":"2020-07-21T05:31:39.335Z","comments":true,"path":"blog/linux/linux安装使用zsh和oh my zsh/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8zsh%E5%92%8Coh%20my%20zsh/","excerpt":"","text":"linux安装使用zsh和oh my zsh安装使用zsh 和 oh my zsh 先安装zsh yum install zsh 切换zsh chsh -s /bin/zsh 设置用户默认zsh sudo usermod -s /bin/zsh username 安装oh my zsh使用 curl $ sh -c “$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 或者 使用wget $ sh -c “$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)” 如果 下载可能很慢 手动配置使用码云地址下载再安装 克隆仓库 git clone https://gitee.com/zhou_jiajian/ohmyzsh.git 或者自己github地址 git clone git@github.com:wx11055/oh-my-zsh.git 更改仓库名为.oh-my-zsh mv ohmyzsh .oh-my-zsh 改写 .zshrc文件 cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 改变shell chsh -s /bin/zsh 设置zsh 为默认shell source ~/.zshrc tip:手动切换shell 输入shell名称 bash zsh 执行上次使用的命令 !! 搜索历史执行命令 快捷键ctrl + r 就会进入对应的shell 配置主题修改~/.zshrc中的环境变量ZSH_THEME vim ~/.zshrc ZSH_THEME=”agnoster” # (this is one of the fancy ones) ZSH_THEME=”random” # (…please let it be pie… please be some pie..) 查看官网主题https://github.com/robbyrussell/oh-my-zsh/wiki/Themes 配置插件修改～/.zshrc中plugins plugins=(git bundler osx rake ruby) 安装自动补全插件cd ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;git clone https:&#x2F;&#x2F;github.com&#x2F;zsh-users&#x2F;zsh-autosuggestionssource ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;zsh-autosuggestions&#x2F;zsh-autosuggestions.zsh 安装高亮cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitsource ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh cd ~/.oh-my-zsh/custom/plugins/ git clone https://github.com/zsh-users/zsh-completions $&#123;ZSH_CUSTOM:=~/.oh-my-zsh/custom&#125;/plugins/zsh-completions 更新oh-my-zsh’ disable_update_prompt = true 禁用自动升级, 修改~/.zshrc disable_auto_update = true 立即升级 upgrade_oh_my_zsh 卸载 uninstall_oh_my_zsh zsh 兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。 强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。 智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的…… 各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全 智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。 目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。 在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。 通配符搜索：ls -l */.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。 更强的别名 插件支持","categories":[],"tags":[]},{"title":"blog/tools/高效的使用Postman进行Mock Server","slug":"blog/tools/高效的使用Postman进行Mock Server","date":"2020-06-04T02:02:07.181Z","updated":"2020-06-04T02:02:07.181Z","comments":true,"path":"blog/tools/高效的使用Postman进行Mock Server/","link":"","permalink":"http://www.matosiki.site/blog/tools/%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8Postman%E8%BF%9B%E8%A1%8CMock%20Server/","excerpt":"","text":"1. 添加Example在自己添加的collection中,正常测试完成,将response保存为Example.这样防止API接口断供后,无法获取数据,这样可以从Example中查看到保存的Response. 但是如果你想,根据Example做一个MockServer,这样每次访问接口都能拿到Example中Response的结果了.接下来,第一步将Response保存到Example中. 在弹出的页面中填写好Example的名称,还可以自己调正Response返回的值. 2. 添加mock环境正常情况下有一个collection的环境,但为了mock测试方便,新建一个mock环境.注意: mock环境中有两个变量,x-api-key这个需要在自己的workspace上生成, url这个需要等到mock server 创建时填写. 3.新建mock server在postman中,点击New按钮,选择Mock Server,会看到如下图对话框在第一步中选择 Select an existing collection 选择 eurekacollection,点击Next.第二步,设置mock server,注意选择 eureka mock 环境,并且注意要去自己的workspace生成x-api-key,再点击Next,页面会返回一个URL,这个就是Mock URL,复制这个变量拷贝到mock环境变量中,到这里差不多就快完成了,还有最后 如果找不到Mock Server Url 也可以去workspace中找到. 4.生成API-KEY进入自己的workspace,生成自己的API key,复制Api-key到mock 环境中,完成了mock环境配置. 5.Runner测试最后我们来测试mock server,选择collection,添加Runner,选择环境变量,运行测试.查看测试结果 总结: 如何使用postman进行mock server 对接口进行测试. 参考链接 Postman API Postman Examples","categories":[],"tags":[]},{"title":"blog/terraform/terraform理解入门","slug":"blog/terraform/terraform理解入门","date":"2020-06-04T02:02:07.180Z","updated":"2020-06-04T02:04:48.595Z","comments":true,"path":"blog/terraform/terraform理解入门/","link":"","permalink":"http://www.matosiki.site/blog/terraform/terraform%E7%90%86%E8%A7%A3%E5%85%A5%E9%97%A8/","excerpt":"","text":"腾讯云栗子下载-tencentcloud-demo-module.zip Terraform是一种安全有效地构建，更改和版本化基础架构的工具。Terraform用于创建，管理和更新基础架构资源，例如物理机，VM，网络交换机，容器等。几乎任何基础设施类型都可以表示为Terraform中的资源。 四大功能 基础设置代码 执行计划 资源图 自动更新 Terraform使用场景 Heroku应用设置 多层应用 自助服务集群 软件演示 一次性环境 软件定义网络（SDN） 资源调度程序 多云部署 使用terraform安装下载windows版本使用命令验证安装将terraform.exe拷贝到指定目录,并设置path环境变量terraform设置环境变量 插件缓存目录 set TF_PLUGIN_CACHE_DIR&#x3D;&quot;%HOME%\\.terraform.d\\plugin-cache&quot; 手动安装插件目录 %APPDATA%\\terraform.d\\plugins 手动安装provider插件aws-provider插件google-provider插件 构建基础架构一.配置provider &quot;aws&quot; &#123; profile &#x3D; &quot;default&quot; region &#x3D; &quot;us-east-1&quot;&#125;resource &quot;aws_instance&quot; &quot;example&quot; &#123; ami &#x3D; &quot;ami-2757f631&quot; instance_type &#x3D; &quot;t2.micro&quot;&#125; 二.初始化terraform initterraform apply terrafomr show 三.应用更改更改amiresource &quot;aws_instance&quot; &quot;example&quot; &#123; ami &#x3D; &quot;ami-b374d5a5&quot; instance_type &#x3D; &quot;t2.micro&quot;&#125; terraform apply terrafomr show # 销毁基础设施terraform destroy 四.资源依赖 隐性依赖Terraform可以自动推断出一个资源何时依赖于另一个资源.Terraform使用此依赖关系信息来确定创建不同资源的正确顺序通过插值表达式的隐式依赖关系是告知Terraform关于这些关系的主要方式，应尽可能使用。 显式依赖depends_on任何资源都接受该参数，并接受资源列表以创建显式依赖项。 depends_on&#x3D;[google_instance.example] 非资源依赖Terraform将同时执行操作以减少应用更改所需的总时间,非资源依赖与其他资源依赖的可能同时创建. 五.提供负责实例创建完成初始化工作,比如运行shell、触发软件配置等等. 定义提供者 provisioner &quot;local-exec&quot; &#123; command &#x3D; &quot;echo $&#123;aws_instance.example.public_ip&#125; &gt; ip_address.txt&quot;&#125; terraform可以定义多个提供者 应用配置terraform applycat ip_address.txt 失败的提供者和污点资源 如果资源成功创建但在配置期间失败，则Terraform将发生错误并将资源标记为“受污染”。一个污点资源已被物理创建出来，由于预配失败，将无法被视为安全的使用。 当执行下一个计划时，因为不能保证安全，terraform不会在相同的资源上尝试重启预配置。取代方式是，terraform将移除所有污点资源，然后再创建资源并尝试预配置。 因为违反了执行计划，当执行期间失败时，terraform不会回滚和删除资源。 执行计划只告诉资源的创建，不会有删除资源，如果创建一个污点资源，计划将清除状态，资源将被删除。 销毁provisioners还可以定义仅在销毁操作期间运行的供应商。这些对于执行系统清理，提取数据等非常有用。对于许多资源，建议尽可能使用内置清理机制（例如init脚本），但必要时可以使用配置程序。 provisioners详细文档 输入变量 定义变量创建variables.tf文件variable &quot;region&quot; &#123; default &#x3D; &quot;us-east-1&quot;&#125; 引用变量provider &quot;aws&quot; &#123; region &#x3D; &quot;$&#123;var.region&#125;&quot;&#125; 分配变量 命令行分配方式terraform apply -var region&#x3D;us-east-2 从文件中分配创建目录匹配terraform.tfvars或 .auto.tfvars存在的所有文件，分配变量值。 region &#x3D; &quot;us-east-2&quot; 指定多个变量文件terraform apply \\ -var-file&#x3D;&quot;secret.tfvars&quot; \\ -var-file&#x3D;&quot;production.tfvars&quot; 环境变量Terraform读取TF_VAR_name变量，TF_VAR_region 设置region变量 UI输入如果您terraform apply使用未指定的某些变量执行，Terraform将要求您以交互方式输入其值。 定义list类型变量 # 隐式声明# implicitly by using brackets [...]variable &quot;cidrs&quot; &#123; default &#x3D; [] &#125;# 显式声明# explicitlyvariable &quot;cidrs&quot; &#123; type &#x3D; list &#125; terraform.tfvars文件中定义cidrs &#x3D; [ &quot;10.0.0.0&#x2F;16&quot;, &quot;10.1.0.0&#x2F;16&quot; ]定义map类型变量variable &quot;amis&quot; &#123; type &#x3D; &quot;map&quot; default &#x3D; &#123; &quot;us-east-1&quot; &#x3D; &quot;ami-b374d5a5&quot; &quot;us-west-2&quot; &#x3D; &quot;ami-4b32be2b&quot; &#125;&#125; resource &quot;aws_instance&quot; &quot;example&quot; &#123; ami &#x3D; var.amis[var.region] instance_type &#x3D; &quot;t2.micro&quot;&#125; 命令行分配map类型变量terraform apply -var &#39;amis&#x3D;&#123; us-east-1 &#x3D; &quot;foo&quot;, us-west-2 &#x3D; &quot;bar&quot; &#125;&#39; 栗子variables.tfvariable &quot;region&quot; &#123;&#125;variable &quot;amis&quot; &#123; type &#x3D; &quot;map&quot;&#125;terraform.tfvarsamis &#x3D; &#123; &quot;us-east-1&quot; &#x3D; &quot;ami-abc123&quot; &quot;us-west-2&quot; &#x3D; &quot;ami-def456&quot;&#125;main.tfresource &quot;aws_instance&quot; &quot;example&quot; &#123; # ami &#x3D; &quot;ami-b374d5a5&quot; ami &#x3D; &quot;$&#123;var.amis[var.region]&#125;&quot; instance_type &#x3D; &quot;t2.micro&quot;&#125;output &quot;ami&quot; &#123; value &#x3D; aws_instance.example.ami&#125;cliterraform apply -var region&#x3D;us-west-2 输出变量 定义输出添加到任何 *.tf 文件中output &quot;ip&quot; &#123; value &#x3D; aws_eip.ip.public_ip&#125; output可以定义多个块以指定多个输出变量。 2.查看输出命令行 terraform ouput ip 此命令对于脚本提取输出很有用 模块Terraform中的模块是Terraform配置的独立包，可作为一个组进行管理。模块用于创建可重用组件，改进组织，并将基础架构处理为黑盒子。模块文档 使用模块 terraform &#123; required_version &#x3D; &quot;0.12.5&quot;&#125;provider &quot;aws&quot; &#123; access_key &#x3D; &quot;AWS ACCESS KEY&quot; secret_key &#x3D; &quot;AWS SECRET KEY&quot; region &#x3D; &quot;us-east-1&quot;&#125;module &quot;consul&quot; &#123; source &#x3D; &quot;hashicorp&#x2F;consul&#x2F;aws&quot; num_servers &#x3D; &quot;3&quot;&#125; 该source属性是模块的唯一必需参数。它告诉Terraform可以检索模块的位置。Terraform会自动为您下载和管理模块。 模块从官方Terraform Registry中检索。Terraform还可以从各种来源检索模块，包括私有模块注册表或直接从Git，Mercurial，HTTP和本地文件。 terraform init 应用更改 terraform apply 模块输出模块输出文档描述了它产生的所有不同值。总的来说，它暴露了它创建的每个资源的id，以及回显一些输入值。 销毁terraform destroy 远程状态存储远程后端文档远程后端允许Terraform使用共享存储空间来存储状态数据，因此团队中的任何成员都可以使用Terraform来管理相同的基础架构。 1. 如何远程状态存储terraform &#123; backend &quot;remote&quot; &#123; organization &#x3D; &quot;Cloud-Org&quot; workspaces &#123; name &#x3D; &quot;Dev-QA&quot; &#125; &#125;&#125; 2. 远程状态存储方案3. Terraform Cloud文档它支持执行Terraform运行的两个主要工作流程： VCS驱动的工作流，在将更改提交到配置的VCS存储库时，它会自动对计划进行排队。 API驱动的工作流，CI管道或其他自动化工具可以直接上传配置。 登录terraform cloud console 升级terraform版本到0.11.13以上 在cloud上创建组织 添加组织成员 在cloud上添加access token并配置本机认证文件%APPDATA%\\terraform.rc credentials &quot;app.terraform.io&quot; &#123; token &#x3D; &quot;REPLACE_ME&quot;&#125; 在配置中开启terraform remote state 配置 terraform &#123; backend &quot;remote&quot; &#123; organization &#x3D; &quot;max&quot; workspaces &#123; name &#x3D; &quot;app-max-hello&quot; &#125; &#125;&#125; 重新初始化并运行terraform terraform init 协作查看 查看工作区 工作区锁定 查看状态历史版本 删除工作空间 terraform destroy -auto-approve","categories":[],"tags":[]},{"title":"blog/terraform/terraform进阶实践","slug":"blog/terraform/terraform进阶实践","date":"2020-06-04T02:02:07.180Z","updated":"2020-06-04T02:04:52.937Z","comments":true,"path":"blog/terraform/terraform进阶实践/","link":"","permalink":"http://www.matosiki.site/blog/terraform/terraform%E8%BF%9B%E9%98%B6%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"架构图 一、导入terraform 用户导入现有的基础结构 二、状态Terraform必须存储有关托管基础架构和配置的状态。Terraform使用此状态将现实世界资源映射到您的配置，跟踪元数据并提高大型基础架构的性能。默认情况下，此状态存储在名为“terraform.tfstate”的本地文件中，但也可以远程存储，这在团队环境中更有效。 Terraform使用此本地状态来创建计划并对您的基础架构进行更改。在任何操作之前，Terraform会进行 刷新以使用真实基础架构更新状态。 terraform state命令，使用CLI对状态进行基本修改。 terraform state目的 映射真实世界 terraform需要某种数据库来将Terraform配置映射到现实世界。 元数据 Terraform通常使用配置来确定依赖顺序，但是，从Terraform配置中删除资源时，Terraform必须知道如何删除该资源。Terraform还出于类似的原因存储其他元数据，例如指向最近在存在多个别名提供程序的情况下与资源一起使用的提供程序配置的指针。 表现Terraform还为状态中的所有资源存储属性值的缓存，terraform plan，Terraform必须知道当前的资源状态，以便有效地确定为达到所需配置而需要进行的更改 同步在默认配置中，Terraform将状态存储在运行Terraform的当前工作目录中的文件中 导入现有资源 锁如果您的后端支持，Terraform将锁定您可以写入状态的所有操作的状态。这可以防止他人获得锁定并可能破坏您的状态。 工作空间每个Terraform配置都有一个关联的后端 ，用于定义操作的执行方式以及存储Terraform状态等持久性数据的位置。 支持工作区有： AzureRM、Consul、GCS、local、manta、pg、remote、S3当前工作区插值 resource &quot;aws_instance&quot; &quot;example&quot; &#123; count &#x3D; &quot;$&#123;terraform.workspace &#x3D;&#x3D; &quot;default&quot; ? 5 : 1&#125;&quot; # ... other arguments&#125; 远程状态 将状态远程存储起来，Terraform还可以使用 状态锁定来防止Terraform在同一状态下并发运行，从而到达团队协作。 敏感数据使用本地状态时，state存储在纯文本JSON文件中。使用远程状态时，状态仅在Terraform使用时保存在内存中。它可以在静止时加密，但这取决于特定的远程状态后端。远程存储状态可能会为您提供静态加密，具体取决于您选择的后端。 三、提供商云提供商: 亚马逊、谷歌、百度云、阿里云、腾讯云等等。 四、预配器 connect 预配器provisioner &quot;file&quot; &#123; source &#x3D; &quot;conf&#x2F;myapp.conf&quot; destination &#x3D; &quot;&#x2F;etc&#x2F;myapp.conf&quot; connection &#123; type &#x3D; &quot;ssh&quot; user &#x3D; &quot;root&quot; password &#x3D; &quot;$&#123;var.root_password&#125;&quot; &#125;&#125;# Copies the file as the Administrator user using WinRMprovisioner &quot;file&quot; &#123; source &#x3D; &quot;conf&#x2F;myapp.conf&quot; destination &#x3D; &quot;C:&#x2F;App&#x2F;myapp.conf&quot; &#x2F;&#x2F; connection块来覆盖这些默认值 connection &#123; type &#x3D; &quot;winrm&quot; user &#x3D; &quot;Administrator&quot; password &#x3D; &quot;$&#123;var.admin_password&#125;&quot; host &#x3D; &quot;192.168.0.1&quot; timeout &#x3D; &quot;30s&quot; script_path &#x3D; &quot;path&quot; &#x2F;&#x2F;用于复制脚本的路径，用于远程执行。 &#125;&#125; 没有资源的预配器null_resource被视为普通资源 chefchef预配安装，配置和运行上的远程资源的厨师客户端该chef预配有特定的连接类型的一些先决条件： 对于ssh类型连接，cURL必须在远程主机上可用。 对于winrm连接，PowerShell 2.0必须在远程主机上可用。 文件预配器该file预配用于从执行Terraform到新创建的资源的机器复制文件或目录。resource &quot;aws_instance&quot; &quot;web&quot; &#123; # ... # Copies the myapp.conf file to &#x2F;etc&#x2F;myapp.conf provisioner &quot;file&quot; &#123; source &#x3D; &quot;conf&#x2F;myapp.conf&quot; destination &#x3D; &quot;&#x2F;etc&#x2F;myapp.conf&quot; &#125;&#125; habitathabitat预配装的Habitat管理者和配置加载服务先决条件：对于ssh类型连接，我们假设在远程主机上有一些工具可用： curl tee setsid- 仅在使用unmanaged服务类型时 local-exec在local-exec创建资源后供应者调用本地可执行文件。 Puppet 预配器先决条件： 对于ssh类型连接，cURL必须在远程主机上可用。对于winrm连接，PowerShell 2.0必须在远程主机上可用。 remote-execremote-exec供应方的远程资源调用的脚本在创建后。 salt-masterlesssalt-masterlessTerraform供应方规定的机器使用内置Terraform salt的状态，而无需连接到salt-masterless 五、模块 发布来源terraform registry 上发布模块公共的模块 自己实现api 来源类型在module块中source参数告诉terraform从哪里找到子module有如下方式： 本地路径 terraform registry github bitbucket 公共git仓库 http urls s3 bucket gcs bucket 模块组成依赖性倒置有条件地创建对象多云抽象仅数据模块 核心: 定义 main.tf 资源定义值文件 outputs.tf 输出变量,用于其他模块引用 aliables.tf 输入变量,用于获取外部变量. 引用使用外部module 六、后端后端的作用,可以团队工作、保持磁盘上的敏感信息和远程操作。后端初始化配置好后端使用配置进行terraform init terraform &#123; backend &quot;consul&quot; &#123; address &#x3D; &quot;demo.consul.io&quot; scheme &#x3D; &quot;https&quot; path &#x3D; &quot;example_app&#x2F;terraform_state&quot; &#125;&#125; 后端负责存储状态并提供状态锁定API手动推拉从远程状态中检索状态 七、插件Terraform供应商插件提供。gong’kai特定服务和配置程序。安装插件将插件放入%APPDATA%\\terraform.d\\plugins目录下。开发插件package mainimport ( &quot;github.com&#x2F;hashicorp&#x2F;terraform&#x2F;plugin&quot;)func main() &#123; plugin.Serve(new(MyPlugin)) &#x2F;&#x2F;实现Provider或Provisioner&#125; provider插件插件提供者负责资源的生命周期：创建、读取、更新和删除。提供插件 import ( &quot;github.com&#x2F;hashicorp&#x2F;terraform&#x2F;helper&#x2F;schema&quot; &quot;github.com&#x2F;hashicorp&#x2F;terraform&#x2F;terraform&quot;)&#x2F;&#x2F;这是提供程序本身的配置架构 func Provider() terraform.ResourceProvider &#123; return &amp;schema.Provider&#123; DataSourcesMap: map[string]*schema.Resource&#123; &quot;template_file&quot;: dataSourceFile(), &quot;template_cloudinit_config&quot;: dataSourceCloudinitConfig(), &#125;, ResourcesMap: map[string]*schema.Resource&#123; &quot;template_file&quot;: schema.DataSourceResourceShim( &quot;template_file&quot;, dataSourceFile(), ), &quot;template_cloudinit_config&quot;: schema.DataSourceResourceShim( &quot;template_cloudinit_config&quot;, dataSourceCloudinitConfig(), ), &quot;template_dir&quot;: resourceDir(), &#125;, &#125;&#125; 部分状态改变操作 func resourceUpdate(d *schema.ResourceData, meta interface&#123;&#125;) error &#123; &#x2F;&#x2F; Enable partial state mode d.Partial(true) if d.HasChange(&quot;tags&quot;) &#123; &#x2F;&#x2F; 如果tags属性值变化了进行其他操作 &#x2F;&#x2F; If an error occurs, return with an error, &#x2F;&#x2F; we didn&#39;t finish updating if err :&#x3D; updateTags(d, meta); err !&#x3D; nil &#123; return err &#125; d.SetPartial(&quot;tags&quot;) &#125; if d.HasChange(&quot;name&quot;) &#123; if err :&#x3D; updateName(d, meta); err !&#x3D; nil &#123; return err &#125; d.SetPartial(&quot;name&quot;) &#125; &#x2F;&#x2F; We succeeded, disable partial mode d.Partial(false) return nil&#125; 八、内幕调试terraform设置日志打印环境变量中添加 # 打印等级 TRACE，DEBUG，INFO，WARN或ERRORTF_LOG&#x3D;TRACETF_LOG_PATH&#x3D;path Terraform崩溃（Go运行时中的“恐慌”），它会保存一个日志文件，其中包含来自会话的调试日志以及恐慌消息和回溯到crash.log 资源图 所有资源组合编排实际在terraform中，组成了一个复杂的资源依赖图，资源图由资源节点、提供者配置节点和资源元节点组成，所以并发构建其实是对图中未依赖的资源节点和依赖的执行节点进行并发创建. terraform是支持并发构建的。让我默认看看terraform资源图创建与遍历原理，来理解terraform并发创建基础设施。图形节点： 资源节点 - 表示单个资源 count设置了元参数，那么每个计数将有一个资源节点 （更改中的资源的配置，差异，状态等附加到此节点。） 提供者配置节点 -表示完全配置提供者的时机，将提供者配置提供给提供者的实际，如aws安全认证3.资源源节点 -表示一组资源，但不代表任何操作构建图形: 根据配置添加资源节点。如果存在diff（计划）或状态，则将该元数据附加到每个资源节点。 如果资源有任何已定义的资源，则映射到资源。必须在创建所有资源节点后执行此操作，以便具有相同配置程序类型的资源可以共享配置程序实现。 depends_on元参数的显式依赖关系用于创建资源边缘。 如果存在状态，则将任何“孤立”资源添加到图形中。孤立资源是配置中不再存在但存在于状态文件中的任何资源。孤儿永远不会有任何与之关联的配置，因为状态文件不存储配置。 资源映射到提供者。为这些提供程序创建提供程序配置节点，并创建边缘，以便资源依赖于正在配置的各自提供程序。 在资源和提供程序配置中解析插值以确定依赖性。对资源属性的引用变为从具有内插的资源到被引用资源的依赖性。 创建根节点。根节点指向所有资源并且已创建，因此依赖关系图中只有一个根。遍历图形时，将忽略根节点。 如果存在diff，则遍历所有资源节点并查找正在销毁的资源。这些资源节点分为两个：一个销毁资源的节点和另一个创建资源的节点（如果正在重新创建）。必须拆分节点的原因是因为销毁顺序通常与创建顺序不同，因此它们不能由单个图节点表示。 验证图表没有周期并且具有单个根节点。遍历图形：遍历图形，采用一个标准的深度优先遍历方式，图的遍历是并行的，一旦遍历所有依赖关系，就运行一个节点。默认图表同时操作10个节点，也可以使用-parallelism参数更改并发数 资源的生命周期 ValidateResource被称为对资源配置进行高级结构验证。 Diff使用当前状态和配置调用。 Apply用当前状态和差异调用。 如果资源刚刚创建且之前不存在，并且应用成功而没有错误，则按顺序执行配置程序。如果任何供应商错误，资源被标记为 污染，以便在下次申请时将其销毁。 资源地址一个资源地址是引用了一个更大的基础设施中的特定资源的字符串。 模块路径module.A.module.B.module.C... 资源规格resource_type.resource_name[N] json输出格式状态表示、计划表示、值表示形式、配置表示和更改表示都可以使用json的方式查看。 远程服务发现插件","categories":[],"tags":[]},{"title":"blog/tools/高效的使用Postman进行API调试","slug":"blog/tools/高效的使用Postman进行API调试","date":"2020-06-04T02:02:07.180Z","updated":"2020-06-04T02:02:07.181Z","comments":true,"path":"blog/tools/高效的使用Postman进行API调试/","link":"","permalink":"http://www.matosiki.site/blog/tools/%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8Postman%E8%BF%9B%E8%A1%8CAPI%E8%B0%83%E8%AF%95/","excerpt":"","text":"简介在postman使用中,很多接口使用共同的请求地址和相同的参数,这样我们可以定义一些公共的环境变量,每个collection可以使用变量.postman也内置了一些变量,比如生成随机数,生成字符串,生成id,这些变量用于表单测试是非常方便的. 下面我就简简单单定义变量和请求参数自定义装饰器并测试结果. 定义环境变量在postman中可以自定义环境变量,我们可以添加全局变量也可以添加自定义collection的变量,这里我定义了一个,eureka集合的变量,其中包含主机名和端口地址等变量. 使用变量使用变量目前有三种方式: 第一种如图,在表单中添加变量,注意使用 中的变量将会被定义的变量值替换掉 第二种如图, 在使用application/json的方式发送请求时,就没办法使用 形式的变量.此时我们需要在pre-request-Srcipt中手动些装饰器,将替换掉.在这种方式下可分为两种具体实现: 方式一:将使用replace替换 内置变量 方式二:解析json为obj对象,然后更改obj对象的值 json请求值:&#123; &quot;instance&quot;: &#123; &quot;instanceId&quot;: &quot;&#123;&#123;appID&#125;&#125;:11101&quot;, &quot;app&quot;: &quot;&#123;&#123;appID&#125;&#125;&quot;, &quot;appGroutName&quot;: null, &quot;ipAddr&quot;: &quot;127.0.0.1&quot;, &quot;sid&quot;: &quot;na&quot;, &quot;homePageUrl&quot;: null, &quot;statusPageUrl&quot;: null, &quot;healthCheckUrl&quot;: null, &quot;secureHealthCheckUrl&quot;: null, &quot;vipAddress&quot;: &quot;tf-service&quot;, &quot;secureVipAddress&quot;: &quot;tf-service&quot;, &quot;countryId&quot;: 1, &quot;dataCenterInfo&quot;: &#123; &quot;@class&quot;: &quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;, &quot;name&quot;: &quot;MyOwn&quot; &#125;, &quot;hostName&quot;: &quot;127.0.0.1&quot;, &quot;status&quot;: &quot;UP&quot;, &quot;leaseInfo&quot;: null, &quot;isCoordinatingDiscoveryServer&quot;: false, &quot;lastUpdatedTimestamp&quot;: 1529391461000, &quot;lastDirtyTimestamp&quot;: 1529391461000, &quot;actionType&quot;: null, &quot;asgName&quot;: null, &quot;overridden_status&quot;: &quot;UNKNOWN&quot;, &quot;port&quot;: &#123; &quot;$&quot;: 11102, &quot;@enabled&quot;: &quot;false&quot; &#125;, &quot;securePort&quot;: &#123; &quot;$&quot;: 7002, &quot;@enabled&quot;: &quot;false&quot; &#125;, &quot;metadata&quot;: &#123; &quot;@class&quot;: &quot;java.util.Collections$EmptyMap&quot; &#125; &#125;&#125;pre-request-Srcipt中的内容&#x2F;&#x2F; 检查请求头是否是jsonfunction isJsonReq()&#123; var header &#x3D; pm.request.headers; header.each(function(v)&#123; if(v[&#39;key&#39;]&#x3D;&#x3D;&#39;Content-Type&#39;&amp;&amp;v[&#39;value&#39;]&#x3D;&#x3D;&quot;application&#x2F;json&quot;)&#123; return true; &#125; &#125;); return false; &#125;&#x2F;&#x2F; 方法一: 替换全局变量pm.request.body.raw &#x3D; replace(pm.request.body.raw);console.log(pm.request)function replace(reqbody)&#123; if(reqbody&amp;&amp;isJsonReq())&#123; var values &#x3D; pm.environment.values; values.each(function(v)&#123; reqbody &#x3D; reqbody.replace(new RegExp(&quot;&#123;&#123;&quot;+v[&#39;key&#39;]+&quot;&#125;&#125;&quot;,&#39;g&#39;),v[&#39;value&#39;]) &#125;) &#125; return reqbody;&#125; &#x2F;&#x2F; 方法二: 动态生成编号gen(pm.request.body.raw);console.log(pm.ace)function gen(reqbody)&#123; if(reqbody&amp;&amp;isJsonReq())&#123; var obj &#x3D; JSON.parse(reqbody) obj &#x3D; doit(obj) &#x2F;&#x2F;实现对象属性值替换 pm.request.body.raw &#x3D; JSON.stringify(obj) &#125;&#125;function doit(obj)&#123; obtuoj[&#39;instance&#39;][&#39;instanceID&#39;]&#x3D;require(&#39;uuid&#39;)(); &#x2F;&#x2F; todo 替换变量 console.log(obj) return obj;&#125; 使用高级js库在postman的沙盒环境中,我们可以使用一些高级的js库.我们可以在pre-request-script和end-test中使用. var Ajv &#x3D; require(&#39;ajv&#39;);var ajv &#x3D; new Ajv();&#x2F;&#x2F; 根据schema验证json&#x2F;&#x2F; var validate &#x3D; ajv.compile(schema);&#x2F;&#x2F; var valid &#x3D; validate(data);&#x2F;&#x2F; if (!valid) console.log(validate.errors);&#x2F;&#x2F; atob var atob &#x3D; require(&#39;atob&#39;);var b64 &#x3D; &quot;SGVsbG8sIFdvcmxkIQ&#x3D;&#x3D;&quot;;var bin &#x3D; atob(b64); &#x2F;&#x2F; base64转ascii码console.log(bin);var btoa &#x3D; require(&#39;btoa&#39;);var b64 &#x3D; btoa(bin);console.log(b64);var should &#x3D; require(&#39;chai&#39;).should() &#x2F;&#x2F; BDD&#x2F;TDD assert 库 , foo &#x3D; &#39;bar&#39; , beverages &#x3D; &#123; tea: [ &#39;chai&#39;, &#39;matcha&#39;, &#39;oolong&#39; ] &#125;;foo.should.be.a(&#39;string&#39;);foo.should.equal(&#39;bar&#39;);foo.should.have.lengthOf(3);beverages.should.have.property(&#39;tea&#39;).with.lengthOf(3)var CryptoJS &#x3D; require(&quot;crypto-js&quot;);console.log(CryptoJS.HmacSHA1(&quot;Message&quot;, &quot;Key&quot;));var moment &#x3D; require(&#39;moment&#39;);console.log(moment().format())const uuidv1 &#x3D; require(&#39;uuid&#39;);console.log(uuidv1())const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;);const decoder &#x3D; new StringDecoder(&#39;utf8&#39;);const cent &#x3D; Buffer.from([0xC2, 0xA2]);console.log(decoder.write(cent));const path &#x3D; require(&#39;path&#39;);console.log(path.basename(&#39;C:\\\\temp\\\\myfile.html&#39;))const assert &#x3D; require(&#39;assert&#39;);assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, &#39;3&#39;]], 4, 5]);const util &#x3D; require(&#39;util&#39;);&#x2F;&#x2F; console.log(require(&#39;lodash&#39;).join([1,24,5],[1234]))var _ &#x3D; require(&#39;lodash&#39;);console.log(_.random(5, true)) &#x2F;&#x2F;生成随机数1-5var abc &#x3D; function(a,b,c)&#123; return [a,b,c];&#125;var curried &#x3D; _.curry(abc);console.log(curried(1)(2)(3)) &#x2F;&#x2F;函数柯里化console.log(_.now()) &#x2F;&#x2F;获取当前时间搓var timer &#x3D; require(&#39;timers&#39;)console.log(timer) 测试结果在每次请求后还可以编写断言脚本验证结果 tests[&quot;请求成功&quot;] &#x3D; responseCode.code &#x3D;&#x3D;&#x3D; 204;pm.test(&quot;注册新实例成功&quot;, function () &#123; pm.response.to.have.body(&quot;&quot;);&#125;); 参考: postman官方文档-sanbox","categories":[],"tags":[]},{"title":"blog/java/java统计字符串中字符出现的次数","slug":"blog/java/java统计字符串中字符出现的次数","date":"2020-06-04T02:02:07.179Z","updated":"2020-06-04T02:06:12.075Z","comments":true,"path":"blog/java/java统计字符串中字符出现的次数/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","excerpt":"","text":"1. 使用java原生方式for循环String someString = \"elephant\";char someChar = 'e';int count = 0; for (int i = 0; i &lt; someString.length(); i++) &#123; if (someString.charAt(i) == someChar) &#123; count++; &#125;&#125;assertEquals(2, count); 2. 使用java原生递归调用private static int countOccurences( String someString, char searchedChar, int index) &#123; if (index &gt;= someString.length()) &#123; return 0; &#125; int count = someString.charAt(index) == searchedChar ? 1 : 0; return count + countOccurences( someString, searchedChar, index + 1);&#125; 3. 使用正则表达式Pattern pattern = Pattern.compile(\"[^e]*e\");Matcher matcher = pattern.matcher(\"elephant\");int count = 0;while (matcher.find()) &#123; count++;&#125; assertEquals(2, count); 4.使用java8String someString = \"elephant\";long count = someString.chars().filter(ch -&gt; ch == 'e').count();assertEquals(2, count); long count2 = someString.codePoints().filter(ch -&gt; ch == 'e').count();assertEquals(2, count2); 使用外部jar包5. 使用lang包int count = StringUtils.countMatches(\"elephant\", \"e\");assertEquals(2, count); 6. 使用guavaint count = CharMatcher.is('e').countIn(\"elephant\");assertEquals(2, count); 7.使用spring utilsint count = StringUtils.countOccurrencesOf(\"elephant\", \"e\");assertEquals(2, count); 总结: 原生方式简单粗暴,也可以使用其他工具类,但使用java8感觉最优雅.","categories":[],"tags":[]},{"title":"blog/java/jvm工作原理","slug":"blog/java/jvm工作原理","date":"2020-06-04T02:02:07.179Z","updated":"2020-06-04T02:06:15.910Z","comments":true,"path":"blog/java/jvm工作原理/","link":"","permalink":"http://www.matosiki.site/blog/java/jvm%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"一、 JVM的生命周期 JVM实例对应了一个独立运行的java程序它是进程级别a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出 JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的 二、 JVM的体系结构 类装载器（ClassLoader）（用来装载.class文件） 执行引擎（执行字节码，或者执行本地方法） 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈） 三、 JVM类加载器JVM整个类加载过程的步骤： 装载装载过程负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：类名+包名+ClassLoader实例ID。 链接链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。完成校验后，JVM初始化类中的静态变量，并将其值赋为默认值。最后对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。 初始化初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，在四种情况下初始化过程会被触发执行：调用了new；反射调用了类中的方法；子类调用了初始化；JVM启动过程中指定的初始化类。 VM类加载顺序：JVM两种类装载器包括：启动类装载器和用户自定义类装载器。启动类装载器是JVM实现的一部分；用户自定义类装载器则是Java程序的一部分，必须是ClassLoader类的子类。JVM装载顺序： Jvm启动时，由Bootstrap向User-Defined方向加载类； 应用进行ClassLoader时，由User-Defined向Bootstrap方向查找并加载类； Bootstrap ClassLoaderzh这是JVM的根ClassLoader，它是用C++实现的，JVM启动时初始化此ClassLoader，并由此ClassLoader完成$JAVA_HOME中jre/lib/rt.jar（Sun JDK的实现）中所有class文件的加载，这个jar中包含了java规范定义的所有接口以及实现。 Extension ClassLoaderJVM用此classloader来加载扩展功能的一些jar包。 System ClassLoaderJVM用此classloader来加载启动参数中指定的Classpath中的jar包以及目录，在Sun JDK中ClassLoader对应的类名为AppClassLoader。 User-Defined ClassLoaderUser-DefinedClassLoader是Java开发人员继承ClassLoader抽象类自行实现的ClassLoader，基于自定义的ClassLoader可用于加载非Classpath中的jar以及目录。 ClassLoader抽象类的几个关键方法：（1） loadClass 此方法负责加载指定名字的类，ClassLoader的实现方法为先从已经加载的类中寻找，如没有则继续从parent ClassLoader中寻找，如仍然没找到，则从System ClassLoader中寻找，最后再调用findClass方法来寻找，如要改变类的加载顺序，则可覆盖此方法（2） findLoadedClass此方法负责从当前ClassLoader实例对象的缓存中寻找已加载的类，调用的为native的方法。（3） findClass此方法直接抛出ClassNotFoundException，因此需要通过覆盖loadClass或此方法来以自定义的方式加载相应的类。（4） findSystemClass此方法负责从System ClassLoader中寻找类，如未找到，则继续从Bootstrap ClassLoader中寻找，如仍然为找到，则返回null。（5） defineClass此方法负责将二进制的字节码转换为Class对象（6） resolveClass此方法负责完成Class对象的链接，如已链接过，则会直接返回。 四、 JVM执行引擎在执行方法时JVM提供了四种指令来执行：（1）invokestatic：调用类的static方法（2）invokevirtual：调用对象实例的方法（3）invokeinterface：将属性定义为接口来进行调用（4）invokespecial：JVM对于初始化对象（Java构造器的方法为：）以及调用对象实例中的私有方法时。 主要的执行技术有:解释，即时编译，自适应优化、芯片级直接执行（1）解释属于第一代JVM，（2）即时编译JIT属于第二代JVM，（3）自适应优化（目前Sun的HotspotJVM采用这种技术）则吸取第一代JVM和第二代JVM的经验，采用两者结合的方式 开始对所有的代码都采取解释执行的方式，并监视代码执行情况，然后对那些经常调用的方法启动一个后台线程，将其编译为本地代码，并进行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。 五、 JVM运行时数据区第一块：PC寄存器PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。第二块：JVM栈JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址第三块：堆（Heap）它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。（1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。第四块：方法区域（Method Area）（1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。（2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class 对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。第五块：运行时常量池（Runtime Constant Pool）存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。第六块：本地方法堆栈（Native Method Stacks）JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。 六、 JVM垃圾回收GC的基本原理： 将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停（1）对新生代的对象的收集称为minor GC；（2）对旧生代的对象的收集称为Full GC；（3）程序中主动调用System.gc()强制执行的GC为Full GC。不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）（3）弱引用：在GC时一定会被GC回收（4）虚引用：由于虚引用只是用来得知对象是否被GC","categories":[],"tags":[]},{"title":"blog/java/java的字符串转枚举类型","slug":"blog/java/java的字符串转枚举类型","date":"2020-06-04T02:02:07.179Z","updated":"2020-06-04T02:06:20.606Z","comments":true,"path":"blog/java/java的字符串转枚举类型/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"假定一个美酒类型PizzaStatusEnum readyStatus = PizzaStatusEnum.READY; 使用 valueOf(“”)方法@Testpublic void whenConvertedIntoEnum_thenGetsConvertedCorrectly() &#123; String pizzaEnumValue = \"READY\"; PizzaStatusEnum pizzaStatusEnum = PizzaStatusEnum.valueOf(pizzaEnumValue); assertTrue(pizzaStatusEnum == PizzaStatusEnum.READY);&#125; 注意: 如果参数不对,会抛出非法参数异常@Test(expected = IllegalArgumentException.class)public void whenConvertedIntoEnum_thenThrowsException() &#123; String pizzaEnumValue = \"invalid\"; PizzaStatusEnum pizzaStatusEnum = PizzaStatusEnum.valueOf(pizzaEnumValue);&#125;","categories":[],"tags":[]},{"title":"blog/java/oauth2-0-深入理解","slug":"blog/java/oauth2-0-深入理解","date":"2020-06-04T02:02:07.179Z","updated":"2020-06-04T02:06:05.548Z","comments":true,"path":"blog/java/oauth2-0-深入理解/","link":"","permalink":"http://www.matosiki.site/blog/java/oauth2-0-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","excerpt":"","text":"OAuth2.0是什么用于REST/APIS的代理授权框架（delegatedauthorizetion framework）,基于令牌token的授权，在无需暴露用户密码的情况下，使应用能够对用户数据有效访问权限，充分解耦认证和授权，实际上是标准的安全架构，支持多种应用场景，服务器端WebApp,浏览器单页面SPA，无线原生App,服务器与服务器之间访问。像仆从钥匙，给应用授权优先的访问权限，代表用户访问用户数据。OAoth是系统之间代理授权协议 优点 易实现 安全，服务端不接触用户密码，服务单更容易集中保护。 广泛传播被持续采用 短寿命和封装的token 资源服务器和授权服务器解耦 集中授权简化客户端 HTTP/JSON友好易于请求和传递token 考虑多种客户端架构场景 客户可以具有不同的信任级别 缺点 协议框架太宽泛，造成各种实现的兼容性和互操作性 与OAuth1.0不兼容 OAuth 2.0 不是一个认证协议，OAuth2.0本身并不能告诉你任何用户信息 架构角色1.授权服务 Authorization Service客户应用成功认证并获得授权之后，向客户应用颁发访问令牌。 2.资源服务 Resource Service一个web服务或者web应用，保存用户受保护的数据 3.客户端应用 Client Application通常是一个浏览器或者手机app，它需要用户受保护的数据 4.资源拥有者 owner数据拥有者，想把数据分享给他人使用 客户端应用需要访问资源服务,但是没有认证,此时客户端去授权服务获取认证令牌,拿到令牌后交给资源服务器,资源服务器拿到令牌后也去授权服务比较一次,如果是对的,就认证通过. OAuth2.0语术概念1.客户凭证 Client Credentials客户的clientId和密码用户认证客户 2.令牌 Tokens授权服务器在接收到客户请求后颁发的资源服务器令牌类型 授权码 (Authorization Code Token) 仅用于授权码类型，用于交换获取访问令牌和刷新令牌 刷新令牌 (Refresh Token) 用于去授权服务器获取一个新的token 访问令牌 (Access Token) 代表用户直接访问受保护的资源服务器 Bearer Token 不管谁拿到都可以访问资源 Proof of Prosession Token 可以校验Client是否对Token有明确的权限 3.作用域客户请求访问令牌时，有资源拥有者额外指定的细分权限 应用场景,解决方案一、开放间系统授权1.社交联合登陆 2.开放API平台 二、现代微服务安全1.单页面浏览器APP 2.无线原生APP 3.服务端WebApp 4.微服务和原生API调用 三、企业内部认证授权(IAM,SSO)AOuth Flow推荐两篇文章 https://tools.ietf.org/html/rfc6749 理解OAuth 2.0 - 阮一峰的网络日志 客户端的授权模式1. 授权码模式 授权步骤 A.用户访问客户端,客户端重定向到认证服务器. B.用户选择授权客户端 C.如果用户授权,授权服务器重定向到客户端带来的url并附加一个授权码 D.客户端附带重定向url和授权码后台请求授权服务器申请令牌 E.授权服务器校对授权码和重定向url,确认无误,向客户端发送访问令牌(Access Token)和刷新令牌(Refresh Token) 基于spring security oauth2.0搭建最简授权码模式服务器一、 源码资源服务器和授权服务器一起案例 引入jar包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!-- OAuth 2.0 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 添加授权服务器配置 &#x2F;&#x2F;授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) .redirectUris(&quot;http:&#x2F;&#x2F;localhost:9001&#x2F;callback&quot;) &#x2F;&#x2F; 授权码模式 .authorizedGrantTypes(&quot;authorization_code&quot;) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125;&#125; 添加资源服务器配置 &#x2F;&#x2F;资源服务配置@Configuration@EnableResourceServerpublic class OAuth2ResourceServer extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers(&quot;&#x2F;api&#x2F;**&quot;); &#125;&#125; 配置添加授权用户 # Spring Security Settingsecurity.user.name&#x3D;user1security.user.password&#x3D;passwd1 添加资源服务器api入口 @Controllerpublic class UserController &#123; &#x2F;&#x2F; 资源API @RequestMapping(&quot;&#x2F;api&#x2F;userinfo&quot;) public ResponseEntity&lt;UserInfo&gt; getUserInfo() &#123; User user &#x3D; (User) SecurityContextHolder.getContext() .getAuthentication().getPrincipal(); String email &#x3D; user.getUsername() + &quot;@hello.com&quot;; UserInfo userInfo &#x3D; new UserInfo(); userInfo.setName(user.getUsername()); userInfo.setEmail(email); return ResponseEntity.ok(userInfo); &#125;&#125; 启动服务器 二、实践 获取授权码 请求：打开浏览器 输入地址： http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;clientapp&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:9001&#x2F;callback&amp;response_type&#x3D;code&amp;scope&#x3D;read_userinfo 输入用户名和密码，选择授权。 请求：页面会跳转一个callback地址加授权码http:&#x2F;&#x2F;localhost:9001&#x2F;callback?code&#x3D;4PFZ2w 获取令牌 请求：curl -X POST --user clientapp:123456 http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;token -H&quot;content-type: application&#x2F;x-www-form-urlencoded&quot; -d&quot;code&#x3D;4PFZ2w&amp;grant_type&#x3D;authorization_code&amp;redirect_uri&#x3D;http%3A%2F%2Flocalhost%3A9001%2Fcallback&amp;scope&#x3D;read_userinfo&quot; 响应：&#123;\"access_token\":\"44a572ca-3a05-40ba-a557-35955179e143\",\"token_type\":\"bearer\",\"expires_in\":43199,\"scope\":\"read_userinfo\"&#125; 访问资源，调用API请求： curl -X GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;userinfo -H &quot;authorization: Bearer 44a572ca-3a05-40ba-a557-35955179e143&quot; 响应： &#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 通过前端渠道客户获取授权码 通过后端渠道,客户使用authorization code 交换access token 或refresh token 假定资源拥有者和客户在不同的设备上 最安全的流程,因为令牌不会传递经过User-Agent 总结: 授权码模式本质上是客户端通过用户名密码发起获取授权码请求,服务端根据回调地址返回授权码,客户端根据授权码访问资源服务器,资源服务器根据授权码拿到授权服务器给的access token返回给客户端,客户端就可以带着这个access token访问资源服务器上的有效资源. 2. 简化模式 授权步骤 客户端重定向用户到认证服务器 用户选择是否授权给客户端 用户授权,授权服务器根据客户端请求参数uri重定向到客户端,并将token放入url的hash部分 资源服务返回一个页面,可以获取hash值 浏览器执行脚本获取令牌 浏览器叫令牌发送给客户端 基于spring security oauth2.0搭建简化模式服务器一、 源码资源服务器和授权服务器一起案例 引入spring security 和 oauth jar包 授权服务器配置 &#x2F;&#x2F;简化服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) .redirectUris(&quot;http:&#x2F;&#x2F;localhost:9001&#x2F;callback&quot;) &#x2F;&#x2F; 授权码模式 &#x2F;&#x2F;.authorizedGrantTypes(&quot;authorization_code&quot;) &#x2F;&#x2F; 简化模式 .authorizedGrantTypes(&quot;implicit&quot;) .accessTokenValiditySeconds(120) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125;&#125; 二、操作 获取令牌访问浏览器http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;authorize?client_id&#x3D;clientapp&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:9001&#x2F;callback&amp;response_type&#x3D;token&amp;scope&#x3D;read_userinfo&amp;state&#x3D;abc 输入配置的用户和密码，选择授权。响应： http:&#x2F;&#x2F;localhost:9001&#x2F;callback#access_token&#x3D;d678754d-752c-46cc-9a9b-d59ae830cddb&amp;token_type&#x3D;bearer&amp;state&#x3D;abc&amp;expires_in&#x3D;119 访问资源，调用API curl -X GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;userinfo -H &quot;authorization: Bearer d678754d-752c-46cc-9a9b-d59ae830cddb&quot; 响应：&#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 适用于公开的浏览器单页面应用 Access Token 直接从授权服务器返回 不支持Refresh Token 假定资源拥有者和客户在同一设备上 最容易受安全攻击 总结：简化模式，就是没有授权码的授权模式，去掉了授权码这个步骤。 3. 密码模式 Resource Owner Password Credential Grant 授权步骤 用户向客户端提供用户名和密码 客户端将用户名和密码发送给认证服务器去认证授权 认证服务器验证无误，返回给客户端令牌 基于spring security oauth2.0搭建密码模式服务器一、代码授权服务器配置&#x2F;&#x2F; 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; &#x2F;&#x2F; 用户认证 @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) &#x2F;&#x2F; 密码模式 .authorizedGrantTypes(&quot;password&quot;) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125;&#125; 一、操作 获取令牌 curl -X POST --user clientapp:123456 http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;token -H &quot;accept: application&#x2F;json&quot; -H &quot;content-type: application&#x2F;x-www-form-urlencoded&quot; -d &quot;grant_type&#x3D;password&amp;username&#x3D;user1&amp;password&#x3D;passwd1&amp;scope&#x3D;read_userinfo&quot; 响应： &#123;&quot;access_token&quot;:&quot;9247e26e-b9d7-488b-88b0-25fb046ac7ce&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;expires_in&quot;:43163,&quot;scope&quot;:&quot;read_userinfo&quot;&#125; 访问资源，调用API curl -X GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;userinfo -H &quot;authorization: Bearer 9247e26e-b9d7-488b-88b0-25fb046ac7ce&quot; 响应： &#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 使用用户名密码登录的应用,比如桌面应用 使用用户名/密码作为授权方式从授权服务器上获取access token 一般不支持refresh token 假定资源拥有者和公开客户在相同设备上 总结：密码授权模式，是对客户端极度信任的情况下，将用户名和密码交给客户端，客户端去授权服务器获取令牌。 4. 客户端模式 授权步骤 客户端直接向授权服务器发起授权认证，获取令牌 授权服务器校验通过，颁发令牌 基于spring security oauth2.0搭建客户端模式服务器一、代码授权服务器配置&#x2F;&#x2F; 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientdevops&quot;) &#x2F;&#x2F; 密码模式 .secret(&quot;123456&quot;) .authorizedGrantTypes(&quot;client_credentials&quot;) .scopes(&quot;devops&quot;); &#125;&#125; 二、操作 获取令牌 curl -X POST &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;token&quot; --user clientdevops:123456 -d&quot;grant_type&#x3D;client_credentials&amp;scope&#x3D;devops&quot; 响应： &#123;&quot;access_token&quot;:&quot;ab5e2936-7463-456b-9ded-aac79d9311e1&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;expires_in&quot;:43199,&quot;scope&quot;:&quot;devops&quot;&#125; 访问资源，调用API curl -X GET http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;userinfo -H &quot;authorization: Bearer ab5e2936-7463-456b-9ded-aac79d9311e1&quot; 响应：&#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 适用于服务间通信,机器代表用户或者它自己 只有后端渠道,使用客户凭证获取一个access token 因为客户凭证可以使用对称或者非对称加密,该方式支持共享密码或者证书 刷新令牌 一、代码&#x2F;&#x2F;授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) .redirectUris(&quot;http:&#x2F;&#x2F;localhost:9001&#x2F;callback&quot;) &#x2F;&#x2F; 密码模式 .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;) .accessTokenValiditySeconds(120) .refreshTokenValiditySeconds(60) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager); endpoints.userDetailsService(userDetailsService); &#125;&#125; 安全配置@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled &#x3D; true) &#x2F;&#x2F;启用方法级的权限认证public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean @Override protected UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager &#x3D; new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;user1&quot;).password(&quot;passwd1&quot;).authorities(&quot;USER&quot;).build()); manager.createUser(User.withUsername(&quot;root&quot;).password(&quot;root&quot;).authorities(&quot;USER&quot;).build()); return manager; &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 二、操作获取令牌curl -i -X POST --user clientapp:123456 http:&#x2F;&#x2F;localhost:8080&#x2F;oauth&#x2F;token -H &quot;accept: application&#x2F;json&quot; -H &quot;content-type: application&#x2F;x-www-form-urlencoded&quot; -d &quot;grant_type&#x3D;refresh_token&amp;refresh_token&#x3D;dda1413c-86e8-4612-8e13-e9044e530c66&quot; 响应： HTTP&#x2F;1.1 200X-Content-Type-Options: nosniffX-XSS-Protection: 1; mode&#x3D;blockCache-Control: no-cache, no-store, max-age&#x3D;0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYX-Application-Context: applicationCache-Control: no-storePragma: no-cacheContent-Type: application&#x2F;json;charset&#x3D;UTF-8Transfer-Encoding: chunkedDate: Fri, 12 Jul 2019 07:43:15 GMT&#123;&quot;access_token&quot;:&quot;052f2239-6231-4537-bc93-33fce4c58d0c&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;dda1413c-86e8-4612-8e13-e9044e530c66&quot;,&quot;expires_in&quot;:119,&quot;scope&quot;:&quot;read_userinfo&quot;&#125; 认证方式选择 授权服务器端点 Authorize Endpoint (/oauth2/authorize) 认证端点 Token Endpoint (/oauth2/token) 令牌端点 Introspection Endpoint (/oauth2/instrospection) 检查端点 Revocation Endpoint (/aouth2/revoke) 吊销端点 Spring Security OAuth2.0架构http://terasolunaorg.github.io/guideline/5.3.0.RELEASE/en/Security/OAuth.html","categories":[],"tags":[]},{"title":"blog/java/java中将异常栈跟踪信息转字符串","slug":"blog/java/java中将异常栈跟踪信息转字符串","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:06:44.100Z","comments":true,"path":"blog/java/java中将异常栈跟踪信息转字符串/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%AD%E5%B0%86%E5%BC%82%E5%B8%B8%E6%A0%88%E8%B7%9F%E8%B8%AA%E4%BF%A1%E6%81%AF%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1. 使用原生java代码StringWriter sw = new StringWriter();PrintWriter pw = new PrintWriter(sw);e.printStackTrace(pw); 2. 使用Common lang工具在类String stacktrace = ExceptionUtils.getStacktrace(e); 总结 获取跟踪栈异常默认不能用String,在java9中添加了StackWalking API支持栈异常跟踪","categories":[],"tags":[]},{"title":"blog/java/java使用Guava进行字符串处理","slug":"blog/java/java使用Guava进行字符串处理","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:05:45.118Z","comments":true,"path":"blog/java/java使用Guava进行字符串处理/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%BD%BF%E7%94%A8Guava%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"java使用Guava进行字符串处理从字符串中删除特定的字符@Testpublic void whenRemoveSpecialCharacters_thenRemoved()&#123; String input = \"H*el.lo,&#125;12\"; CharMatcher matcher = CharMatcher.JAVA_LETTER_OR_DIGIT; String result = matcher.retainFrom(input); assertEquals(\"Hello12\", result);&#125; 从字符串中删除不是字符串@Testpublic void whenRemoveNonASCIIChars_thenRemoved() &#123; String input = \"あhello₤\"; String result = CharMatcher.ASCII.retainFrom(input); assertEquals(\"hello\", result); result = CharMatcher.inRange('0', 'z').retainFrom(input); assertEquals(\"hello\", result);&#125; 删除不在字符集中的字符@Testpublic void whenRemoveCharsNotInCharset_thenRemoved() &#123; Charset charset = Charset.forName(\"cp437\"); CharsetEncoder encoder = charset.newEncoder(); Predicate&lt;Character&gt; inRange = new Predicate&lt;Character&gt;() &#123; @Override public boolean apply(Character c) &#123; return encoder.canEncode(c); &#125; &#125;; String result = CharMatcher.forPredicate(inRange) .retainFrom(\"helloは\"); assertEquals(\"hello\", result);&#125; 验证字符串@Testpublic void whenValidateString_thenValid()&#123; String input = \"hello\"; boolean result = CharMatcher.JAVA_LOWER_CASE.matchesAllOf(input); assertTrue(result); result = CharMatcher.is('e').matchesAnyOf(input); assertTrue(result); result = CharMatcher.JAVA_DIGIT.matchesNoneOf(input); assertTrue(result);&#125; 去除字符串空格@Testpublic void whenTrimString_thenTrimmed() &#123; String input = \"---hello,,,\"; String result = CharMatcher.is('-').trimLeadingFrom(input); assertEquals(\"hello,,,\", result); result = CharMatcher.is(',').trimTrailingFrom(input); assertEquals(\"---hello\", result); result = CharMatcher.anyOf(\"-,\").trimFrom(input); assertEquals(\"hello\", result);&#125; 折叠字符串@Testpublic void whenCollapseFromString_thenCollapsed() &#123; String input = \" hel lo \"; String result = CharMatcher.is(' ').collapseFrom(input, '-'); assertEquals(\"-hel-lo-\", result); result = CharMatcher.is(' ').trimAndCollapseFrom(input, '-'); assertEquals(\"hel-lo\", result);&#125; 替换字符串@Testpublic void whenReplaceFromString_thenReplaced() &#123; String input = \"apple-banana.\"; String result = CharMatcher.anyOf(\"-.\").replaceFrom(input, '!'); assertEquals(\"apple!banana!\", result); result = CharMatcher.is('-').replaceFrom(input, \" and \"); assertEquals(\"apple and banana.\", result);&#125; 统计字串串出现的次数@Testpublic void whenCountCharInString_thenCorrect() &#123; String input = \"a, c, z, 1, 2\"; int result = CharMatcher.is(',').countIn(input); assertEquals(4, result); result = CharMatcher.inRange('a', 'h').countIn(input); assertEquals(2, result);&#125; 总结: 使用CharMatcher处理字符串,简单方便.","categories":[],"tags":[]},{"title":"blog/java/java使用apache common工具类","slug":"blog/java/java使用apache common工具类","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:05:41.423Z","comments":true,"path":"blog/java/java使用apache common工具类/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%BD%BF%E7%94%A8apache%20common%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"查询字符串中出现任意字符String string = \"baeldung.com\";boolean contained1 = StringUtils.containsAny(string, 'a', 'b', 'c');boolean contained2 = StringUtils.containsAny(string, 'x', 'y', 'z');boolean contained3 = StringUtils.containsAny(string, \"abc\");boolean contained4 = StringUtils.containsAny(string, \"xyz\"); assertTrue(contained1);assertFalse(contained2);assertTrue(contained3);assertFalse(contained4);// 忽略大小写String string = \"matosiki.com\";boolean contained = StringUtils.containsIgnoreCase(string, \"MATOSIKI\"); assertTrue(contained); 匹配出现次数方法String string = \"welcome to www.matosiki.com\";int charNum = StringUtils.countMatches(string, 'w');int stringNum = StringUtils.countMatches(string, \"com\"); assertEquals(4, charNum);assertEquals(2, stringNum); 匹配前缀和后缀的方法String string = \"matosiki.com\";String stringWithSuffix = StringUtils.appendIfMissing(string, \".com\");String stringWithPrefix = StringUtils.prependIfMissing(string, \"www.\"); assertEquals(\"matosiki.com\", stringWithSuffix);assertEquals(\"www.matosiki.com\", stringWithPrefix); 改变大小写String originalString = \"matosiki.COM\";String swappedString = StringUtils.swapCase(originalString); assertEquals(\"MATOSIKI.com\", swappedString);// 首字母大写String capitalizedString = StringUtils.capitalize(originalString); assertEquals(\"Matosiki.COM\", capitalizedString);//首字母不大写String uncapitalizedString = StringUtils.uncapitalize(originalString); assertEquals(\"matosiki.COM\", uncapitalizedString); 翻转字符串String originalString = \"matosiki\";String reversedString = StringUtils.reverse(originalString); assertEquals(\"ikisotam\", reversedString);// 分割式翻转String originalString = \"www.matosiki.com\";String reversedString = StringUtils.reverseDelimited(originalString, '.'); assertEquals(\"com.matosiki.www\", reversedString); 使用rotate()方法旋转String originalString = \"matosiki\";String rotatedString = StringUtils.rotate(originalString, 4); assertEquals(\"sikimatos\", rotatedString); 比较不同String tutorials = \"Baeldung Tutorials\";String courses = \"Baeldung Courses\";String diff1 = StringUtils.difference(tutorials, courses);String diff2 = StringUtils.difference(courses, tutorials); assertEquals(\"Courses\", diff1);assertEquals(\"Tutorials\", diff2); 总结: 使用StringUtils对字符串进行一些常用操作","categories":[],"tags":[]},{"title":"blog/java/java分割字符串的三种方式","slug":"blog/java/java分割字符串的三种方式","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:05:50.044Z","comments":true,"path":"blog/java/java分割字符串的三种方式/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"使用java原生String.split()方法String[] splitted = \"peter,james,thomas\".split(\",\"); // 逗号分割String[] splitted = \"car jeep scooter\".split(\" \"); // 空格分割String[] splitted = \"192.168.1.178\".split(\"\\\\.\") // 点分割String[] splitted = \"b a, e, l.d u, n g\".split(\"\\\\s+|,\\\\s*|\\\\.\\\\s*\")); //则这表达式多个分割符 使用工具类Common包下的StringUtils.split()方法String[] splitted = StringUtils.split(\"car jeep scooter\"); //默认空白分割 使用guava工具包的Splitter流List&lt;String&gt; resultList = Splitter.on(',') .trimResults() .omitEmptyStrings() .splitToList(\"car,jeep,, scooter\"); 总结: String成员方法分割字符串处理简单分割比较容易,但是复杂一点使用工具类还是比较方法. 预先善其事必先利其器,多学习一些工具类的使用,提高开发效率也还不错.","categories":[],"tags":[]},{"title":"blog/java/java回文数字判断","slug":"blog/java/java回文数字判断","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:05:54.147Z","comments":true,"path":"blog/java/java回文数字判断/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E5%9B%9E%E6%96%87%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/","excerpt":"","text":"1. 使用原生java方式public boolean isPalindrome(String text) &#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); int length = clean.length(); int forward = 0; int backward = length - 1; while (backward &gt; forward) &#123; //两边指针同时变动,比较. char forwardChar = clean.charAt(forward++); char backwardChar = clean.charAt(backward--); if (forwardChar != backwardChar) return false; &#125; return true;&#125; 2. 使用字符串reverse比较public boolean isPalindromeReverseTheString(String text) &#123; StringBuilder reverse = new StringBuilder(); String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); char[] plain = clean.toCharArray(); for (int i = plain.length - 1; i &gt;= 0; i--) &#123; reverse.append(plain[i]); &#125; return (reverse.toString()).equals(clean);&#125; 3. 使用stringbuffer 和stringbuilder直接翻转字符串比较public boolean isPalindromeUsingStringBuilder(String text) &#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); StringBuilder plain = new StringBuilder(clean); StringBuilder reverse = plain.reverse(); return (reverse.toString()).equals(clean);&#125; public boolean isPalindromeUsingStringBuffer(String text) &#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); StringBuffer plain = new StringBuffer(clean); StringBuffer reverse = plain.reverse(); return (reverse.toString()).equals(clean);&#125; 4. 使用java8 intStreampublic boolean isPalindromeUsingIntStream(String text) &#123; String temp = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); return IntStream.range(0, temp.length() / 2) .noneMatch(i -&gt; temp.charAt(i) != temp.charAt(temp.length() - i - 1));&#125; 5. 使用递归调用public boolean isPalindromeRecursive(String text)&#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); return recursivePalindrome(clean,0,clean.length()-1);&#125; private boolean recursivePalindrome(String text, int forward, int backward) &#123; if (forward == backward) &#123; return true; &#125; if ((text.charAt(forward)) != (text.charAt(backward))) &#123; return false; &#125; if (forward &lt; backward + 1) &#123; return recursivePalindrome(text, forward + 1, backward - 1); &#125; return true;&#125; 总结: 回文数验证分两种 一种是移动下标比较 另一种是 翻转 比较,翻转比较性能没有下标比较好,所以建议使用java8 InStreannomatch方法","categories":[],"tags":[]},{"title":"blog/java/java截取字符串的最后一个字符方法","slug":"blog/java/java截取字符串的最后一个字符方法","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:06:27.651Z","comments":true,"path":"blog/java/java截取字符串的最后一个字符方法/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%96%B9%E6%B3%95/","excerpt":"","text":"1. 原生java方式 先判断是否为空public static String removeLastChar(String s) &#123; return (s == null || s.length() == 0) ? null : (s.substring(0, s.length() - 1));&#125; 2. 使用java8public static String removeLastCharOptional(String s) &#123; return Optional.ofNullable(s) .filter(str -&gt; str.length() != 0) .map(str -&gt; str.substring(0, str.length() - 1)) .orElse(s);&#125; 3. 使用 apache common lang StringUtils.substring()String TEST_STRING = \"ACBDEF\";StringUtils.substring(TEST_STRING,0,TEST_STRING.length()-1); 4. 使用 StringUtils.chop()方法 因对边缘场景的情况（empty or null）时StringUtils.chop(TEST_STRING) 5. 使用replaceAll() 的正则表达式方式public static String removeLastCharRegex(String s) &#123; return (s == null) ? null : s.replaceAll(\".$\", \"\");&#125;// java8public static String removeLastCharRegexOptional(String s) &#123; return Optional.ofNullable(s) .map(str -&gt; str.replaceAll(\".$\", \"\")) .orElse(s);&#125; 总结： 以上主要使用substring方法截取字符串，复杂的话建议使用正则表达式方式处理。","categories":[],"tags":[]},{"title":"blog/java/java字符类型转字符串类型六种方式","slug":"blog/java/java字符类型转字符串类型六种方式","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:05:57.536Z","comments":true,"path":"blog/java/java字符类型转字符串类型六种方式/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1. 使用String.valueOf()方法@Testpublic void givenChar_whenCallingStringValueOf_shouldConvertToString() &#123; char givenChar = 'x'; String result = String.valueOf(givenChar); assertThat(result).isEqualTo(\"x\");&#125; 2. 使用 Character.toString() 方法@Testpublic void givenChar_whenCallingToStringOnCharacter_shouldConvertToString() &#123; char givenChar = 'x'; String result = Character.toString(givenChar); assertThat(result).isEqualTo(\"x\");&#125; 3. 使用Character的构造方法@Testpublic void givenChar_whenCallingCharacterConstructor_shouldConvertToString() &#123; char givenChar = 'x'; String result = new Character(givenChar).toString(); assertThat(result).isEqualTo(\"x\");&#125; 4. 通过String的隐式转换@Testpublic void givenChar_whenConcatenated_shouldConvertToString() &#123; char givenChar = 'x'; String result = givenChar + \"\"; assertThat(result).isEqualTo(\"x\");&#125; 5.@Testpublic void givenChar_whenFormated_shouldConvertToString() &#123; char givenChar = 'x'; String result = String.format(\"%c\", givenChar); assertThat(result).isEqualTo(\"x\");&#125; 总结: 常用Stirng的隐式转换方式.","categories":[],"tags":[]},{"title":"blog/java/java生成随机字符串的五种方式","slug":"blog/java/java生成随机字符串的五种方式","date":"2020-06-04T02:02:07.178Z","updated":"2020-06-04T02:06:31.990Z","comments":true,"path":"blog/java/java生成随机字符串的五种方式/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1. 使用原生java生成无边界字符串@Testpublic void givenUsingPlainJava_whenGeneratingRandomStringUnbounded_thenCorrect() &#123; byte[] array = new byte[7]; // length is bounded by 7 new Random().nextBytes(array); String generatedString = new String(array, Charset.forName(\"UTF-8\")); System.out.println(generatedString);&#125; 2.使用原生java生成右边界字符串@Testpublic void givenUsingPlainJava_whenGeneratingRandomStringBounded_thenCorrect() &#123; int leftLimit = 97; // letter 'a' int rightLimit = 122; // letter 'z' int targetStringLength = 10; Random random = new Random(); StringBuilder buffer = new StringBuilder(targetStringLength); for (int i = 0; i &lt; targetStringLength; i++) &#123; int randomLimitedInt = leftLimit + (int) (random.nextFloat() * (rightLimit - leftLimit + 1)); buffer.append((char) randomLimitedInt); &#125; String generatedString = buffer.toString(); System.out.println(generatedString);&#125; 3.使用 apache common lang 生成有边界字符串(只用字母)@Testpublic void givenUsingApache_whenGeneratingRandomStringBounded_thenCorrect() &#123; int length = 10; boolean useLetters = true; boolean useNumbers = false; String generatedString = RandomStringUtils.random(length, useLetters, useNumbers); System.out.println(generatedString);&#125; 4. 使用 apache common lang 生成有边界字母@Testpublic void givenUsingApache_whenGeneratingRandomAlphabeticString_thenCorrect() &#123; String generatedString = RandomStringUtils.randomAlphabetic(10); System.out.println(generatedString);&#125; 5. 使用 apache common lang 生成有边界字母和数字@Testpublic void givenUsingApache_whenGeneratingRandomAlphanumericString_thenCorrect() &#123; String generatedString = RandomStringUtils.randomAlphanumeric(10); System.out.println(generatedString);&#125; 总结: 使用lang包的生成方式简单,自己原生方式也可以实现.","categories":[],"tags":[]},{"title":"blog/java/java8新增StringJoiner用法","slug":"blog/java/java8新增StringJoiner用法","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:05:21.329Z","comments":true,"path":"blog/java/java8新增StringJoiner用法/","link":"","permalink":"http://www.matosiki.site/blog/java/java8%E6%96%B0%E5%A2%9EStringJoiner%E7%94%A8%E6%B3%95/","excerpt":"","text":"使用java8的StringJoiner连接,附带分割和前缀和后缀1. 添加元素@Testpublic void whenAddingElements_thenJoinedElements() &#123; StringJoiner joiner = new StringJoiner(\",\", PREFIX, SUFFIX); joiner.add(\"Red\") .add(\"Green\") .add(\"Blue\"); assertEquals(joiner.toString(), \"[Red,Green,Blue]\");&#125; 2. 使用for循环添加内容@Testpublic void whenAddingListElements_thenJoinedListElements() &#123; List&lt;String&gt; rgbList = new ArrayList&lt;&gt;(); rgbList.add(\"Red\"); rgbList.add(\"Green\"); rgbList.add(\"Blue\"); StringJoiner rgbJoiner = new StringJoiner( \",\", PREFIX, SUFFIX); for (String color : rgbList) &#123; rgbJoiner.add(color); &#125; assertEquals(rgbJoiner.toString(), \"[Red,Green,Blue]\");&#125; 使用构造方式private String PREFIX = \"[\";private String SUFFIX = \"]\"; @Testpublic void whenEmptyJoinerWithoutPrefixSuffix_thenEmptyString() &#123; StringJoiner joiner = new StringJoiner(\",\"); assertEquals(0, joiner.toString().length());&#125; @Testpublic void whenEmptyJoinerJoinerWithPrefixSuffix_thenPrefixSuffix() &#123; StringJoiner joiner = new StringJoiner( \",\", PREFIX, SUFFIX); assertEquals(joiner.toString(), PREFIX + SUFFIX);&#125; 合并Joiner@Testpublic void whenMergingJoiners_thenReturnMerged() &#123; StringJoiner rgbJoiner = new StringJoiner( \",\", PREFIX, SUFFIX); StringJoiner cmybJoiner = new StringJoiner( \"-\", PREFIX, SUFFIX); rgbJoiner.add(\"Red\") .add(\"Green\") .add(\"Blue\"); cmybJoiner.add(\"Cyan\") .add(\"Magenta\") .add(\"Yellow\") .add(\"Black\"); rgbJoiner.merge(cmybJoiner); assertEquals( rgbJoiner.toString(), \"[Red,Green,Blue,Cyan-Magenta-Yellow-Black]\");&#125; 使用流@Testpublic void whenUsedWithinCollectors_thenJoined() &#123; List&lt;String&gt; rgbList = Arrays.asList(\"Red\", \"Green\", \"Blue\"); String commaSeparatedRGB = rgbList.stream() .map(color -&gt; color.toString()) .collect(Collectors.joining(\",\")); assertEquals(commaSeparatedRGB, \"Red,Green,Blue\");&#125; 总结: 构造一个简单分割的字符串,使用StringJoiner方式很不错,也可以使用流的方式.","categories":[],"tags":[]},{"title":"blog/java/java中StringTokenizer使用","slug":"blog/java/java中StringTokenizer使用","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:05:25.057Z","comments":true,"path":"blog/java/java中StringTokenizer使用/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%ADStringTokenizer%E4%BD%BF%E7%94%A8/","excerpt":"","text":"使用特殊分割符分割String类型一般使用StringTokenize()1. 使用逗号分割,再用枚举递归public List&lt;String&gt; getTokens(String str) &#123; List&lt;String&gt; tokens = new ArrayList&lt;&gt;(); StringTokenizer tokenizer = new StringTokenizer(str, \",\"); while (tokenizer.hasMoreElements()) &#123; tokens.add(tokenizer.nextToken()); &#125; return tokens;&#125; 2. 使用java8public List&lt;String&gt; getTokensWithCollection(String str) &#123; return Collections.list(new StringTokenizer(str, \",\")).stream() .map(token -&gt; (String) token) // 注意这里返回类型为Object类型需要强转 .collect(Collectors.toList());&#125; 3. 自定义分割符tokens.add(tokenizer.nextToken(\"e\")); 读取CVS文件public List&lt;String&gt; getTokensFromFile( String path , String delim ) &#123; List&lt;String&gt; tokens = new ArrayList&lt;&gt;(); String currLine = \"\"; StringTokenizer tokenizer; try (BufferedReader br = new BufferedReader( new InputStreamReader(Application.class.getResourceAsStream( \"/\" + path )))) &#123; while (( currLine = br.readLine()) != null ) &#123; tokenizer = new StringTokenizer( currLine , delim ); while (tokenizer.hasMoreElements()) &#123; tokens.add(tokenizer.nextToken()); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return tokens;&#125; 测试public class TokenizerTest &#123; private MyTokenizer myTokenizer = new MyTokenizer(); private List&lt;String&gt; expectedTokensForString = Arrays.asList( \"Welcome\" , \"to\" , \"baeldung.com\" ); private List&lt;String&gt; expectedTokensForFile = Arrays.asList( \"1\" , \"IND\" , \"India\" , \"2\" , \"MY\" , \"Malaysia\" , \"3\", \"AU\" , \"Australia\" ); @Test public void givenString_thenGetListOfString() &#123; String str = \"Welcome,to,baeldung.com\"; List&lt;String&gt; actualTokens = myTokenizer.getTokens( str ); assertEquals( expectedTokensForString, actualTokens ); &#125; @Test public void givenFile_thenGetListOfString() &#123; List&lt;String&gt; actualTokens = myTokenizer.getTokensFromFile( \"data.csv\", \"|\" ); assertEquals( expectedTokensForFile , actualTokens ); &#125;&#125;","categories":[],"tags":[]},{"title":"blog/java/java中String类型转Integer或int类型","slug":"blog/java/java中String类型转Integer或int类型","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:06:40.299Z","comments":true,"path":"blog/java/java中String类型转Integer或int类型/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%ADString%E7%B1%BB%E5%9E%8B%E8%BD%ACInteger%E6%88%96int%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"1. 使用 Integer.parseInt() @Testpublic void givenString_whenParsingInt_shouldConvertToInt() &#123; String givenString = \"42\"; int result = Integer.parseInt(givenString); assertThat(result).isEqualTo(42);&#125; 2. 使用 Integer.valueOf() ,(不建议使用)内部使用缓存机制@Testpublic void givenString_whenCallingIntegerValueOf_shouldConvertToInt() &#123; String givenString = \"42\"; Integer result = Integer.valueOf(givenString); assertThat(result).isEqualTo(new Integer(42));&#125; 3. 使用Integer构造方法@Testpublic void givenString_whenCallingIntegerConstructor_shouldConvertToInt() &#123; String givenString = \"42\"; Integer result = new Integer(givenString); assertThat(result).isEqualTo(new Integer(42));&#125; 4. 使用 Integer.decode()方法@Testpublic void givenString_whenCallingIntegerDecode_shouldConvertToInt() &#123; String givenString = \"42\"; int result = Integer.decode(givenString); assertThat(result).isEqualTo(42);&#125; 以上方法如果转换错误会抛出NumberFormatException异常@Test(expected = NumberFormatException.class)public void givenInvalidInput_whenParsingInt_shouldThrow() &#123; String givenString = \"nan\"; Integer.parseInt(givenString);&#125; 5. 使用guava 工具 ,如果解析失败,会跳过返回空值@Testpublic void givenString_whenTryParse_shouldConvertToInt() &#123; String givenString = \"42\"; Integer result = Ints.tryParse(givenString); assertThat(result).isEqualTo(42);&#125; 总结: 使用java原生方式简单,但每次要考虑到解析异常也挺烦的,建议使用guava 的Ints.tryParse方法","categories":[],"tags":[]},{"title":"blog/java/java中十六进制转ASCII编码","slug":"blog/java/java中十六进制转ASCII编码","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:05:28.256Z","comments":true,"path":"blog/java/java中十六进制转ASCII编码/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%AD%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BD%ACASCII%E7%BC%96%E7%A0%81/","excerpt":"","text":"将字符串转换成十六进制 将每个字符串转换成数组 将数组中字符转换成整型 使用Integer.toHexString()方法转换成十六进制 private static String asciiToHex(String asciiStr) &#123; char[] chars = asciiStr.toCharArray(); StringBuilder hex = new StringBuilder(); for (char ch : chars) &#123; hex.append(Integer.toHexString((int) ch)); &#125; return hex.toString();&#125; 截断一个十六进制为两个字符组 使用Integer.parseInt(hex, 16)方法强转字符 把每个字符添加的StringBuilder上 private static String hexToAscii(String hexStr) &#123; StringBuilder output = new StringBuilder(\"\"); for (int i = 0; i &lt; hexStr.length(); i += 2) &#123; String str = hexStr.substring(i, i + 2); output.append((char) Integer.parseInt(str, 16)); &#125; return output.toString();&#125; 测试@Testpublic static void whenHexToAscii() &#123; String asciiString = \"www.matosiki.com\"; String hexEquivalent = \"3737373737373265363236313635366336343735366536373265363336663664\"; assertEquals(asciiString, hexToAscii(hexEquivalent));&#125; @Testpublic static void whenAsciiToHex() &#123; String asciiString = \"www.matosiki.com\"; String hexEquivalent = \"3737373737373265363236313635366336343735366536373265363336663664\"; assertEquals(hexEquivalent, asciiToHex(asciiString));&#125; 总结: 以上同16进制与ascii码相互转换.","categories":[],"tags":[]},{"title":"blog/java/java中字符串转字节流","slug":"blog/java/java中字符串转字节流","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:05:32.727Z","comments":true,"path":"blog/java/java中字符串转字节流/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%AD%97%E8%8A%82%E6%B5%81/","excerpt":"","text":"1. 使用chars()方法 返回IntStreamString testString = \"String\";IntStream intStream = testString.chars(); // 获取 数字流 ,所以我们需要转换Stream&lt;Character&gt; characterStream = testString.chars() .mapToObj(c -&gt; (char) c); // 使用mapToObj强转 2. 使用codePoint()方法 得到点码,再强转.Stream&lt;Character&gt; characterStream2 = testString.codePoints() .mapToObj(c -&gt; (char) c);// 也可以转换成单个字符串流Stream&lt;String&gt; stringStream = testString.codePoints() .mapToObj(c -&gt; String.valueOf((char) c)); 总结: 通过字符串转换整型流,也可以转换字节流,还可以转换单个字符串流.","categories":[],"tags":[]},{"title":"blog/java/java中实用apache Text字符串处理","slug":"blog/java/java中实用apache Text字符串处理","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:06:36.194Z","comments":true,"path":"blog/java/java中实用apache Text字符串处理/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%AD%E5%AE%9E%E7%94%A8apache%20Text%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"首字母大写@Testpublic void whenCapitalized_thenCorrect() &#123; String toBeCapitalized = \"to be capitalized!\"; String result = WordUtils.capitalize(toBeCapitalized); assertEquals(\"To Be Capitalized!\", result);&#125; 判断字符串中存在的字符@Testpublic void whenContainsWords_thenCorrect() &#123; boolean containsWords = WordUtils .containsAllWords(\"String to search\", \"to\", \"search\"); assertTrue(containsWords);&#125; 使用StrSubstitutor建立字符串模板@Testpublic void whenSubstituted_thenCorrect() &#123; Map&lt;String, String&gt; substitutes = new HashMap&lt;&gt;(); substitutes.put(\"name\", \"John\"); substitutes.put(\"college\", \"University of Stanford\"); String templateString = \"My name is $&#123;name&#125; and I am a student at the $&#123;college&#125;.\"; StrSubstitutor sub = new StrSubstitutor(substitutes); String result = sub.replace(templateString); assertEquals(\"My name is John and I am a student at the University of Stanford.\", result);&#125; 使用StrBuilder替代原生StirngBuilder 方便替换字串串内容@Testpublic void whenReplaced_thenCorrect() &#123; StrBuilder strBuilder = new StrBuilder(\"example StrBuilder!\"); strBuilder.replaceAll(\"example\", \"new\"); assertEquals(new StrBuilder(\"new StrBuilder!\"), strBuilder); //清理StrBuilder strBuilder.clear()&#125; 比较字符串不同次数@Testpublic void whenEditScript_thenCorrect() &#123; StringsComparator cmp = new StringsComparator(\"ABCFGH\", \"BCDEFG\"); EditScript&lt;Character&gt; script = cmp.getScript(); int mod = script.getModifications(); assertEquals(4, mod);&#125; 使用text.similarily方便比较字符串的不同程度// 得到相同数量@Testpublic void whenCompare_thenCorrect() &#123; LongestCommonSubsequence lcs = new LongestCommonSubsequence(); int countLcs = lcs.apply(\"New York\", \"New Hampshire\"); assertEquals(5, countLcs);&#125;// 得到不同数量@Testpublic void whenCalculateDistance_thenCorrect() &#123; LongestCommonSubsequenceDistance lcsd = new LongestCommonSubsequenceDistance(); int countLcsd = lcsd.apply(\"New York\", \"New Hampshire\"); assertEquals(11, countLcsd);&#125; 自定义传唤字符串@Testpublic void whenTranslate_thenCorrect() &#123; UnicodeEscaper ue = UnicodeEscaper.above(0); String result = ue.translate(\"ABCD\"); assertEquals(\"\\\\u0041\\\\u0042\\\\u0043\\\\u0044\", result);&#125;","categories":[],"tags":[]},{"title":"blog/java/java中将列表转换成字符串","slug":"blog/java/java中将列表转换成字符串","date":"2020-06-04T02:02:07.177Z","updated":"2020-06-04T02:05:38.558Z","comments":true,"path":"blog/java/java中将列表转换成字符串/","link":"","permalink":"http://www.matosiki.site/blog/java/java%E4%B8%AD%E5%B0%86%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"1. 直接打印@Testpublic void whenListToString_thenPrintDefault() &#123; List&lt;Integer&gt; intLIst = Arrays.asList(1, 2, 3); System.out.println(intLIst); //这个方式,对简单类型对象适用&#125; 2. 实用stream方式转换@Testpublic void whenCollectorsJoining_thenPrintCustom() &#123; List&lt;Integer&gt; intList = Arrays.asList(1, 2, 3); String result = intList.stream() .map(n -&gt; String.valueOf(n)) .collect(Collectors.joining(\"-\", \"&#123;\", \"&#125;\")); System.out.println(result);&#125; 3. 实用Common lang 工具@Testpublic void whenStringUtilsJoin_thenPrintCustom() &#123; List&lt;Integer&gt; intList = Arrays.asList(1, 2, 3); System.out.println(StringUtils.join(intList, \"|\"));&#125; 总结: 简单的类型可以直接打印,但是复杂自定义对象建议使用流方式打印.","categories":[],"tags":[]},{"title":"blog/linux/ubuntu环境下编译linux内核","slug":"blog/linux/ubuntu环境下编译linux内核","date":"2020-04-18T07:01:23.088Z","updated":"2020-04-18T07:01:23.088Z","comments":true,"path":"blog/linux/ubuntu环境下编译linux内核/","link":"","permalink":"http://www.matosiki.site/blog/linux/ubuntu%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/","excerpt":"","text":"ubuntu环境下编译linux内核安装步骤: 准备一台ubuntu服务器或者虚拟机 安装编译需要的软件并配置编译环境 进入官网下载stable版本linux(本次实验版本5.5.6) 配置需要编译的模块 安装内核 下载内核 删除内核 环境准备实验系统Ubuntu Server 18.04.1 LTS 64位 基础配置4核 8GB 处理器型号(主频) Intel Xeon Skylake 6146(3.2 GHz) #使用root权限su - root 查看当前系统linux内核 dpkg --list | grep linux-imageii linux-image-4.15.0-54-generic 4.15.0-54.58 amd64 Signed kernel image genericii linux-image-generic 4.15.0.54.56 amd64 Generic Linux kernel image 查看当前运行的内核uname -aLinux VM-0-35-ubuntu 4.15.0-54-generic #58-Ubuntu SMP Mon Jun 24 10:55:24 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 安装依赖软件sudo apt-get install libncurses5-dev libssl-dev -ysudo apt-get install build-essential openssl -ysudo apt-get install zlibc minizip -ysudo apt-get install libidn11-dev libidn11 -ysudo apt-get install bison -ysudo apt-get install flex -ysudo apt-get install libelf-dev -ysudo apt-get install libelf-devel -ysudo apt-get install elfutils-libelf-devel -ysudo apt-get install flex -ysudo apt-get install bison -y 下载内核wget https:&#x2F;&#x2F;cdn.kernel.org&#x2F;pub&#x2F;linux&#x2F;kernel&#x2F;v5.x&#x2F;linux-5.5.6.tar.xz# 解压到&#x2F;usr&#x2F;srctar -vxzf linux-5.5.6.tar.xzmv linux-5.5.6&#x2F; &#x2F;usr&#x2F;src&#x2F;cd &#x2F;usr&#x2F;src&#x2F;linux-5.5.6 配置Linux内核 配置编译选项开始编译安装内核 make mrproper 清空编译信息make clean make menuconfig 当前目录下执行 # 使用20个线程编译make -j 20# 生成相应的模块make modules# 将相应的模块拷贝到对应的目录下time make modules_install install# 该命令的作用是将.config，vmlinuz，initrd.img，System.map文件到/boot/目录、更新grub。默认启动新内核 查看当前安装的内核 dpkg --get-selections | grep linux 执行apt-get remove linux-image-**-generic dpkg –get-selections|grep linux 有时候这个命令找不到刚才安装的内核 这个时候用一下方法 删除boot下面和要删除的内核版本相关的文件 rm –rf rm -f 3.19.8删除/usr/src/目录下的内核源码update-grub 更新grub","categories":[],"tags":[]},{"title":"blog/linux/ubuntu配置apt镜像源","slug":"blog/linux/ubuntu配置apt镜像源","date":"2020-04-18T07:01:23.088Z","updated":"2020-04-19T15:14:28.067Z","comments":true,"path":"blog/linux/ubuntu配置apt镜像源/","link":"","permalink":"http://www.matosiki.site/blog/linux/ubuntu%E9%85%8D%E7%BD%AEapt%E9%95%9C%E5%83%8F%E6%BA%90/","excerpt":"","text":"ubuntu配置apt与使用配置apt镜像源 清华镜像源 # 备份原镜像配置sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak# 注意选择版本哟# 配置清华镜像源cat &lt;&lt; EOF&gt; /etc/apt/sources.list# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverseEOF 安装aptitude搜索软件 apt install aptitude -yaptitude search libgtk-3-0 libgtk-3-dev# 其他的库apt install libgtk-3-0 libgtk-3-dev libgconf-2-4 libxss1 libasound2","categories":[],"tags":[]},{"title":"blog/linux/linux系统知识","slug":"blog/linux/linux系统知识","date":"2020-04-18T07:01:23.087Z","updated":"2020-04-18T07:01:23.087Z","comments":true,"path":"blog/linux/linux系统知识/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86/","excerpt":"","text":"linux系统知识体系结构 Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。 Linux内核 Linux 将内存划分为容易处理的“内存页”，提供了对 4KB 缓冲区的抽象，例如 slab 分配器。 进程实际是某特定应用程序的一个运行实体，进程调度控制进程对CPU的访问。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。 内核通过 SCI 提供了一个API来创建一个新进程（fork、exec 或 POSⅨ），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。 Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。 由于 Linux 支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。 Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。 网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。 Linux 文件系统 Linux系统能支持多种目前流行的文件系统，推荐用EXT4。 Linux下面的文件类型主要有： 1) 普通文件，分为纯文本和二进制。 2) 目录文件，存储文件的地方。 3) 链接文件，指向同一个文件或目录的的文件。 4) 设备文件，分为块设备和字符设备。 5）管道文件，提供进程间通信 6）套接字文件，与网络通信有关 Linux使用标准的目录结构，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。 目录名 简要说明 /media 用于挂载设备文件的目录 /opt 放置第三方的软件 /srv 一些网络服务的数据文件目录 /lost+found 当文件系统发生错误时，将一些丢失的文件片段存放在这里 /boot 开机所需文件—内核、开机菜单以及所需配置文件等 /bin 二进制可执行命令 /dev 以文件形式存放任何设备与接口 /etc 系统管理和配置文件 /etc/rc.d 启动的配置文件和脚本 /home 用户主目录的基点，比如用户abc的主目录就是/home/user，可以用~abc表示 /lib 标准程序设计库, 开机时用到的函数库，以及/bin与/sbin下面的命令要调用的函数 /sbin 系统管理命令，这里存放的是系统管理员使用的管理程序 /tmp 公用的临时文件存储点 /root 系统管理员的主目录 /mnt 系统提供这个目录是让用户临时挂载其他的文件系统。 /lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件 /proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。虚拟文件系统，例如系统内核、进程、外部设备及网络状态等 /var 某些大文件的溢出区，比方说各种服务的日志文件 /usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：/usr/X11R6 存放X window的目录/usr/bin 众多的应用程序/usr/sbin 超级用户的一些管理程序/usr/doc linux文档/usr/include linux下开发和编译应用程序所需要的头文件/usr/lib 常用的动态链接库和软件包的配置文件/usr/man 帮助文档/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里/usr/local 用户自行安装的软件/usr/local/bin 本地增加的命令/usr/local/lib 本地增加的库 Linux Shell 及命令 vim编辑器 系统环境变量 # 注意所有系统环境变量都是大写# 用户的主目录（即家目录）echo $HOME# 用户在使用的Shellecho $SHELL# 历史命令记录条数echo $HISTSIZE # 保存的历史命令记录条数echo $HISTFILESIZE # 邮件保存路径echo $MAIL # 系统语言、语系名称echo $LANG # 生成一个随机数字echo $RANDOM# 用户执行命令的路径echo $PATH #用户默认的文本编辑器echo $EDITOR 特殊权限SUIDset UID 简称 SUID 这个UID代表User的ID,表示文档的拥有者 有这个权限代表只能拥有者和root能操作比如/usr/bin/passwd SGIDset GID 简称 SGID这个GID 代表Group 的ID,表示文档的拥有组 这个权限代表只能拥有组和ROOT能操作 Strick Bit比如/tmp的权限”drwxrwxrwt”仅有该档案/目录建立者与 root 能够删除自己的目录或档案 proc目录下文件详解&#x2F;proc&#x2F;cmdline 载入 kernel 时所下达的相关参数！查阅此档案，可了解系统是如何启动的！ &#x2F;proc&#x2F;cpuinfo 本机的 CPU 的相关资讯，包含时脉、类型与运算功能等 &#x2F;proc&#x2F;devices 这个档案记录了系统各个主要装置的主要装置代号，与 mknod 有关呢！ &#x2F;proc&#x2F;filesystems 目前系统已经载入的档案系统棉！ &#x2F;proc&#x2F;interrupts 目前系统上面的 IRQ 分配状态。 &#x2F;proc&#x2F;ioports 目前系统上面各个装置所配置的 I&#x2F;O 位址。 &#x2F;proc&#x2F;kcore 这个就是记忆体的大小啦！好大对吧！但是不要读他啦！ &#x2F;proc&#x2F;loadavg 还记得 top 以及 uptime 吧？没错！上头的三个平均数值就是记录在此！ &#x2F;proc&#x2F;meminfo 使用 free 列出的记忆体资讯，嘿嘿！在这里也能够查阅到！ &#x2F;proc&#x2F;modules 目前我们的 Linux 已经载入的模组列表，也可以想成是驱动程式啦！ &#x2F;proc&#x2F;mounts 系统已经挂载的资料，就是用 mount 这个指令呼叫出来的资料啦！ &#x2F;proc&#x2F;swaps 到底系统挂载入的记忆体在哪里？呵呵！使用掉的 partition 就记录在此啦！ &#x2F;proc&#x2F;partitions 使用 fdisk -l 会出现目前所有的 partition 吧？在这个档案当中也有纪录喔！ &#x2F;proc&#x2F;pci 在 PCI 汇流排上面，每个装置的详细情况！可用 lspci 来查阅！ &#x2F;proc&#x2F;uptime 就是用 uptime 的时候，会出现的资讯啦！ &#x2F;proc&#x2F;version 核心的版本，就是用 uname -a 显示的内容啦！ &#x2F;proc&#x2F;bus&#x2F;* 一些汇流排的装置，还有 USB 的装置也记录在此喔！","categories":[],"tags":[]},{"title":"blog/linux/linux环境搭建mysql主从集群","slug":"blog/linux/linux环境搭建mysql主从集群","date":"2020-04-18T07:01:23.087Z","updated":"2020-04-24T04:17:14.876Z","comments":true,"path":"blog/linux/linux环境搭建mysql主从集群/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmysql%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/","excerpt":"","text":"linux环境搭建mysql主从集群环境 master replica 192.168.10.111 192.168.10.112 安装完成mysql# 启动mysqlservice mysqld start#cd # 进入mysql命令行./mysql -uroot -p123456use mysql# 赋权限给从数据库GRANT REPLICATION SLAVE ON *.* to root@192.168.10.112 identified by '123456';show binary logs;show master status\\G;reset master; 更改配置文件vi /etc/my.cnf#设置主192.168.10.111server_id=111#设置主192.168.10.112server_id=112# 清空日志文件，同Mastercd /usr/local/mysql/datarm -rf mysql-bin.*systemctl restart mysql# 启用复制# 让slave连接master并开始重做master二进制日志中的事件./mysql -uroot -p123456change master to master_host='192.168.10.111',master_user='root',master_password='123456',master_port=3306,master_log_file='mysql-bin.000001',master_log_pos=120;start slave;show slave status\\G;# 查看当前server_idshow variables like 'server_id';show variables like '%server_uuid%';# 其中Slave_IO_Running 与 Slave_SQL_Running 的值都必须为YES，才表明状态正常。 [错误] 其中Slave_IO_Running为NO Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.[解决] 在副本节点下执行 ./mysql -uroot -p123456show variables like '%server_uuid%';mv /usr/local/mysql/data/mysql/auto.cnf /usr/local/mysql/data/mysql/auto.cnf.bk# 重启副本节点systemctl restart mysql 查看show slave status这样表示安装成功. Slave_IO_Running: YesSlave_SQL_Running: Yes 查看master集群上show slave hosts 下面表示成功 +-----------+------+------+-----------+--------------------------------------+| Server_id | Host | Port | Master_id | Slave_UUID |+-----------+------+------+-----------+--------------------------------------+| 101 | | 3306 | 1 | cfd1e2f2-85e0-11ea-83ab-525400c3ed77 |+-----------+------+------+-----------+--------------------------------------+","categories":[],"tags":[]},{"title":"blog/linux/ubuntu安装使用cgroups","slug":"blog/linux/ubuntu安装使用cgroups","date":"2020-04-18T07:01:23.087Z","updated":"2020-04-18T07:01:23.087Z","comments":true,"path":"blog/linux/ubuntu安装使用cgroups/","link":"","permalink":"http://www.matosiki.site/blog/linux/ubuntu%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8cgroups/","excerpt":"","text":"ubuntu 安装使用CgroupsCgroups简介原文 Cgroups 是什么？Cgroups 是 control groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO 等等）的机制。最初由 google 的工程师提出，后来被整合进 Linux 内核。Cgroups 也是 LXC 为实现虚拟化所使用的资源管理手段，可以说没有 cgroups 就没有 LXC。 Cgroups 可以做什么？Cgroups 最初的目标是为资源管理提供的一个统一的框架，既整合现有的 cpuset 等子系统，也为未来开发新的子系统提供接口。现在的 cgroups 适用于多种应用场景，从单个进程的资源控制，到实现操作系统层次的虚拟化（OS Level Virtualization）。 Cgroups 提供了一下功能： 限制进程组可以使用的资源数量（Resource limiting ）。比如：memory 子系统可以为进程组设定一个 memory 使用上限，一旦进程组使用的内存达到限额再申请内存，就会出发 OOM（out of memory）。 进程组的优先级控制（Prioritization ）。比如：可以使用 cpu 子系统为某个进程组分配特定 cpu share。 记录进程组使用的资源数量（Accounting ）。比如：可以使用 cpuacct 子系统记录某个进程组使用的 cpu 时间 进程组隔离（Isolation）。比如：使用 ns 子系统可以使不同的进程组使用不同的 namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。 进程组控制（Control）。比如：使用 freezer 子系统可以将进程组挂起和恢复。 Cgroups 相关概念及其关系相关概念 任务（task）。在 cgroups 中，任务就是系统的一个进程。 控制族群（control group）。控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制。 层级（hierarchy）。控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性。 子系统（subsytem）。一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。 相互关系 每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 root cgroup ，此 cgroup 在创建层级时自动创建，后面在该层级中创建的 cgroup 都是此 cgroup 的后代）的初始成员。 一个子系统最多只能附加到一个层级。 一个层级可以附加多个子系统 一个任务可以是多个 cgroup 的成员，但是这些 cgroup 必须在不同的层级。 系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup 的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的 cgroup。 图 1. CGroup 层级图 图 1 所示的 CGroup 层级关系显示，CPU 和 Memory 两个子系统有自己独立的层级系统，而又通过 Task Group 取得关联关系。 图 2. 进程与cgourps 关系示意图 图2 从整体结构上描述了进程与 cgroups 之间的关系。最下面的P代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构css_set（cgroups subsystem set）。 指向某一个css_set的进程会被加入到当前css_set的进程链表中。一个进程只能隶属于一个css_set，一个css_set可以包含多个进程，隶属于同一css_set的进程受到同一个css_set所关联的资源限制。 上图中的”M×N Linkage”说明的是css_set通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许css_set同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。 一个css_set关联多个 cgroups 层级结构的节点时，表明需要对当前css_set下的进程进行多种资源的控制。而一个 cgroups 节点关联多个css_set时，表明多个css_set下的进程列表受到同一份资源的相同限制。 Cgroups 子系统介绍 blkio – 这个子系统为块设备设定输入 / 输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。 cpu – 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。 cpuacct – 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。 cpuset – 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。 devices – 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。 freezer – 这个子系统挂起或者恢复 cgroup 中的任务。 memory – 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。 net_cls – 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。 ns – 名称空间子系统。 图3. CGroup 典型应用架构图 如图 2 所示，CGroup 技术可以被用来在操作系统底层限制物理资源，起到 Container 的作用。图中每一个 JVM 进程对应一个 Container Cgroup 层级，通过 CGroup 提供的各类子系统，可以对每一个 JVM 进程对应的线程级别进行物理限制，这些限制包括 CPU、内存等等许多种类的资源 Cgroups详解cgroups 数据结构设计我们从进程出发来剖析 cgroups 相关数据结构之间的关系。 在 Linux 中，管理进程的数据结构是 task_struct，其中与 cgroups 有关的： #ifdef CONFIG_CGROUPS /* Control Group info protected by css_set_lock */ struct css_set *cgroups; /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */ struct list_head cg_list;#endif 其中 cgroups 指针指向了一个 css_set 结构，而 css_set 存储了与进程相关的 cgroups 信息。Cg_list 是一个嵌入的 list_head 结构，用于将连到同一个 css_set 的进程组织成一个链表。下面我们来看 css_set 的结构： struct css_set &#123; atomic_t refcount; struct hlist_node hlist; struct list_head tasks; struct list_head cg_links; struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT]; struct rcu_head rcu_head;&#125;; 其中 refcount 是该 css_set 的引用数，因为一个 css_set 可以被多个进程共用，只要这些进程的 cgroups 信息相同，比如：在所有已创建的层级里面都在同一个 cgroup 里的进程。 hlist 是嵌入的 hlist_node，用于把所有 css_set 组织成一个 hash 表，这样内核可以快速查找特定的 css_set。 tasks 指向所有连到此 css_set 的进程连成的链表。 cg_links 指向一个由 struct cg_cgroup_link 连成的链表。 Subsys 是一个指针数组，存储一组指向 cgroup_subsys_state 的指针。一个 cgroup_subsys_state 就是进程与一个特定子系统相关的信息。通过这个指针数组，进程就可以获得相应的 cgroups 控制信息了。下面我们就来看 cgroup_subsys_state 的结构： struct cgroup_subsys_state &#123; struct cgroup *cgroup; atomic_t refcnt; unsigned long flags; struct css_id *id;&#125;; cgroup 指针指向了一个 cgroup 结构，也就是进程属于的 cgroup。进程受到子系统的控制，实际上是通过加入到特定的 cgroup 实现的，因为 cgroup 在特定的层级上，而子系统又是附加到曾经上的。通过以上三个结构，进程就可以和 cgroup 连接起来了：task_struct-&gt;css_set-&gt;cgroup_subsys_state-&gt;cgroup。 下面我们再来看 cgroup 的结构： struct cgroup &#123; unsigned long flags; atomic_t count; struct list_head sibling; struct list_head children; struct cgroup *parent; struct dentry *dentry; struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT]; struct cgroupfs_root *root; struct cgroup *top_cgroup; struct list_head css_sets; struct list_head release_list; struct list_head pidlists; struct mutex pidlist_mutex; struct rcu_head rcu_head; struct list_head event_list; spinlock_t event_list_lock;&#125;; sibling,children 和 parent 三个嵌入的 list_head 负责将同一层级的 cgroup 连接成一颗 cgroup 树。subsys 是一个指针数组，存储一组指向 cgroup_subsys_state 的指针。这组指针指向了此 cgroup 跟各个子系统相关的信息，这个跟 css_set 中的道理是一样的。 root 指向了一个 cgroupfs_root 的结构，就是 cgroup 所在的层级对应的结构体。这样以来，之前谈到的几个 cgroups 概念就全部联系起来了。 top_cgroup 指向了所在层级的根 cgroup，也就是创建层级时自动创建的那个 cgroup。 css_set 指向一个由 struct cg_cgroup_link 连成的链表，跟 css_set 中 cg_links 一样。 下面我们来分析一个 css_set 和 cgroup 之间的关系。我们先看一下 cg_cgroup_link 的结构: struct cg_cgroup_link &#123; struct list_head cgrp_link_list; struct cgroup *cgrp; struct list_head cg_link_list; struct css_set *cg;&#125;; cgrp_link_list 连入到 cgroup-&gt;css_set 指向的链表，cgrp 则指向此 cg_cgroup_link 相关的 cgroup。 Cg_link_list 则连入到 css_set-&gt;cg_links 指向的链表, cg 则指向此 cg_cgroup_link 相关的 css_set。 那为什么要这样设计呢？ 那是因为 cgroup 和 css_set 是一个多对多的关系，必须添加一个中间结构来将两者联系起来，这跟数据库模式设计是一个道理。cg_cgroup_link 中的 cgrp 和 cg 就是此结构体的联合主键，而 cgrp_link_list 和 cg_link_list 分别连入到 cgroup 和 css_set 相应的链表，使得能从 cgroup 或 css_set 都可以进行遍历查询。 那为什么 cgroup 和 css_set 是多对多的关系呢？ 一个进程对应 css_set，一个 css_set 就存储了一组进程（应该有可能被几个进程共享，所以是一组）跟各个子系统相关的信息，但是这些信息有可能不是从一个 cgroup 那里获得的，因为一个进程可以同时属于几个 cgroup，只要这些 cgroup 不在同一个层级。 举个例子：我们创建一个层级 A，A 上面附加了 cpu 和 memory 两个子系统，进程 B 属于 A 的根 cgroup；然后我们再创建一个层级 C，C 上面附加了 ns 和 blkio 两个子系统，进程 B 同样属于 C 的根 cgroup；那么进程 B 对应的 cpu 和 memory 的信息是从 A 的根 cgroup 获得的，ns 和 blkio 信息则是从 C 的根 cgroup 获得的。因此，一个 css_set 存储的 cgroup_subsys_state 可以对应多个 cgroup。另一方面，cgroup 也存储了一组 cgroup_subsys_state，这一组 cgroup_subsys_state 则是 cgroup 从所在的层级附加的子系统获得的。一个 cgroup 中可以有多个进程，而这些进程的 css_set 不一定都相同，因为有些进程可能还加入了其他 cgroup。但是同一个 cgroup 中的进程与该 cgroup 关联的 cgroup_subsys_state 都受到该 cgroup 的管理（cgroups 中进程控制是以 cgroup 为单位的）的，所以一个 cgrouop 也可以对应多个 css_set。 那为什么要这样一个结构呢？ 从前面的分析，我们可以看出从 task 到 cgroup 是很容易定位的，但是从 cgroup 获取此 cgroup 的所有的 task 就必须通过这个结构了。每个进程都会指向一个 css_set，而与这个 css_set 关联的所有进程都会链入到 css_set-&gt;tasks 链表. 而 cgroup 又通过一个中间结构 cg_cgroup_link 来寻找所有与之关联的所有 css_set，从而可以得到与 cgroup 关联的所有进程。 最后让我们看一下层级和子系统对应的结构体。层级对应的结构体是 cgroupfs_root: struct cgroupfs_root &#123; struct super_block *sb; unsigned long subsys_bits; int hierarchy_id; unsigned long actual_subsys_bits; struct list_head subsys_list; struct cgroup top_cgroup; int number_of_cgroups; struct list_head root_list; unsigned long flags; char release_agent_path[PATH_MAX]; char name[MAX_CGROUP_ROOT_NAMELEN];&#125;; sb 指向该层级关联的文件系统超级块 subsys_bits 和 actual_subsys_bits 分别指向将要附加到层级的子系统和现在实际附加到层级的子系统，在子系统附加到层级时使用 hierarchy_id 是该层级唯一的 id top_cgroup 指向该层级的根 cgroup number_of_cgroups 记录该层级 cgroup 的个数 root_list 是一个嵌入的 list_head，用于将系统所有的层级连成链表 子系统对应的结构体是 cgroup_subsys: struct cgroup_subsys &#123; struct cgroup_subsys_state *(*create)(struct cgroup_subsys *ss, struct cgroup *cgrp); int (*pre_destroy)(struct cgroup_subsys *ss, struct cgroup *cgrp); void (*destroy)(struct cgroup_subsys *ss, struct cgroup *cgrp); int (*can_attach)(struct cgroup_subsys *ss, struct cgroup *cgrp, struct task_struct *tsk, bool threadgroup); void (*cancel_attach)(struct cgroup_subsys *ss, struct cgroup *cgrp, struct task_struct *tsk, bool threadgroup); void (*attach)(struct cgroup_subsys *ss, struct cgroup *cgrp, struct cgroup *old_cgrp, struct task_struct *tsk, bool threadgroup); void (*fork)(struct cgroup_subsys *ss, struct task_struct *task); void (*exit)(struct cgroup_subsys *ss, struct task_struct *task); int (*populate)(struct cgroup_subsys *ss, struct cgroup *cgrp); void (*post_clone)(struct cgroup_subsys *ss, struct cgroup *cgrp); void (*bind)(struct cgroup_subsys *ss, struct cgroup *root); int subsys_id; int active; int disabled; int early_init; bool use_id;#define MAX_CGROUP_TYPE_NAMELEN 32 const char *name; struct mutex hierarchy_mutex; struct lock_class_key subsys_key; struct cgroupfs_root *root; struct list_head sibling; struct idr idr; spinlock_t id_lock; struct module *module;&#125;; Cgroup_subsys 定义了一组操作，让各个子系统根据各自的需要去实现。这个相当于 C++ 中抽象基类，然后各个特定的子系统对应 cgroup_subsys 则是实现了相应操作的子类。 类似的思想还被用在了 cgroup_subsys_state 中，cgroup_subsys_state 并未定义控制信息，而只是定义了各个子系统都需要的共同信息，比如该 cgroup_subsys_state 从属的 cgroup。然后各个子系统再根据各自的需要去定义自己的进程控制信息结构体，最后在各自的结构体中将 cgroup_subsys_state 包含进去，这样通过 Linux 内核的 container_of 等宏就可以通过 cgroup_subsys_state 来获取相应的结构体。 从 cgroups 的数据结构设计，我们可以看出内核开发者的智慧，其中即包含了数据库模式设计来解决数据冗余问题，又包含了 OO 思想来解决通用操作的问题。 Cgroups安装使用Ubuntu18.4环境安装依赖程序sudo apt-get install cgroup-bin cgroup-lite cgroup-tools cgroupfs-mount libcgroup1配置cgroups新建 /etc/init/cgroup-lite.conf文件description \"mount available cgroup filesystems\"author \"Matos Iki &lt;wx11055@163.com&gt;\"start on mounted MOUNTPOINT=/sys/fs/cgrouppre-start script test -x /bin/cgroups-mount || &#123; stop; exit 0; &#125; test -d /sys/fs/cgroup || &#123; stop; exit 0; &#125; /bin/cgroups-mountcgconfigparser -l /etc/cgconfig.confend scriptpost-stop script if [ -x /bin/cgroups-umount ] then /bin/cgroups-umount fiend script新建 /etc/cgconfig.conf文件# Since systemd is working well, this section may not be necessary.# Uncomment if you need it## mount &#123;# cpuacct = /cgroup/cpuacct;# memory = /cgroup/memory;# devices = /cgroup/devices;# freezer = /cgroup/freezer;# net_cls = /cgroup/net_cls;# blkio = /cgroup/blkio;# cpuset = /cgroup/cpuset;# cpu = /cgroup/cpu;# &#125;group limitcpu&#123; cpu &#123; cpu.shares = 400; &#125;&#125;group limitmem&#123; memory &#123; memory.limit_in_bytes = 512m; &#125;&#125;group limitio&#123; blkio &#123; blkio.throttle.read_bps_device = \"252:0 2097152\"; &#125;&#125;group browsers &#123; cpu &#123;# Set the relative share of CPU resources equal to 25% cpu.shares = \"256\";&#125;memory &#123;# Allocate at most 512M of memory to tasks memory.limit_in_bytes = \"512m\";# Apply a soft limit of 512 MB to tasks memory.soft_limit_in_bytes = \"384m\"; &#125;&#125;group media-players &#123; cpu &#123;# Set the relative share of CPU resources equal to 25% cpu.shares = \"256\"; &#125; memory &#123;# Allocate at most 256M of memory to tasks memory.limit_in_bytes = \"256m\";# Apply a soft limit of 196 MB to tasks memory.soft_limit_in_bytes = \"128m\"; &#125;&#125;应用配置cgconfigparser -l /etc/cgconfig.conf启动cgconfigsudo service cgconfig restart Cgroups使用","categories":[],"tags":[]},{"title":"blog/linux/ubuntu安装使用lxc","slug":"blog/linux/ubuntu安装使用lxc","date":"2020-04-18T07:01:23.087Z","updated":"2020-04-18T07:01:23.087Z","comments":true,"path":"blog/linux/ubuntu安装使用lxc/","link":"","permalink":"http://www.matosiki.site/blog/linux/ubuntu%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8lxc/","excerpt":"","text":"ubuntu安装使用LXC1. LXC 是什么？LXC 是 Linux containers 的简称，是一种基于容器的操作系统层级的虚拟化技术。 2. LXC 可以做什么？LXC 可以在操作系统层次上为进程提供的虚拟的执行环境，一个虚拟的执行环境就是一个容器。可以为容器绑定特定的 cpu 和 memory 节点，分配特定比例的 cpu 时间、IO 时间，限制可以使用的内存大小（包括内存和是 swap 空间），提供 device 访问控制，提供独立的 namespace（网络、pid、ipc、mnt、uts）。 3. LXC 如何实现？Sourceforge 上有 LXC 这个开源项目，但是 LXC 项目本身只是一个为用户提供一个用户空间的工具集，用来使用和管理 LXC 容器。LXC 真正的实现则是靠 Linux 内核的相关特性，LXC 项目只是对此做了整合。基于容器的虚拟化技术起源于所谓的资源容器和安全容器。 LXC 在资源管理方面依赖与 Linux 内核的 cgroups 子系统，cgroups 子系统是 Linux 内核提供的一个基于进程组的资源管理的框架，可以为特定的进程组限定可以使用的资源。LXC 在隔离控制方面依赖于 Linux 内核的 namespace 特性，具体而言就是在 clone 时加入相应的 flag（NEWNS NEWPID 等等）。 4. 为什么要选择 LXC？LXC 是所谓的操作系统层次的虚拟化技术，与传统的 HAL（硬件抽象层）层次的虚拟化技术相比有以下优势： 更小的虚拟化开销（LXC 的诸多特性基本由内核特供，而内核实现这些特性只有极少的花费，具体分析有时间再说） 快速部署。利用 LXC 来隔离特定应用，只需要安装 LXC，即可使用 LXC 相关命令来创建并启动容器来为应用提供虚拟执行环境。传统的虚拟化技术则需要先创建虚拟机，然后安装系统，再部署应用。 LXC 跟其他操作系统层次的虚拟化技术相比，最大的优势在于 LXC 被整合进内核，不用单独为内核打补丁。 如何使用 LXC？TODO","categories":[],"tags":[]},{"title":"blog/linux/linux常用操作与技巧","slug":"blog/linux/linux常用操作与技巧","date":"2020-04-18T07:01:23.086Z","updated":"2020-04-18T07:01:23.086Z","comments":true,"path":"blog/linux/linux常用操作与技巧/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%8A%80%E5%B7%A7/","excerpt":"","text":"linux常用操作与技巧常用命令账户安全# 切换用户su - username # 更改权限chmod +x filename 搜索与查找which 寻找执行文档which [-a] command# -a 将所有可以找到的指令均列出，而不止第一个被找到的指令名称which -a java whereis 寻找特定文档whereis [-bmsu] 档案或目录名#参数∶#-b :只找 binary 的档案#-m :只找在说明档 manual 路径下的档案#-s :只找 source 来源档案#-u :没有说明档的档案！whieris passwdwhereis -b passwd locatelocate filenamelocate passwd find# 将过去系统上面 24 小时内有更动过内容 (mtime) 的档案列出find / -mtime 0# 寻找 /etc 底下的档案，如果档案日期比 /etc/passwd 新就列出find /etc -newer /etc/passwd# 搜寻 /home 底下属于 dmtsai 的档案find /home -user dmtsai# 搜寻系统中不属于任何人的档案find / -nouser# 找出档名为 passwd 这个档案find / -name passwd# 搜寻档案属性为 f (一般档案) 的档案find /home -type f# 搜寻档案当中含有 SGID/SUID/SBIT 的属性find / -perm +7000 # 将上个范例找到的档案使用 ls -l 列出来～find / -perm +7000 -exec ls -l &#123;&#125; \\;# 找出系统中，大于 1MB 的档案find / -size +1000k 程序安装# 安装软件rpm -ivh filename.rpm # 列出所有仓库yum repolist all# 列出仓库中所有软件包yum list all# 安装软件包yum install # 启动服务systemctl start foo.service # 重启服务systemctl restart foo.service# 停止服务systemctl stop foo.service# 重新加载配置文件（不终止服务）systemctl reload foo.service# 查看服务状态systemctl status foo.service 系统管理系统运行时命令#查看进程运行时间ps -p 7890 -o lstart,etime # 查看网络网卡状况ifconfig # 查看系统内核与系统版本等信息uname -sr # 用于查看系统的负载信息uptime -p # 以M为单位查看内存free -m -t -s 10 # 查看当前登入主机的用户终端信息who # 查看所有系统的登录记录last -iw # 显示历史执行过的命令history # 收集系统配置及架构信息并输出诊断文档sosreport -a # 打印固定格式时间date \"+%Y-%m-%d %H:%M:%S\" # 重启reboot# 关机poweroff # 查看所有进程状况ps -aux# 查看占用前10的进程ps aux | sort -k3nr |head -n 10 # 监视系统负载状况top # 查询系统进程pidpidof [参数] [服务名称]# 根据名称查找进程idpgrep hello # 关闭进程kill -9 [进程PID]killall [参数] [进程] # 计算程序运行时间time ./fibo 30 # 设置环境变量export PATH=PATH:/opt/bin # 查看系统端口netstat -tunlp 文件管理# 用户当前所处的工作目录pwd# 切换工作路径cd ~# 显示目录中的文件信息 ls# 纯文本文件cat# 查看纯文本文件（内容较多的）more# 查看纯文本文档的前N行head# 查看纯文本文档的后N行或持续刷新内容tail -f filename.txt# 替换文本文件中的字符 tr [原始字符] [目标字符]tr# 统计指定文本的行数、字数、字节数wc [参数] 文本 -l 只显示行数 -w 只显示单词数 -c 只显示字节数# 查看文件的具体存储信息和时间等信息stat# 按“列”提取文本字符cut [参数] 文本# 比较多个文本文件的差异，格式为“diff [参数] 文件”diff# 创建空白文件或设置文件的时间touch# 创建空白的目录mkdir# 复制文件或目录cp [选项] 源文件 目标文件# 剪切文件或将文件重命名mv [选项] 源文件 [目标路径|目标文件名]# 删除文件或目录rm [选项] 文件”# 按照指定大小和个数的数据块来复制文件或转换文件dd# 查看磁盘情况df -h# 查看文件的类型file 文件名tar -czvf testfile.tar.gztar -xzvf testfile.tar.gz# 在文本中执行关键词搜索grep [选项] [文件]-c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择——仅列出没有“关键词”的行。grep -rn \"test\"# 按照指定条件来查找文件find [查找路径] 寻找条件 操作# 预设权限umask 文本操作文本重定向# 将文件作为命令的标准输入命令 &lt; 文件# 从标准输入中读入，直到遇见分界符才停止命令 &lt;&lt; 分界符# 将文件1作为命令的标准输入并将标准输出到文件2命令 &lt; 文件1 &gt; 文件2 # 将标准输出重定向到一个文件中（清空原有文件的数据）命令 &gt; 文件 # 将错误输出重定向到一个文件中（清空原有文件的数据）命令 2&gt; 文件 # 将标准输出重定向到一个文件中（追加到原有内容的后面）命令 &gt;&gt; 文件 # 将错误输出重定向到一个文件中（追加到原有内容的后面）命令 2&gt;&gt; 文件 # 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面命令 &gt;&gt; 文件 2&gt;&amp;1 或 命令 &amp;&gt;&gt; 文件 # 使用cat创建文件cat &lt;&lt;EOF&gt;testfile.txt输入文本EOF 命令行光标与屏幕# 删除从开头到光标出的文本ctrl+u # 删除从光标出到结尾处的文本 ctrl+k# 光标移动到命令开头ctrl+a# 光标移动到命令结尾ctrl+e# 光标向前移动一个字母ctrl+f# 光标向后移动一个字母ctrl+b# 光标向前移动一个单词alt+f# 光标小后移动一个单词alt+b# 删除一个单词ctrl+w# 冻结屏幕ctrl+s# 冻结恢复ctrl+q 远程管理使用lrzsz上传和下载文件# 安装命令 yum install lrzsz # 上传文件rz# 下载文件sz 帮助文档man -h # 向下翻一页space# 向下翻一页Page down# 向上翻一页Page up # 直接前往首页home# 直接前往尾页end# 从上至下搜索某个关键词，如“/linux”/# 从下至上搜索某个关键词，如“?linux”?# 定位到下一个搜索到的关键词n# 定位到上一个搜索到的关键词N# 退出帮助文档q 其他技巧感叹号!使用# 命令位置whereis bash# 再次执行上一条名称!!# 使用上一条名称最后一个参数# 上一条名称是 ls /proc/1/task/1/net/tcp# 添加 -al参数ls -al !$ #实际执行 ls -al /proc/1/task/1/net/tcp# 使用上一条命令第一个参数ls -al !^# 去掉最后一个参数执行上一条命令!:-# 使用上一条名称所有参数#fin -name \"test.zip\" #这里find输错了。find !*# 使用上一条名称指定参数# cp -rf dira dirb/ #将dira拷贝到dirbls -l !cp:2 #查看dira的内容 # 执行history中的命令history# 执行history 2225条命令!2225# 执行倒数第二条名称!-2# 执行上一条find命令!find# 替换上条命令的参数# find ./ -name \"old*\" -a -name \"*.zip\"!!:gs/old/new# !感叹号参数时做非运算# 删除不是cfg结尾的所有文件rm !(*.cfg)","categories":[],"tags":[]},{"title":"blog/linux/linux更改主机名并设置网卡","slug":"blog/linux/linux更改主机名并设置网卡","date":"2020-04-18T07:01:23.086Z","updated":"2020-04-18T07:01:23.086Z","comments":true,"path":"blog/linux/linux更改主机名并设置网卡/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E6%9B%B4%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E5%B9%B6%E8%AE%BE%E7%BD%AE%E7%BD%91%E5%8D%A1/","excerpt":"","text":"linux更改主机名并设置网卡设置主机名设置你想要的主机名 vi /etc/hostname 查看当前ip地址相关信息 ifconfig 查看网卡配置信息 cat /etc/sysconfig/network-scripts/ifcfg-eth0 备份网卡配置信息 cd /etc/sysconfig/network-scripts/ cp ifcfg-eth0 ifcfg-eth0.bak 更改网卡配置信息将查看的IP和子网掩码广播地址添加到eth0中 vi ifcfg-eth0 ZONE=publicIPADDR=172.20.223.199 # 更具实际情况更改NETMASK=255.255.255.240BROADCAST=172.20.223.207BOOTPROTO=static GATEWAY=172.20.223.2 设置静态IP地址 BOOTPROTO=static 这句是开启静态IP功能这里有个坑 有的虚拟机不能设置，设置之后就不能访问外网 重启网卡 systemctl restart network 网卡信息文件/etc/sysconfig/network-scripts/ifcfg-eth0内容详解DEVICE=eth0 #网卡设备名称ONBOOT=yes #启动时是否激活 yes | noBOOTPROTO=static #协议类型IPADDR=192.168.1.90 #网络IP地址NETMASK=255.255.255.0 #网络子网地址GATEWAY=192.168.1.1 #网关地址BROADCAST=192.168.1.255 #广播地址HWADDR=00:0C:29:FE:1A:09 #网卡MAC地址TYPE=Ethernet #网卡类型为以太网 添加多个ip地址附加IP在没有网关下是没有多大作用的只能用于本机内部使用//附加IP IPADDR1=172.28.211.3PREFIX1=16 //与上面的PREFIX值要不同NETMASK=255.255.0.0DNS1=114.114.114.114DNS2=8.8.8.8NAME=\"System eth0\"","categories":[],"tags":[]},{"title":"blog/linux/linux源码安装sqlite3","slug":"blog/linux/linux源码安装sqlite3","date":"2020-04-18T07:01:23.086Z","updated":"2020-04-18T07:01:23.086Z","comments":true,"path":"blog/linux/linux源码安装sqlite3/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85sqlite3/","excerpt":"","text":"官网下载wget https://www.sqlite.org/2019/sqlite-autoconf-3270200.tar.gztar -zxvf sqlite-autoconf-3270200.tar.gzyum remove sqlitecd sqlite-autoconf-3270200./configuremake &amp;&amp; make installsqlite命令行 进入sqlite3sqlite3# 帮助.help# 退出.quit","categories":[],"tags":[]},{"title":"blog/linux/linux安装storm集群","slug":"blog/linux/linux安装storm集群","date":"2020-04-18T07:01:23.085Z","updated":"2020-04-18T07:01:23.085Z","comments":true,"path":"blog/linux/linux安装storm集群/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85storm%E9%9B%86%E7%BE%A4/","excerpt":"","text":"linux安装storm集群环境：jdk1.8zeekeeper3.4.10集群 下载Storm2.0.0官网镜像 wget http:&#x2F;&#x2F;tar.matosiki.site&#x2F;tar&#x2F;apache-storm-2.0.0.tar.gztar -vxzf apache-storm-2.0.0.tar.gz -C &#x2F;opt&#x2F; 修改配置 mkdir -p &#x2F;opt&#x2F;apache-storm-2.0.0&#x2F;localdircd &#x2F;opt&#x2F;apache-storm-2.0.0&#x2F;confvim &#x2F;opt&#x2F;apache-storm-2.0.0&#x2F;conf&#x2F;storm.yaml 注意Zookeeper的主机名storm.local.dir: \"/opt/apache-storm-2.0.0/localdir\"storm.zookeeper.port: 2181storm.zookeeper.servers: - \"master\" - \"mv-salve1\"nimbus.seeds: [\"master\"]ui.host: 0.0.0.0ui.port: 8686supervisor.slots.ports: - 6700 - 6701 - 6702 - 6703 supervisor额外添加jmx配置 supervisor.childopts: -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.port=9998 添加环境 vim &#x2F;etc&#x2F;profileexport STORM_HOME&#x3D;&#x2F;opt&#x2F;apache-storm-2.0.0export PATH&#x3D;$STORM_HOME&#x2F;bin:$PATHsource &#x2F;etc&#x2F;profile 复制安装文件到另一个节点 scp -r &#x2F;opt&#x2F;apache-storm-2.0.0&#x2F; root@192.168.126.100:&#x2F;opt&#x2F; 启动Storm 先启动zookeeper master节点 启动nimbus和storm ui cd &#x2F;opt&#x2F;apache-storm-2.0.0&#x2F;bin&#x2F;nohup .&#x2F;storm ui &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;nohup .&#x2F;storm nimbus &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp; worker节点启动启动Supervisor cd &#x2F;opt&#x2F;apache-storm-2.0.0&#x2F;bin&#x2F;nohup .&#x2F;storm supervisor &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;nohup .&#x2F;storm supervisor &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp; 开启防火墙 firewall-cmd --zone=public --add-port=6700/tcp --permanentfirewall-cmd --zone=public --add-port=6701/tcp --permanentfirewall-cmd --zone=public --add-port=6702/tcp --permanentfirewall-cmd --zone=public --add-port=6703/tcp --permanentfirewall-cmd --zone=public --add-port=8686/tcp --permanentfirewall-cmd --reload","categories":[],"tags":[]},{"title":"blog/linux/linux安装zookeeper","slug":"blog/linux/linux安装zookeeper","date":"2020-04-18T07:01:23.085Z","updated":"2020-04-18T07:01:23.085Z","comments":true,"path":"blog/linux/linux安装zookeeper/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85zookeeper/","excerpt":"","text":"linux安装zookeeper必要环境jdk 下载zoopeeker官网下载地址个人下载地址 wget http://tar.matosiki.site/tar/zookeeper-3.4.10.tar.gz 解压移动到固定目录 tar -zxf zookeeper-3.4.10.tar.gz -C /opt/ cd /opt/ mv zookeeper-3.4.10/ zookeeper3.4 配置zookeeper cd zookeeper3.4/ mkdir -p data mkdir -p logs cd /opt/zookeeper3.4/conf mv zoo_sample.cfg zoo.cfg 编辑配置文件 vi zoo.cfg #发送心跳的间隔时间，单位：毫秒tickTime&#x3D;2000#zookeeper保存数据的目录dataDir&#x3D;&#x2F;opt&#x2F;zookeeper3.4&#x2F;data#日志目录dataLogDir&#x3D;&#x2F;opt&#x2F;zookeeper3.4&#x2F;logs#端口clientPort&#x3D;2181#leader和follower初始化连接时最长能忍受多少个心跳时间的间隔数initLimit&#x3D;5#leader和follower之间发送消息，请求和英达时间长度，最长不能超过多少个tickTime的时间长度syncLimit&#x3D;2#zookeeper机器列表，server.order这里的Order依据集群的机器个数依次进行递增，这里的server1、server2、server3表示机器IP地址server.1&#x3D;192.168.0.1:2888:3888server.2&#x3D;192.168.0.2:2888:3888server.3&#x3D;192.168.0.3:2888:3888 cd /opt/zookeeper3.4/data 设置集群服务编号 echo “1” &gt; myid 添加环境变量vi &#x2F;etc&#x2F;profile# 添加export ZOOKEEPER_HOME&#x3D;&#x2F;opt&#x2F;zookeeper3.4&#x2F;export PATH&#x3D;$ZOOKEEPER_HOME&#x2F;bin:$PATH scp -r .&#x2F;zookeeper3.4&#x2F; root@192.168.0.3:&#x2F;opt&#x2F; 启动zookeeper.&#x2F;zkServer.sh start.&#x2F;zkServer.sh stop.&#x2F;zkServer.sh restart.&#x2F;zkServer.sh status 开启防火墙 firewall-cmd –zone=public –add-port=2181/tcp –permanent firewall-cmd –zone=public –add-port=2888/tcp –permanent firewall-cmd –zone=public –add-port=3888/tcp –permanent firewall-cmd –reload 集群或者启动错误Error contacting service. It is probably not running. cat /opt/zookeeper3.4/conf/zookeeper.out 查看错误日志 比我这台电脑 错误为： nohup: 无法运行命令”java”: 没有那个文件或目录 没有jdk环境导致的问题 说明在装zookeeper前要有jdk环境","categories":[],"tags":[]},{"title":"blog/linux/linux安装使用golang","slug":"blog/linux/linux安装使用golang","date":"2020-04-18T07:01:23.085Z","updated":"2020-04-18T07:01:23.085Z","comments":true,"path":"blog/linux/linux安装使用golang/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8golang/","excerpt":"","text":"linux安装使用golang安装环境 centos7 git 下载二进制安装wget https:&#x2F;&#x2F;studygolang.com&#x2F;dl&#x2F;golang&#x2F;go1.12.7.linux-amd64.tar.gz# 或者 wget http:&#x2F;&#x2F;tar.matosiki.site&#x2F;tar&#x2F;golang&#x2F;go1.12.7.linux-amd64.tar.gztar -vxzf go1.12.7.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;cd &#x2F;usr&#x2F;local&#x2F;gomkdir -p &#x2F;usr&#x2F;local&#x2F;gopath 环境变量 vim /etc/profile export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goexport GOPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;gopathexport PATH&#x3D;$PATH:$GOROOT&#x2F;bin:$GOPATH&#x2F;bin source /etc/profile 测试安装是否完成 go version","categories":[],"tags":[]},{"title":"blog/linux/linux安装使用tcpdump进行网络抓包","slug":"blog/linux/linux安装使用tcpdump进行网络抓包","date":"2020-04-18T07:01:23.085Z","updated":"2020-04-18T07:01:23.085Z","comments":true,"path":"blog/linux/linux安装使用tcpdump进行网络抓包/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8tcpdump%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/","excerpt":"","text":"linux安装使用tcpdump进行网络抓包安装使用源码编译安装前提需要安装gcc编译器 # ubuntu安装 gcc g++ makesudo apt install build-essentialapt install flex sudo apt-get install -y byacc# centos环境 安装gcc g++yum install -y gcc gcc-c++ tcpdump需要依赖pcap包,首先我们先下载tcpdump和pcap. wget http://tar.matosiki.site/tar/tcpdump-4.9.3.tar.gz wget http://tar.matosiki.site/tar/libpcap-1.9.1.tar.gz sudo mkdir -p /opt/codes# ubuntu权限不够,添加权限sudo chmod u+xr,go-rwx /optsudo tar -vxzf tcpdump-4.9.3.tar.gz -C /opt/codes/sudo tar -vxzf libpcap-1.9.1.tar.gz -C /opt/codes/cd /opt/codes/libpcap-1.9.1./configuremake &amp;&amp; make installcd /opt/codes/tcpdump-4.9.3./configuremake &amp;&amp; make install# 查看tcpdump位置whereis tcpdump 直接下载使用 # windows版本wget http://tar.matosiki.site/tcpdump.exe# ubuntu18.04wget http://tar.matosiki.site/tar/tcpdump 基本用法和使用方法tcpdump常用参数如下: tcpdump -i eth0 -nn -s0 -v port 80 -i : 选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 vlan 或其他特殊接口。如果该系统上只有一个网络接口，则无需指定。 -nn : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。 -s0 : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。 -v : 使用 -v，-vv 和 -vvv 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。 port 80 : 这是一个常见的端口过滤器，表示仅抓取 80 端口上的流量，通常是 HTTP。 额外再介绍几个常用参数： -p : 不让网络接口进入混杂模式。默认情况下使用 tcpdump 抓包时，会让网络接口进入混杂模式。一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。如果设备接入的交换机开启了混杂模式，使用 -p 选项可以有效地过滤噪声。 -e : 显示数据链路层信息。默认情况下 tcpdump 不会显示数据链路层信息，使用 -e 选项可以显示源和目的 MAC 地址，以及 VLAN tag 信息。例如： tcpdump -n -e -c 5 not ip6 tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes09:07:08.014418 00:15:5d:c7:dc:1c &gt; 00:15:5d:a4:b3:40, ethertype IPv4 (0x0800), length 162: 192.168.225.119.22 &gt; 192.168.225.113.63300: Flags [P.], seq 1119263860:1119263968, ack 1500707057, win 964, length 10809:07:08.014481 00:15:5d:c7:dc:1c &gt; 00:15:5d:a4:b3:40, ethertype IPv4 (0x0800), length 90: 192.168.225.119.22 &gt; 192.168.225.113.63300: Flags [P.], seq 108:144, ack 1, win 964, length 3609:07:08.014549 00:15:5d:c7:dc:1c &gt; 00:15:5d:a4:b3:40, ethertype IPv4 (0x0800), length 162: 192.168.225.119.22 &gt; 192.168.225.113.63300: Flags [P.], seq 144:252, ack 1, win 964, length 10809:07:08.014570 00:15:5d:a4:b3:40 &gt; 00:15:5d:c7:dc:1c, ethertype IPv4 (0x0800), length 54: 192.168.225.113.63300 &gt; 192.168.225.119.22: Flags [.], ack 108, win 8212, length 009:07:08.014735 00:15:5d:a4:b3:40 &gt; 00:15:5d:c7:dc:1c, ethertype IPv4 (0x0800), length 54: 192.168.225.113.63300 &gt; 192.168.225.119.22: Flags [.], ack 252, win 8211, length 05 packets captured 本次实验在虚拟机中进行,可以看出物理地址00:15:5d:c7:dc:1c是虚拟机物理地址,00:15:5d:a4:b3:40地址是宿主机物理地址. 显示ASCII字符-A 表示使用 ASCII 字符串打印报文的全部数据，这样可以使读取更加简单，方便使用 grep 等工具解析输出内容。-X 表示同时使用十六进制和 ASCII 字符串打印报文的全部数据。这两个参数不能一起使用。例如： tcpdump -A -s0 port 80 抓取特定协议的数据后面可以跟上协议名称来过滤特定协议的流量，以 UDP 为例，可以加上参数 udp 或 protocol 17，这两个命令意思相同。 tcpdump -i eth0 udp# 另一种写法tcpdump -i etho proto 17 同理，tcp 与 protocol 6 意思相同。 抓取特定主机的数据使用过滤器 host 可以抓取特定目的地和源 IP 地址的流量。 tcpdump -i eth0 host 39.96.184.32 也可以使用 src 或 dst 只抓取源或目的地： tcpdump -i eth0 dst 39.96.184.32 将抓取的数据写入文件使用 tcpdump 截取数据报文的时候，默认会打印到屏幕的默认输出，你会看到按照顺序和格式，很多的数据一行行快速闪过，根本来不及看清楚所有的内容。不过，tcpdump 提供了把截取的数据保存到文件的功能，以便后面使用其他图形工具（比如 wireshark，Snort）来分析。 -w 选项用来把数据报文输出到文件： tcpdump -i eth0 -s0 -w test.pcap 行缓冲模式如果想实时将抓取到的数据通过管道传递给其他工具来处理，需要使用 -l 选项来开启行缓冲模式（或使用 -c 选项来开启数据包缓冲模式）。使用 -l 选项可以将输出通过立即发送给其他命令，其他命令会立即响应。 tcpdump -i eth0 -s0 -l port 80 | grep 'Server:' 组合过滤器过滤的真正强大之处在于你可以随意组合它们，而连接它们的逻辑就是常用的 与/AND/&amp;&amp; 、 或/OR/|| 和 非/not/!。 and or &amp;&amp;or or ||not or ! 过滤器 关于 tcpdump 的过滤器，这里有必要单独介绍一下。 机器上的网络报文数量异常的多，很多时候我们只关系和具体问题有关的数据报（比如访问某个网站的数据，或者 icmp 超时的报文等等），而这些数据只占到很小的一部分。把所有的数据截取下来，从里面找到想要的信息无疑是一件很费时费力的工作。而 tcpdump 提供了灵活的语法可以精确地截取关心的数据报，简化分析的工作量。这些选择数据包的语句就是过滤器（filter）！ Host 过滤器Host 过滤器用来过滤某个主机的数据报文。例如： tcpdump host 1.2.3.4 该命令会抓取所有发往主机 1.2.3.4 或者从主机 1.2.3.4 发出的流量。如果想只抓取从该主机发出的流量，可以使用下面的命令： tcpdump src host 1.2.3.4 Network 过滤器Network 过滤器用来过滤某个网段的数据，使用的是 CIDR[2] 模式。可以使用四元组（x.x.x.x）、三元组（x.x.x）、二元组（x.x）和一元组（x）。四元组就是指定某个主机，三元组表示子网掩码为 255.255.255.0，二元组表示子网掩码为 255.255.0.0，一元组表示子网掩码为 255.0.0.0。例如， 抓取所有发往网段 192.168.1.x 或从网段 192.168.1.x 发出的流量： tcpdump net 192.168.1 抓取所有发往网段 10.x.x.x 或从网段 10.x.x.x 发出的流量： tcpdump net 10 和 Host 过滤器一样，这里也可以指定源和目的： tcpdump src net 10 也可以使用 CIDR 格式： tcpdump src net 172.16.0.0/12 Proto 过滤器Proto 过滤器用来过滤某个协议的数据，关键字为 proto，可省略。proto 后面可以跟上协议号或协议名称，支持 icmp, igmp, igrp, pim, ah, esp, carp, vrrp, udp和 tcp。因为通常的协议名称是保留字段，所以在与 proto 指令一起使用时，必须根据 shell 类型使用一个或两个反斜杠（/）来转义。Linux 中的 shell 需要使用两个反斜杠来转义，MacOS 只需要一个。 例如，抓取 icmp 协议的报文： $ tcpdump -n proto \\\\icmp# 或者$ tcpdump -n icmp Port 过滤器Port 过滤器用来过滤通过某个端口的数据报文，关键字为 port。例如： tcpdump port 389 理解 tcpdump 的输出 截取数据只是第一步，第二步就是理解这些数据，下面就解释一下 tcpdump 命令输出各部分的意义。 21:27:06.995846 IP (tos 0x0, ttl 64, id 45646, offset 0, flags [DF], proto TCP (6), length 64) 192.168.1.106.56166 &gt; 124.192.132.54.80: Flags [S], cksum 0xa730 (correct), seq 992042666, win 65535, options [mss 1460,nop,wscale 4,nop,nop,TS val 663433143 ecr 0,sackOK,eol], length 021:27:07.030487 IP (tos 0x0, ttl 51, id 0, offset 0, flags [DF], proto TCP (6), length 44) 124.192.132.54.80 &gt; 192.168.1.106.56166: Flags [S.], cksum 0xedc0 (correct), seq 2147006684, ack 992042667, win 14600, options [mss 1440], length 021:27:07.030527 IP (tos 0x0, ttl 64, id 59119, offset 0, flags [DF], proto TCP (6), length 40) 192.168.1.106.56166 &gt; 124.192.132.54.80: Flags [.], cksum 0x3e72 (correct), ack 2147006685, win 65535, length 0 最基本也是最重要的信息就是数据报的源地址/端口和目的地址/端口，上面的例子第一条数据报中，源地址 ip 是 192.168.1.106，源端口是 56166，目的地址是 124.192.132.54，目的端口是 80。&gt; 符号代表数据的方向。 此外，上面的三条数据还是 tcp 协议的三次握手过程，第一条就是 SYN 报文，这个可以通过 Flags [S] 看出。下面是常见的 TCP 报文的 Flags: [S] : SYN（开始连接） [.] : 没有 Flag [P] : PSH（推送数据） [F] : FIN （结束连接） [R] : RST（重置连接） 而第二条数据的 [S.] 表示 SYN-ACK，就是 SYN 报文的应答报文。 例子 下面给出一些具体的例子，每个例子都可以使用多种方法来获得相同的输出，你使用的方法取决于所需的输出和网络上的流量。我们在排障时，通常只想获取自己想要的内容，可以通过过滤器和 ASCII 输出并结合管道与 grep、cut、awk 等工具来实现此目的。 例如，在抓取 HTTP 请求和响应数据包时，可以通过删除标志 SYN/ACK/FIN 来过滤噪声，但还有更简单的方法，那就是通过管道传递给 grep。在达到目的的同时，我们要选择最简单最高效的方法。下面来看例子。 提取 HTTP 用户代理从 HTTP 请求头中提取 HTTP 用户代理： tcpdump -nn -A -s1500 -l | grep \"User-Agent:\" 通过 egrep 可以同时提取用户代理和主机名（或其他头文件）： tcpdump -nn -A -s1500 -l | egrep -i 'User-Agent:|Host:' 只抓取 HTTP GET 和 POST 流量抓取 HTTP GET 流量： tcpdump -s 0 -A -vv 'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420' 也可以抓取 HTTP POST 请求流量： tcpdump -s 0 -A -vv 'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354' 注意：该方法不能保证抓取到 HTTP POST 有效数据流量，因为一个 POST 请求会被分割为多个 TCP 数据包。 上述两个表达式中的十六进制将会与 GET 和 POST 请求的 ASCII 字符串匹配。例如，tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] 首先会确定我们感兴趣的字节的位置[3]（在 TCP header 之后），然后选择我们希望匹配的 4 个字节。 提取 HTTP 请求的 URL提取 HTTP 请求的主机名和路径： tcpdump -s 0 -v -n -l | egrep -i \"POST /|GET /|Host:\"tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes GET / HTTP/1.1 Host: vhost.matosiki.site 提取 HTTP POST 请求中的密码tcpdump -s 0 -A -n -l | egrep -i \"POST /|pwd=|passwd=|password=|Host:\" 提取 Cookies提取 Set-Cookie（服务端的 Cookie）和 Cookie（客户端的 Cookie）： tcpdump -nn -A -s0 -l | egrep -i 'Set-Cookie|Host:|Cookie:' 抓取 ICMP 数据包查看网络上的所有 ICMP 数据包： tcpdump -n icmp 抓取非 ECHO/REPLY 类型的 ICMP 数据包通过排除 echo 和 reply 类型的数据包使抓取到的数据包不包括标准的 ping 包： tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply' 抓取 SMTP/POP3 协议的邮件可以提取电子邮件的正文和其他数据。例如，只提取电子邮件的收件人： tcpdump -nn -l port 25 | grep -i 'MAIL FROM\\|RCPT TO' 抓取 NTP 服务的查询和响应tcpdump dst port 123 抓取 SNMP 服务的查询和响应通过 SNMP 服务，渗透测试人员可以获取大量的设备和系统信息。在这些信息中，系统信息最为关键，如操作系统版本、内核版本等。使用 SNMP 协议快速扫描程序 onesixtyone，可以看到目标系统的信息： onesixtyone 10.10.1.10 public 可以通过 tcpdump 抓取 GetRequest 和 GetResponse： tcpdump -n -s0 port 161 and udp 切割 pcap 文件当抓取大量数据并写入文件时，可以自动切割为多个大小相同的文件。例如，下面的命令表示每 3600 秒创建一个新文件 capture-(hour).pcap，每个文件大小不超过 200*1000000 字节： tcpdump -w /tmp/capture-%H.pcap -G 3600 -C 200 这些文件的命名为 capture-{1-24}.pcap，24 小时之后，之前的文件就会被覆盖。 抓取 IPv6 流量可以通过过滤器 ip6 来抓取 IPv6 流量，同时可以指定协议如 TCP： tcpdump -nn ip6 proto 6 从之前保存的文件中读取 IPv6 UDP 数据报文： tcpdump -nr ipv6-test.pcap ip6 proto 17 检测端口扫描在下面的例子中，你会发现抓取到的报文的源和目的一直不变，且带有标志位 [S] 和 [R]，它们与一系列看似随机的目标端口进行匹配。当发送 SYN 之后，如果目标主机的端口没有打开，就会返回一个 RESET。这是 Nmap 等端口扫描工具的标准做法 tcpdump -nn 过滤 Nmap NSE 脚本测试结果本例中 Nmap NSE 测试脚本 http-enum.nse 用来检测 HTTP 服务的合法 URL。 在执行脚本测试的主机上： nmap -p 80 --script=http-enum.nse targetip 在目标主机上： tcpdump -nn port 80 | grep \"GET /\" 抓取 DNS 请求和响应向 Google 公共 DNS 发起的出站 DNS 请求和 A 记录响应可以通过 tcpdump 抓取到： tcpdump -i wlp58s0 -s0 port 53 抓取 HTTP 有效数据包抓取 80 端口的 HTTP 有效数据包，排除 TCP 连接建立过程的数据包（SYN / FIN / ACK）： tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)' 将输出内容重定向到 Wireshark通常 Wireshark（或 tshark）比 tcpdump 更容易分析应用层协议。一般的做法是在远程服务器上先使用 tcpdump 抓取数据并写入文件，然后再将文件拷贝到本地工作站上用 Wireshark 分析。 还有一种更高效的方法，可以通过 ssh 连接将抓取到的数据实时发送给 Wireshark 进行分析。以 MacOS 系统为例，可以通过 brew cask install wireshark 来安装，然后通过下面的命令来分析： ssh root@remotesystem 'tcpdump -s0 -c 1000 -nn -w - not port 22' | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i 例如，如果想分析 DNS 协议，可以使用下面的命令： ssh root@remotesystem 'tcpdump -s0 -c 1000 -nn -w - port 53' | /Applications/Wireshark.app/Contents/MacOS/Wireshark -k -i - 抓取到的数据： -c 选项用来限制抓取数据的大小。如果不限制大小，就只能通过 ctrl-c 来停止抓取，这样一来不仅关闭了 tcpdump，也关闭了 wireshark。 找出发包最多的 IP找出一段时间内发包最多的 IP，或者从一堆报文中找出发包最多的 IP，可以使用下面的命令： tcpdump -nnn -t -c 200 | cut -f 1,2,3,4 -d '.' | sort | uniq -c | sort -nr | head -n 20 cut -f 1,2,3,4 -d ‘.’ : 以 . 为分隔符，打印出每行的前四列。即 IP 地址。 sort | uniq -c : 排序并计数 sort -nr : 按照数值大小逆向排序 抓取用户名和密码本例将重点放在标准纯文本协议上，过滤出于用户名和密码相关的报文： tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -l -A | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd=|password=|pass:|user:|username:|password:|login:|pass |user ' 抓取 DHCP 报文抓取 DHCP 服务的请求和响应报文，67 为 DHCP 端口，68 为客户机端口。 tcpdump -v -n port 67 or 68","categories":[],"tags":[]},{"title":"blog/linux/linux安装consul集群","slug":"blog/linux/linux安装consul集群","date":"2020-04-18T07:01:23.084Z","updated":"2020-04-18T07:01:23.084Z","comments":true,"path":"blog/linux/linux安装consul集群/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85consul%E9%9B%86%E7%BE%A4/","excerpt":"","text":"linux安装consul集群consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案， 下载安装curl -O http://tar.matosiki.site/zip/consul_1.3.0_linux_amd64.zipunzip consul_1.3.0_linux_amd64.zip -d /usr/local/bin/cd /usr/local/bin/consul version# 启动测试 consul agent -dev -client 0.0.0.0curl http://localhost:8500/ui 集群 主机名称 IP 作用 是否允许远程访问 node1 172.25.210.141 consul server 是 node2 172.25.210.142 consul client 是 node3 172.25.210.143 consul client 是 #三台机器上新建文件夹mkidr -p /var/data/consul/#node1 consul agent -data-dir /var/data/consul/ -node=172.25.210.141 -bind=0.0.0.0 -datacenter=dc1 -ui -client=172.25.210.141 -server -bootstrap-expect 1 &gt; /dev/null 2&gt;&amp;1 &amp;#node2consul agent -data-dir /var/data/consul/ -node=172.25.210.142 -bind=0.0.0.0 -datacenter=dc1 -ui -client=172.25.210.142 -join=172.25.210.141 &gt; /dev/null 2&gt;&amp;1 &amp;#node3consul agent -data-dir /var/data/consul/ -node=172.25.210.143 -bind=0.0.0.0 -datacenter=dc1 -ui -client=172.25.210.143 -join=172.25.210.141 &gt; /dev/null 2&gt;&amp;1 &amp;#查看节点consul members -rpc-addr=172.25.210.142:8400 #离开节点退出集群consul leave -rpc-addr=172.25.210.142:8400 ​","categories":[],"tags":[]},{"title":"blog/linux/linux安装mongodb的mms","slug":"blog/linux/linux安装mongodb的mms","date":"2020-04-18T07:01:23.084Z","updated":"2020-04-18T07:01:23.084Z","comments":true,"path":"blog/linux/linux安装mongodb的mms/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85mongodb%E7%9A%84mms/","excerpt":"","text":"架构图 使用rpm安装 wget https://downloads.mongodb.com/on-prem-mms/rpm/mongodb-mms-4.0.2.50187.20180905T1454Z-1.x86_64.rpm rpm -ivh mongodb-mms.rpm 文件会安装到 /opt/mongodb/mms下 修改配置文件 vi /opt/mongodb/mms/conf/conf-mms.properties mongo.mongoUri&#x3D;mongodb:&#x2F;&#x2F;127.0.0.1:27017&#x2F;?maxPoolSize&#x3D;150 ##启动 sudo service mongodb-mms start或者sudo &#x2F;etc&#x2F;init.d&#x2F;mongodb-mms start 使用tar包手动安装 wget http://tar.matosiki.site/tart/mongodb-mms-4.0.2.x86_64.tar.gz # 解压到opt目录tar -vxzf mongodb-mms-4.0.2.x86_64.tar.gz -C /opt/# 修改文件夹名mv mongodb-mms-4.0.2.50187.20180905T1454Z-1.x86_64/ mongodb-mms4.0.2# 修改配置vi mongodb-mms4.0.2/conf/conf-mms.properties 访问8080端口 注册用户","categories":[],"tags":[]},{"title":"blog/linux/linux安装mongodb集群","slug":"blog/linux/linux安装mongodb集群","date":"2020-04-18T07:01:23.084Z","updated":"2020-04-18T07:01:23.084Z","comments":true,"path":"blog/linux/linux安装mongodb集群/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85mongodb%E9%9B%86%E7%BE%A4/","excerpt":"","text":"linux安装mongodb集群1、相关概念 从图中可以看到有四个组件：mongos、config server、shard、replica set。 mongos，数据库集群请求的入口，所有的请求都通过mongos进行协调，不需要在应用程序添加一个路由选择器，mongos自己就是一个请求分发中心，它负责把对应的数据请求请求转发到对应的shard服务器上。在生产环境通常有多mongos作为请求的入口，防止其中一个挂掉所有的mongodb请求都没有办法操作。 config server，配置服务器，存储所有数据库元信息（路由、分片）的配置。mongos本身没有物理存储分片服务器和数据路由信息，只是缓存在内存里，配置服务器则实际存储这些数据。mongos第一次启动或者关掉重启就会从 config server 加载配置信息，以后如果配置服务器信息变化会通知到所有的 mongos 更新自己的状态，这样 mongos 就能继续准确路由。在生产环境通常有多个 config server 配置服务器，因为它存储了分片路由的元数据，防止数据丢失！ shard，分片（sharding）是指将数据库拆分，将其分散在不同的机器上的过程。将数据分散到不同的机器上，不需要功能强大的服务器就可以存储更多的数据和处理更大的负载。基本思想就是将集合切成小块，这些块分散到若干片里，每个片只负责总数据的一部分，最后通过一个均衡器来对各个分片进行均衡（数据迁移）。 replica set，中文翻译副本集，其实就是shard的备份，防止shard挂掉之后数据丢失。复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性。 仲裁者（Arbiter），是复制集中的一个MongoDB实例，它并不保存数据。仲裁节点使用最小的资源并且不要求硬件设备，不能将Arbiter部署在同一个数据集节点中，可以部署在其他应用服务器或者监视服务器中，也可部署在单独的虚拟机中。为了确保复制集中有奇数的投票成员（包括primary），需要添加仲裁节点做为投票，否则primary不能运行时不会自动切换primary。 简单了解之后，我们可以这样总结一下，应用请求mongos来操作mongodb的增删改查，配置服务器存储数据库元信息，并且和mongos做同步，数据最终存入在shard（分片）上，为了防止数据丢失同步在副本集中存储了一份，仲裁在数据存储到分片的时候决定存储到哪个节点。 2、环境准备系统系统 centos7五台服务器：10.253.173.95、10.253.173.108、10.253.164.220、10.253.164.242、10.253.164.244安装包： mongodb-linux-x86_64-3.4.6.tgz 服务器规划 95 108 220 242 244 mongos mongos config server config server config server sshard1 server shard2 server shard3 server shard4 server shard5 server shard5 server shard1 server shard2 server shard3 server shard4 server shard4 server shard5 server shard1 server shard2 server shard3 server 端口分配： mongos：20000config：21000shard1：27001shard2：27002shard3：27003shard4：27004shard5：27005 3、集群搭建3.1、安装mongodb下载wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.6.tgz#解压tar -xzvf mongodb-linux-x86_64-3.4.6.tgz -C /opt/#重命名mv mongodb-linux-x86_64-3.4.6 mongodb 分别在每台机器建立conf、mongos、config、shard1、shard2、shard3六个目录，因为mongos不存储数据，只需要建立日志文件目录即可。 mkdir -p /mnt/mongodb/confmkdir -p /mnt/mongodb/mongos/logmkdir -p /mnt/mongodb/config/datamkdir -p /mnt/mongodb/config/logmkdir -p /mnt/mongodb/shard1/datamkdir -p /mnt/mongodb/shard1/logmkdir -p /mnt/mongodb/shard2/datamkdir -p /mnt/mongodb/shard2/logmkdir -p /mnt/mongodb/shard3/datamkdir -p /mnt/mongodb/shard3/logmkdir -p /mnt/mongodb/shard4/datamkdir -p /mnt/mongodb/shard4/logmkdir -p /mnt/mongodb/shard5/datamkdir -p /mnt/mongodb/shard5/log 配置环境变量vim /etc/profile export MONGODB_HOME=/opt/mongodbexport PATH=$MONGODB_HOME/bin:$PATH 环境变量生效 source /etc/profile 3.2、config server配置服务器mongodb3.4以后要求配置服务器也创建副本集，不然集群搭建不成功。 添加配置文件vi /mnt/mongodb/conf/config.conf,其中bindIp替换为对应机器的ip # 系统日志systemLog: destination: file logAppend: true path: /mnt/mongodb/config/log/config.log #日志存储位置 # 文件存储storage: dbPath: /mnt/mongodb/config/ journal: enabled: true directoryPerDB: true #是否一个库一个文件夹 engine: wiredTiger #数据引擎 wiredTiger: #WT引擎配置 engineConfig: cacheSizeGB: 4 #设置为4G,默认为物理内存的一半 directoryForIndexes: true #是否将索引也按数据库名单独存储 journalCompressor: zlib collectionConfig: #表压缩配置 blockCompressor: zlib indexConfig: #索引配置 prefixCompression: true# 配置启动管理方式processManagement: fork: true pidFilePath: /mnt/mongodb/config/log/configsrv.pid # 网络接口net: port: 21000 bindIp: 10.253.173.95 # 副本集replication: replSetName: config sharding: clusterRole: configsvr 启动三台服务器的config server mongod -f /mnt/mongodb/conf/config.conf 登录任意一台配置服务器，初始化配置副本集 #连接mongo 10.253.173.95:21000#config变量config = &#123; _id : \"config\", members : [ &#123;_id : 0, host : \"10.253.173.95:21000\" &#125;, &#123;_id : 1, host : \"10.253.173.108:21000\" &#125;, &#123;_id : 2, host : \"10.253.164.220:21000\" &#125; ] &#125;#初始化副本集rs.initiate(config)#查看分区状态rs.status(); 3.3、配置分片副本集3.1、设置第一个分片副本集在服务器上，10.253.173.95、10.253.173.108、10.253.164.220 配置文件：vi /mnt/mongodb/conf/shard1.conf，其中bindIp换成对应机器的ip ## 配置文件内容# 系统日志systemLog: destination: file logAppend: true path: /mnt/mongodb/shard1/log/shard1.log # 文件存储storage: dbPath: /mnt/mongodb/shard1/data journal: enabled: true wiredTiger: #WT引擎配置 engineConfig: cacheSizeGB: 4 #设置为4G,默认为物理内存的一半 directoryForIndexes: true #是否将索引也按数据库名单独存储 journalCompressor: zlib collectionConfig: #表压缩配置 blockCompressor: zlib indexConfig: #索引配置 prefixCompression: true# 进程processManagement: fork: true pidFilePath: /mnt/mongodb/shard1/log/shard1.pid # 网络接口net: port: 27001 bindIp: 10.253.173.95# 副本集replication: replSetName: shard1sharding: clusterRole: shardsvr 启动三台服务器的shard1 server mongod -f /mnt/mongodb/conf/shard1.conf 登陆任意一台服务器，初始化副本集 mongo 10.253.173.95:27001#使用admin数据库use admin#定义副本集配置config = &#123; _id : \"shard1\", members : [ &#123;_id : 0, host : \"10.253.173.95:27001\" &#125;, &#123;_id : 1, host : \"10.253.173.108:27001\" &#125;, &#123;_id : 2, host : \"10.253.164.220:27001\" &#125; ] &#125;#初始化副本集配置rs.initiate(config);#查看分区状态rs.status(); 3.2、设置第二个分片副本集在服务器上，10.253.173.108、10.253.164.220、10.253.164.242 配置文件：vi /mnt/mongodb/conf/shard2.conf，其中bindIp换成对应机器的ip ## 配置文件内容# 系统日志systemLog: destination: file logAppend: true path: &#x2F;mnt&#x2F;mongodb&#x2F;shard2&#x2F;log&#x2F;shard2.log # 文件存储storage: dbPath: &#x2F;mnt&#x2F;mongodb&#x2F;shard2&#x2F;data journal: enabled: true wiredTiger: #WT引擎配置 engineConfig: cacheSizeGB: 4 #设置为4G,默认为物理内存的一半 directoryForIndexes: true #是否将索引也按数据库名单独存储 journalCompressor: zlib collectionConfig: #表压缩配置 blockCompressor: zlib indexConfig: #索引配置 prefixCompression: true# 进程processManagement: fork: true pidFilePath: &#x2F;mnt&#x2F;mongodb&#x2F;shard2&#x2F;log&#x2F;shard2.pid # 网络接口net: port: 27002 bindIp: 10.253.173.108# 副本集replication: replSetName: shard2sharding: clusterRole: shardsvr 启动三台服务器的shard2 server mongod -f &#x2F;mnt&#x2F;mongodb&#x2F;conf&#x2F;shard2.conf 登陆任意一台服务器，初始化副本集 mongo 10.253.173.108:27002#使用admin数据库use admin#定义副本集配置config &#x3D; &#123; _id : &quot;shard2&quot;, members : [ &#123;_id : 0, host : &quot;10.253.173.108:27002&quot; &#125;, &#123;_id : 1, host : &quot;10.253.164.220:27002&quot; &#125;, &#123;_id : 2, host : &quot;10.253.164.242:27002&quot; &#125; ] &#125;#初始化副本集配置rs.initiate(config);#查看分区状态rs.status(); 3.3、设置第三个分片副本集在服务器上，10.253.164.220、10.253.164.242、10.253.164.244 配置文件：vi /mnt/mongodb/conf/shard3.conf，其中bindIp换成对应机器的ip ## 配置文件内容# 系统日志systemLog: destination: file logAppend: true path: &#x2F;mnt&#x2F;mongodb&#x2F;shard3&#x2F;log&#x2F;shard3.log # 文件存储storage: dbPath: &#x2F;mnt&#x2F;mongodb&#x2F;shard3&#x2F;data journal: enabled: true wiredTiger: #WT引擎配置 engineConfig: cacheSizeGB: 4 #设置为4G,默认为物理内存的一半 directoryForIndexes: true #是否将索引也按数据库名单独存储 journalCompressor: zlib collectionConfig: #表压缩配置 blockCompressor: zlib indexConfig: #索引配置 prefixCompression: true# 进程processManagement: fork: true pidFilePath: &#x2F;mnt&#x2F;mongodb&#x2F;shard3&#x2F;log&#x2F;shard3.pid # 网络接口net: port: 27003 bindIp: 10.253.164.220# 副本集replication: replSetName: shard3sharding: clusterRole: shardsvr 启动三台服务器的shard3 server mongod -f &#x2F;mnt&#x2F;mongodb&#x2F;conf&#x2F;shard3.conf 登陆任意一台服务器，初始化副本集 mongo 10.253.164.220:27003#使用admin数据库use admin#定义副本集配置config = &#123; _id : \"shard3\", members : [ &#123;_id : 0, host : \"10.253.164.220:27003\" &#125;, &#123;_id : 1, host : \"10.253.164.242:27003\" &#125;, &#123;_id : 2, host : \"10.253.164.244:27003\" &#125; ] &#125;#初始化副本集配置rs.initiate(config);#查看分区状态rs.status(); 3.4、设置第四个分片副本集在服务器上，10.253.164.242、10.253.164.244、10.253.173.95 配置文件：vi /mnt/mongodb/conf/shard4.conf，其中bindIp换成对应机器的ip ## 配置文件内容# 系统日志systemLog: destination: file logAppend: true path: /mnt/mongodb/shard4/log/shard4.log # 文件存储storage: dbPath: /mnt/mongodb/shard4/data journal: enabled: true wiredTiger: #WT引擎配置 engineConfig: cacheSizeGB: 4 #设置为4G,默认为物理内存的一半 directoryForIndexes: true #是否将索引也按数据库名单独存储 journalCompressor: zlib collectionConfig: #表压缩配置 blockCompressor: zlib indexConfig: #索引配置 prefixCompression: true# 进程processManagement: fork: true pidFilePath: /mnt/mongodb/shard4/log/shard4.pid # 网络接口net: port: 27004 bindIp: 10.253.164.242# 副本集replication: replSetName: shard4sharding: clusterRole: shardsvr 启动三台服务器的shard4 server mongod -f &#x2F;mnt&#x2F;mongodb&#x2F;conf&#x2F;shard4.conf 登陆任意一台服务器，初始化副本集 mongo 10.253.164.242:27004#使用admin数据库use admin#定义副本集配置config &#x3D; &#123; _id : &quot;shard4&quot;, members : [ &#123;_id : 0, host : &quot;10.253.164.242:27004&quot; &#125;, &#123;_id : 1, host : &quot;10.253.164.244:27004&quot; &#125;, &#123;_id : 2, host : &quot;10.253.173.95:27004&quot; &#125; ] &#125;#初始化副本集配置rs.initiate(config);#查看分区状态rs.status(); 3.5、设置第五个分片副本集在服务器上，10.253.164.244、10.253.173.95、10.253.173.108 配置文件：vi /mnt/mongodb/conf/shard5.conf，其中bindIp换成对应机器的ip ## 配置文件内容# 系统日志systemLog: destination: file logAppend: true path: /mnt/mongodb/shard5/log/shard5.log # 文件存储storage: dbPath: /mnt/mongodb/shard5/data journal: enabled: true wiredTiger: #WT引擎配置 engineConfig: cacheSizeGB: 4 #设置为4G,默认为物理内存的一半 directoryForIndexes: true #是否将索引也按数据库名单独存储 journalCompressor: zlib collectionConfig: #表压缩配置 blockCompressor: zlib indexConfig: #索引配置 prefixCompression: true# 进程processManagement: fork: true pidFilePath: /mnt/mongodb/shard5/log/shard5.pid # 网络接口net: port: 27005 bindIp: 10.253.164.244# 副本集replication: replSetName: shard5sharding: clusterRole: shardsvr 启动三台服务器的shard5 server mongod -f &#x2F;mnt&#x2F;mongodb&#x2F;conf&#x2F;shard5.conf 登陆任意一台服务器，初始化副本集 mongo 10.253.164.244:27005#使用admin数据库use admin#定义副本集配置config &#x3D; &#123; _id : &quot;shard5&quot;, members : [ &#123;_id : 0, host : &quot;10.253.164.244:27005&quot; &#125;, &#123;_id : 1, host : &quot;10.253.173.95:27005&quot; &#125;, &#123;_id : 2, host : &quot;10.253.173.108:27005&quot; &#125; ] &#125;#初始化副本集配置rs.initiate(config);#查看分区状态rs.status(); 4、配置路由服务器 mongos先启动配置服务器和分片服务器,后启动路由实例启动路由实例:10.253.173.95、10.253.173.108 配置路由服务器：vi /mnt/mongodb/conf/mongos.conf systemLog: destination: file logAppend: true path: /mnt/mongodb/mongos/log/mongos.logprocessManagement: fork: truenet: port: 20000 bindIp: 10.253.164.220#监听的配置服务器,只能有1个或者3个 configs为配置服务器的副本集名字sharding: configDB: config/10.253.173.95:21000,10.253.173.108:21000,10.253.164.220:21000 启动二台服务器的mongos server mongos --config &#x2F;mnt&#x2F;mongodb&#x2F;conf&#x2F;mongos.conf 5、启用分片目前搭建了mongodb配置服务器、路由服务器，各个分片服务器，不过应用程序连接到mongos路由服务器并不能使用分片机制，还需要在程序里设置分片配置，让分片生效。 登陆任意一台mongos mongo 10.253.173.95:20000#使用admin数据库use admin#串联路由服务器与分配副本集sh.addShard(&quot;shard1&#x2F;10.253.173.95:27001,10.253.173.108:27001,10.253.164.220:27001&quot;)sh.addShard(&quot;shard2&#x2F;10.253.173.108:27002,10.253.164.220:27002,10.253.164.242:27002&quot;)sh.addShard(&quot;shard3&#x2F;10.253.164.220:27003,10.253.164.242:27003,10.253.164.244:27003&quot;)sh.addShard(&quot;shard4&#x2F;10.253.164.242:27004,10.253.164.244:27004,10.253.173.95:27004&quot;)sh.addShard(&quot;shard5&#x2F;10.253.164.244:27005,10.253.173.95:27005,10.253.173.108:27005&quot;)#查看集群状态sh.status() 6、测试目前配置服务、路由服务、分片服务、副本集服务都已经串联起来了，但我们的目的是希望插入数据，数据能够自动分片。连接在mongos上，准备让指定的数据库、指定的集合分片生效。 mongo 10.253.173.95:20000#使用adminuse admin;#指定testdb分片生效db.runCommand( &#123; enablesharding :\"userinfodb\"&#125;);#指定数据库里需要分片的集合和片键db.runCommand(&#123;shardcollection : \"userinfodb.authinfo\",key : &#123;id:1&#125;&#125;) 我们设置testdb的 table1 表需要分片，根据 id 自动分片到 shard1 ，shard2，shard3，shard4，shard5 上面去。要这样设置是因为不是所有mongodb 的数据库和表 都需要分片！ 测试分片配置结果 mongo 10.253.173.95:20000#使用userinfodbuse userinfodb;#插入测试数据for (var i = 1; i &lt;= 1000; i++)db.authinfo.save(&#123;id:i,\"test1\":\"testval1\"&#125;)#查看分片情况如下，部分无关信息省掉了db.authinfo.stats();&#123; \"sharded\" : true, \"ns\" : \"testdb.table1\", \"count\" : 100000, \"numExtents\" : 13, \"size\" : 5600000, \"storageSize\" : 22372352, \"totalIndexSize\" : 6213760, \"indexSizes\" : &#123; \"_id_\" : 3335808, \"id_1\" : 2877952 &#125;, \"avgObjSize\" : 56, \"nindexes\" : 2, \"nchunks\" : 3, \"shards\" : &#123; \"shard1\" : &#123; \"ns\" : \"testdb.table1\", \"count\" : 42183, \"size\" : 0, ... \"ok\" : 1 &#125;, \"shard2\" : &#123; \"ns\" : \"testdb.table1\", \"count\" : 38937, \"size\" : 2180472, ... \"ok\" : 1 &#125;, \"shard3\" : &#123; \"ns\" : \"testdb.table1\", \"count\" :18880, \"size\" : 3419528, ... \"ok\" : 1 &#125; &#125;, \"ok\" : 1&#125; 可以看到数据分到3个分片，各自分片数量为： shard1 “count” : 42183，shard2 “count” : 38937，shard3 “count” : 18880。已经成功了！ 7、创建认证用户7.1 首先建立一个拥有添加删除用户权限的账号db.createUser(&#123; user:\"useradmin\", pwd:\"123456\", roles: [ &#123; role: \"userAdminAnyDatabase\",db:\"admin\"&#125;, &#123; role : \"clusterAdmin\", db : \"admin\" &#125; ]&#125;)db.auth(\"useradmin\",\"123456\")//认证该用户 这里就添加了一个useradmin这么一个用户，他可以进行所有数据库的用户管理。在添加这个用户后，我们连接mongodb时仍然不需要进行登录，这是因为我们未在配置中开启权限验证。 7.2.开启分片集群的权限验证7.2.1 首先生成一个添加keyFile文件—–&gt;用于认证使用openssl rand -base64 753 &gt;mongodb-keyfilemkdir -p /mnt/mongodb/key/cp mongodb-keyfile /mnt/mongodb/key/chmod 600 /mnt/mongodb/key/mongodb-keyfile 复制mongodb-keyfile文件到其他集群scp /mnt/mongodb/key/mongodb-keyfile root@10.253.173.95:/mnt/mongodb/key/ 7.2.2 在各个分片以及configserver的配置文件中加上如下语句#开启权限验证security: authorization: enabled keyFile: /mnt/mongodb/key/mongodb-keyfile 7.2.3 在每台机器上的mongos配置文件中加入下面一段配置#开启权限验证security: keyFile: /mnt/mongodb/key/mongodb-keyfile 8、启动关闭mongodb的启动顺序是，先启动配置服务器，在启动分片，最后启动mongos. mongod -f /mnt/mongodb/conf/config.confmongod -f /mnt/mongodb/conf/shard1.confmongod -f /mnt/mongodb/conf/shard2.confmongod -f /mnt/mongodb/conf/shard3.confmongos --config /mnt/mongodb/conf/mongos.conf 关闭时，直接killall杀掉所有进程 killall mongodkillall mongos 9、用户权限9.1、创建用户use admindb.createUser(&#123;user:'superadmin',pwd:'123456', roles:[&#123;role:'root', db:'admin'&#125;]&#125;) ---创建超级管理员用户 db.createUser(&#123;user:'useradmin',pwd:'123456', roles:[&#123;role:'userAdminAnyDatabase', db:'admin'&#125;]&#125;) ---创建用户管理员账户（能查询其他库集合，但不能查询集合内容） db.createUser(&#123;user:'admin',pwd:'123456', roles:[&#123;role:'readWriteAnyDatabase', db:'admin'&#125;]&#125;) ---创建访问任意库读写的账户 db.createUser(&#123;user:'user1',pwd:'user1',roles:[&#123;role:'readWrite',db:'test'&#125;]&#125;) ---创建只对test库有读写权限的用户 db.createUser(&#123;user:\"bkuser2\",pwd:\"Bkuser2\",roles:[&#123;role:\"backup\",db:\"admin\"&#125;]&#125;) ---创建用于备份时的用户，如若是恢复权限，则将backup换为restore即可 9.2、用户查询&gt;use admin&gt;db.system.users.find().pretty() ---将所有用户信息查询出来显示某一库下的所有用户&gt;use test&gt;show users ---显示在此库授权的用户信息 9.3、修改用户权限db.updateUser(\"root\", &#123;roles:[&#123;role:\"readWriteAnyDatabase\", db:\"admin\"&#125;]&#125;) 在原来权限上新增权限 db.grantRolesToUser(\"jianlong\",[&#123;role:'readWrite',db:'test'&#125;]) ---不会覆盖原权限信息，只新增权限 9.4、修改用户密码db.changeUserPassword(\"tuser\",\"123456\") 9.5、删除用户db.system.users.remove(&#123;user:&quot;tuser&quot;&#125;); 10、mongodb常用数据库命令10.1、数据库操作show dbs;#查看数据库use test;#如果没有就创建一个db;#查看当前数据库db.dropDatabase();#删除数据库 10.2、数据操作插入 show collections；#查看集合create collection;#创建集合db.student.insert(&#123;\"name\":\"张三\",\"age\":\"22\",\"sex\":\"男\",\"class\":\"计算机2班\"&#125;);#如果数据库中不存在集合，就创建并插入这些数据db.student.insert(&#123;\"name\":\"李四\",\"age\":\"22\",\"sex\":\"女\",\"phone\":\"18513081650\",\"class\":\"计算机1班\"&#125;);#里面的key-value不用保持一致db.student.insert([&#123;\"name\":\"王五\",\"age\":\"22\",\"sex\":\"男\",\"class\":\"计算机2班\"&#125;,&#123;\"name\":\"赵六\",\"age\":\"22\",\"sex\":\"女\",\"phone\":\"18513081650\",\"class\":\"计算机1班\"&#125;]);#同时插入多条数据 更新 db.student.update(&#123;\"name\":\"张三\"&#125;,&#123;\"name\":\"张三丰\"&#125;);#如果有多条语句，只修改第一条，会覆盖原有数据db.student.update(&#123;\"22\":\"女\"&#125;,&#123;\"name\":\"张三丰\"&#125;);db.student.update(&#123;\"name\":\"张三\"&#125;,&#123;$set:&#123;\"name\":\"张无忌\"&#125;&#125;);#只想改某个key的value使用setdb.student.update(&#123;\"name\":\"王五\"&#125;,&#123;$set:&#123;\"name\":\"张无忌\"&#125;&#125;,&#123;multi:true&#125;);#把所有的记录都改了 查询 db.student.find();#查询全部db.student.find(&#123;\"name\":\"李四\"&#125;);#查询指定记录，返回这一行结果db.student.update(&#123;\"name\":\"张三丰\"&#125;,&#123;\"name\":\"张无忌\",\"age\":\"28\",\"sex\":\"男\"&#125;);db.student.find(&#123;\"name\":\"张无忌\",\"age\":\"28\"&#125;);#and操作db.student.find(&#123;$or:[&#123;\"name\":\"张无忌\"&#125;,&#123;\"name\":\"李四\"&#125;]&#125;);#or操作db.student.find().pretty();#格式化显示db.student.find().count();#获取结果的行数db.student.find().sort(&#123;\"age\":-1&#125;);#按照sort里面key的值排序，1为正序，-1为倒序 删除 db.student.remove();#删除所有数据db.student.remove(&#123;\"22\":\"女\"&#125;);#按照条件删除db.student.remove(&#123;\"name\":\"张无忌\"&#125;,2);#删除几条","categories":[],"tags":[]},{"title":"blog/linux/linux安装nacos集群","slug":"blog/linux/linux安装nacos集群","date":"2020-04-18T07:01:23.084Z","updated":"2020-04-18T07:01:23.084Z","comments":true,"path":"blog/linux/linux安装nacos集群/","link":"","permalink":"http://www.matosiki.site/blog/linux/linux%E5%AE%89%E8%A3%85nacos%E9%9B%86%E7%BE%A4/","excerpt":"","text":"linux安装nacos集群下载nacos源码git clone https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;nacos.git cd nacos&#x2F;distributionvi conf&#x2F;application.properties 添加数据库配置spring.datasource.platform=mysqldb.num=2db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.url.1=jdbc:mysql://11.163.152.9:3306/nacos_devtest?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=truedb.user=nacos_devtestdb.password=nacos 更改集群配置cd conf&#x2F;cp cluster.conf.example cluster.confvi cluster.conf 192.168.2.147:8848192.168.175.128:8848192.168.175.130:8848 初始化mmysql在mysql中执行 nacos-mysql.sql 测试环境jvm调优#===========================================================================================# JVM Configuration#===========================================================================================if [[ \"$&#123;MODE&#125;\" == \"standalone\" ]]; then JAVA_OPT=\"$&#123;JAVA_OPT&#125; -Xms512m -Xmx512m -Xmn256m\" JAVA_OPT=\"$&#123;JAVA_OPT&#125; -Dnacos.standalone=true\"else JAVA_OPT=\"$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=128m\" JAVA_OPT=\"$&#123;JAVA_OPT&#125; -XX:-OmitStackTraceInFastThrow -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=$&#123;BASE_DIR&#125;/logs/java_heapdump.hprof\" JAVA_OPT=\"$&#123;JAVA_OPT&#125; -XX:-UseLargePages\" fi 启动nacos# 在nacos的根部目录中执行mvn -Prelease-nacos clean install -Ucd nacos/distribution/target/nacos-server&#123;vers&#125;/nacos/binsh startup.sh 问题解决数据库连接失败 可能版本不一致如果使用8.0mysql 手动更换mysql版本 更改根目录xml&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt;&lt;/dependency&gt;","categories":[],"tags":[]},{"title":"blog/linux/centos安装配置yum","slug":"blog/linux/centos安装配置yum","date":"2020-04-18T07:01:23.083Z","updated":"2020-04-18T07:01:23.083Z","comments":true,"path":"blog/linux/centos安装配置yum/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEyum/","excerpt":"","text":"centos安装配置yum配置yum仓库aliyun镜像 yum install wgetcd /etc/yum.repos.d sudo mv CentOS-Base.repo CentOS-Base.repo.bak sudo wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo yum clean all yum makecache","categories":[],"tags":[]},{"title":"blog/linux/centos安装集群redis","slug":"blog/linux/centos安装集群redis","date":"2020-04-18T07:01:23.083Z","updated":"2020-04-18T07:01:23.083Z","comments":true,"path":"blog/linux/centos安装集群redis/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E9%9B%86%E7%BE%A4redis/","excerpt":"","text":"centos安装集群redis下载redis wget http://tar.matosiki.site/tar/redis-4.0.9.tar.gztar -zxvf redis-4.0.9.tar.gzmv redis-4.0.9 /opt/cd /opt/redis-4.0.9/mkdir -p /opt/redis-4.0.9/redis_clustercp redis.conf redis_cluster# 编辑redis配置文件vim redis_cluster/redis.conf bind 0.0.0.0 //默认ip为127.0.0.1 也可以改为局域网 192.168.10.220daemonize yes //redis后台运行pidfile /var/run/redis_6379.pid //pidfile文件对应7000,7001,7002cluster-enabled yes //开启集群 把注释#去掉cluster-config-file nodes_6379.conf //集群的配置cluster-node-timeout 15000 //请求超时 默认15秒，可自行设置appendonly yes //aof日志开启 有需要就开启，它会每次写操作都记录一条日志 添加6个节点分别更改配置文件 cp redis_cluster/redis.conf redis_cluster/redis-7000.confcp redis_cluster/redis.conf redis_cluster/redis-7001.confcp redis_cluster/redis.conf redis_cluster/redis-7002.confcp redis_cluster/redis.conf redis_cluster/redis-7003.confcp redis_cluster/redis.conf redis_cluster/redis-7004.confcp redis_cluster/redis.conf redis_cluster/redis-7005.confvim redis_cluster/redis-7000.conf:%s/6379/7000/gvim redis_cluster/redis-7001.conf:%s/6379/7001/gvim redis_cluster/redis-7002.conf:%s/6379/7002/gvim redis_cluster/redis-7003.conf:%s/6379/7003/gvim redis_cluster/redis-7004.conf:%s/6379/7004/gvim redis_cluster/redis-7005.conf:%s/6379/7005/g# 启动所有节点src/redis-server redis_cluster/redis.confsrc/redis-server redis_cluster/redis-7000.confsrc/redis-server redis_cluster/redis-7001.confsrc/redis-server redis_cluster/redis-7002.confsrc/redis-server redis_cluster/redis-7003.confsrc/redis-server redis_cluster/redis-7004.confsrc/redis-server redis_cluster/redis-7005.conf 安装ruby并升级ruby-redis yum -y install ruby ruby-devel rubygems rpm-buildgpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3curl -L get.rvm.io | bash -s stable source /usr/local/rvm/scripts/rvmrvm list known# 升级ruby#安装rubyrvm install 2.4.0#使用新版本rvm use 2.4.0#移除旧版本rvm remove 2.0.0#查看当前版本ruby --versiongem install redis 新建分片参数create表示创建一个新的集群，–replicas 1表示为每个master创建一个slave # 单机请使用./src/redis-trib.rb create --replicas 1 0.0.0.0:7000 0.0.0.0:7001 \\ 0.0.0.0:7002 0.0.0.0:7003 0.0.0.0:7004 0.0.0.0:7005 # master-slave请使用 先用telnet测试端口是否可以访问./src/redis-trib.rb create --replicas 1 192.168.10.220:6379 192.168.10.221:6379 192.168.10.220:7000 192.168.10.221:7000 192.168.10.220:7001 192.168.10.221:7001 192.168.10.220:7002 192.168.10.221:7002 192.168.10.220:7003 192.168.10.221:7003 192.168.10.220:7004 192.168.10.221:7004 192.168.10.220:7005 192.168.10.221:7005 完成测试 $ redis-cli -c -p 7000redis 127.0.0.1:7000&gt; set foo bar-&gt; Redirected to slot [12182] located at 127.0.0.1:7002OKredis 127.0.0.1:7002&gt; set hello world-&gt; Redirected to slot [866] located at 127.0.0.1:7000OKredis 127.0.0.1:7000&gt; get foo-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\"bar\"redis 127.0.0.1:7000&gt; get hello-&gt; Redirected to slot [866] located at 127.0.0.1:7000\"world\" 查看集群状态 127.0.0.1:7000&gt; cluster infocluster_state:ok #集群状态cluster_slots_assigned:16384 #被分配的槽位数cluster_slots_ok:16384 #正确分配的槽位cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6 #当前节点cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_ping_sent:48273cluster_stats_messages_pong_sent:49884cluster_stats_messages_sent:98157cluster_stats_messages_ping_received:49879cluster_stats_messages_pong_received:48273cluster_stats_messages_meet_received:5cluster_stats_messages_received:98157 使用cluster nodes命令查看节点状态。127.0.0.1:7000&gt; cluster nodes58d1fe2d2f06144def4a7de79f6851e0c68d316b 127.0.0.1:7000@17000 slave 45fd67328af03fe008dd3605baaeb347373dd9c8 0 1539090532575 6 connected45fd67328af03fe008dd3605baaeb347373dd9c8 127.0.0.1:7001@17001 myself,master - 0 1539090533000 1 connected 0-54604387192aad51ddf6df1b5c9716088d2e96a55149 127.0.0.1:7002@17002 master - 0 1539090534579 2 connected 5461-10922b9afd1c136a5b379c695b8c49b3119f6daa25aa0 127.0.0.1:7005@17005 slave 7990a7b654836850ff207146a790f9fec2f0199d 0 1539090535580 5 connectedc00d297dc429033ea2396a176d610d6acabe5b62 127.0.0.1:7004@17004 slave 4387192aad51ddf6df1b5c9716088d2e96a55149 0 1539090534000 4 connected7990a7b654836850ff207146a790f9fec2f0199d 127.0.0.1:7003@17003 master - 0 1539090534000 3 connected 10923-16383 重新安装集群.&#x2F;src&#x2F;redis-cli -p 3679 shutdown.&#x2F;src&#x2F;redis-cli -p 7000 shutdown.&#x2F;src&#x2F;redis-cli -p 7001 shutdown.&#x2F;src&#x2F;redis-cli -p 7002 shutdown.&#x2F;src&#x2F;redis-cli -p 7003 shutdown.&#x2F;src&#x2F;redis-cli -p 7004 shutdown.&#x2F;src&#x2F;redis-cli -p 7005 shutdownrm -f dump.rdbrm -f appendonly.aofrm -f nodes-*.conf ### # 查看集群节点状态./src/redis-cli -p 7000 cluster nodes 给redis添加密码vi redis_cluster/redis.confvi redis_cluster/redis-7000.confvi redis_cluster/redis-7001.confvi redis_cluster/redis-7002.confvi redis_cluster/redis-7003.confvi redis_cluster/redis-7004.confvi redis_cluster/redis-7005.conf masterauth 123456requirepass 123456","categories":[],"tags":[]},{"title":"blog/linux/centos系统设置同步时间","slug":"blog/linux/centos系统设置同步时间","date":"2020-04-18T07:01:23.083Z","updated":"2020-04-18T07:01:23.083Z","comments":true,"path":"blog/linux/centos系统设置同步时间/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE%E5%90%8C%E6%AD%A5%E6%97%B6%E9%97%B4/","excerpt":"","text":"centos系统设置同步时间上海市区设置 cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtimeecho &#39;Asia&#x2F;Shanghai&#39; &gt;&#x2F;etc&#x2F;timezone 安装ntpdate工具 yum -y install ntp ntpdate 设置系统时间与网络时间同步 ntpdate cn.pool.ntp.orgor &#x3D;&gt; ntpdate -u ntp.api.bz 将系统时间写入硬件时间 hwclock --systohc 4.查看硬件时 hwclock --show","categories":[],"tags":[]},{"title":"blog/linux/centos防火墙","slug":"blog/linux/centos防火墙","date":"2020-04-18T07:01:23.083Z","updated":"2020-04-18T07:01:23.083Z","comments":true,"path":"blog/linux/centos防火墙/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E9%98%B2%E7%81%AB%E5%A2%99/","excerpt":"","text":"centos防火墙firewalld管理方案如果要添加范围例外端口 如 1000-2000语法命令如下：启用区域端口和协议组合firewall-cmd [--zone=&lt;zone&gt;] --add-port=&lt;port&gt;[-&lt;port&gt;]/&lt;protocol&gt; [--timeout=&lt;seconds&gt;]此举将启用端口和协议的组合。端口可以是一个单独的端口 &lt;port&gt; 或者是一个端口范围 &lt;port&gt;-&lt;port&gt; 。协议可以是 tcp 或 udp。实际命令如下： # 添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）firewall-cmd --zone=public --add-port=8000-10000/tcp --permanent # 重新载入firewall-cmd --reload# 查看firewall-cmd --zone=public --query-port=80/tcp# 删除firewall-cmd --zone=public --remove-port=80/tcp --permanent 使用ipttables方式管理防火墙 开启防火墙并重置systemctl stop firewalldsystemctl mask firewalld 安装iptablesyum install iptables-services 默认开启iptables服务systemctl enable iptables 开放某个端口 在/etc/sysconfig/iptables里添加vi /etc/sysconfig/iptables-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 保存iptables配置service iptables save （如果iptables还原了使用）iptables-savesystemctl reload iptables 开启iptablessystemctl stop iptablessystemctl start iptablessystemctl restart iptables","categories":[],"tags":[]},{"title":"blog/linux/centos安装单机elasticseach","slug":"blog/linux/centos安装单机elasticseach","date":"2020-04-18T07:01:23.082Z","updated":"2020-04-18T07:01:23.082Z","comments":true,"path":"blog/linux/centos安装单机elasticseach/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BAelasticseach/","excerpt":"","text":"centos安装单机elasticseach预装环境jdk1.8 curl -O http://tar.matosiki.site/tar/elasticsearch-6.4.2.tar.gztar -vxzf elasticsearch-6.4.2.tar.gz -C /opt/cd /opt/elasticsearch-6.4.2/config 更改elasticsearch配置 vim elasticsearch.ymlnetwork.host: 0.0.0.0http.port: 9200node.max_local_storage_nodes: 256 更改用户最大可创建文件数 vi /etc/security/limits.conf soft nofile 65536hard nofile 131072soft nproc 2048hard nproc 4096 用户最大可创建线程数vi /etc/security/limits.d/20-nproc.conf soft nproc 4096 更改最大虚拟内存vi /etc/sysctl.conf vm.max_map_count&#x3D;655360 执行命令sysctl -p 本地测试环境调优 vim /opt/elasticsearch-6.4.2/config/jvm.options -Xms512m-Xmx512m groupadd esuseradd es -g escd /opt/chown -R es:es ./elasticsearch-6.4.2#切换到es用户su es cd /opt/elasticsearch-6.4.2/bin#-d代表后台进程方式启动 ./elasticsearch -d # 关闭elasticsearchjps | grep Elasticsearch3673 Elasticsearchkill -9 3673 安装插件安装分词器curl -O http://tar.matosiki.site/zip/elasticsearch-analysis-ik-6.4.2.zipunzip elasticsearch-analysis-ik-6.4.2.zip -d /opt/elasticsearch-6.4.2/plugins/ik/# 重启测试curl -XGET -H 'Content-Type: application/json' 'http://localhost:9200/_analyze?pretty' -d '&#123; \"analyzer\" : \"ik_max_word\", \"text\": \"中华人民共和国国歌\"&#125;' 安装Kiban 分析和可视化平台curl -O http://tar.matosiki.site/tar/kibana-6.4.2-linux-x86_64.tar.gztar -vxzf kibana-6.4.2-linux-x86_64.tar.gz -C /opt/vi /opt/kibana-6.4.2-linux-x86_64/config/kibana.ymlserver.host: \"0.0.0.0\"elasticsearch.url: \"http://localhost:9200\"elasticsearch.username: \"kibana\"elasticsearch.password: \"kibana\"# 更改权限chown -R es:es /opt/kibana-6.4.2-linux-x86_64su esnohup /opt/kibana-6.4.2-linux-x86_64/bin/kibana &amp;# 测试访问curl http://localhost:5601/ 安装 X-Pack（安装x-pack需要先安装kibana）X-Pack是一个Elastic Stack扩展，它将安全性，警报，监视，报告和图形功能捆绑到一个易于安装的软件包中 这个6.4.2版本默认包含x-pack# ~~在Elasticsearch中安装x-pack~~/opt/elasticsearch-6.4.2/bin/elasticsearch-plugin install x-pack# ~~启动elasticsearch~~ bin/elasticsearch# 生成默认用户名和密码（ elastic and kibana users）/opt/elasticsearch-6.4.2/bin/x-pack/setup-passwords auto# Kibana中安装 X-Pack /opt/kibana-6.4.2-linux-x86_64/bin/kibana-plugin install x-pack# 在kibana.yml 中添加用户名密码elasticsearch.username: \"kibana\"elasticsearch.password: \"&lt;pwd&gt;\"# 启动 Kibanabin/kibana# 测试访问 登录elastic curl http://localhost:5601/ 安装 logstashLogstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集起来，并进行自定义的处理，然后传输到指定的位置，比如某个服务器或者文件。能集中处理各种类型的数据，能标准化不同模式和格式的数据，能快速的扩展自定义日志的格式，能非常方便的添加插件来自定义数据源, Logstash采用JRuby开发的，本身也支持插件的功能 ELK：开源分布式日志分析搜索平台 E: elasticsearch, 负责数据的存储和查询L: logstash, 负责日志数据的过滤和解析K: Kibana, 负责web方式的前端展现 input: 用于处理输入的filter: 用于处理过滤的output: 用于处理输出的 curl -O http://tar.matosiki.site/tar/logstash-6.4.2.tar.gztar -vxzf logstash-6.4.2.tar.gz -C /opt/# 更改权限chown -R es:es /opt/logstash-6.4.2/su es# 启动/opt/logstash-6.4.2/bin/logstash -e \"input &#123; stdin &#123;&#125; &#125; output &#123; stdout &#123;&#125; &#125;\"# 自定义输出配置启动vi logstash-simple.confinput &#123; stdin &#123; &#125; &#125;output &#123; elasticsearch &#123; hosts =&gt; [\"localhost:9200\"] &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125;/opt/logstash-6.4.2/bin/logstash -f logstash-simple.conf &amp;","categories":[],"tags":[]},{"title":"blog/linux/centos安装单机rabbitmq","slug":"blog/linux/centos安装单机rabbitmq","date":"2020-04-18T07:01:23.082Z","updated":"2020-04-18T07:01:23.082Z","comments":true,"path":"blog/linux/centos安装单机rabbitmq/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BArabbitmq/","excerpt":"","text":"centos安装单机rabbitmq下载安装erlang yum install -y epel-releaseyum install -y erlangwget https:&#x2F;&#x2F;packages.erlang-solutions.com&#x2F;erlang-solutions-1.0-1.noarch.rpmrpm -Uvh erlang-solutions-1.0-1.noarch.rpmyum install -y socat 安装RabbitMQ sudo rpm --import https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;rabbitmq-release-signing-key.ascwget https:&#x2F;&#x2F;www.rabbitmq.com&#x2F;releases&#x2F;rabbitmq-server&#x2F;v3.6.6&#x2F;rabbitmq-server-3.6.6-1.el7.noarch.rpm # 下载RabbitMQ安装包sudo yum install rabbitmq-server-3.6.6-1.el7.noarch.rpm RabbitMQ的基本操作 启动 添加用户 默认使用端口有两个 5672 和 15672 # 查看hostnamehostnamevim &#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq-env.confNODENAME&#x3D;rabbit@[hostname] # 更改hostnameNODE_IP_ADDRESS&#x3D;127.0.0.1# 运行RabbitMQ&#x2F;sbin&#x2F;rabbitmq-server $ sudo chkconfig rabbitmq-server on # 添加开机启动RabbitMQ服务$ sudo &#x2F;sbin&#x2F;service rabbitmq-server start # 启动服务$ sudo &#x2F;sbin&#x2F;service rabbitmq-server status # 查看服务状态$ sudo &#x2F;sbin&#x2F;service rabbitmq-server stop # 停止服务# 查看当前所有用户$ sudo rabbitmqctl list_users# 查看默认guest用户的权限$ sudo rabbitmqctl list_user_permissions guest# 由于RabbitMQ默认的账号用户名和密码都是guest。为了安全起见, 先删掉默认用户$ sudo rabbitmqctl delete_user guest# 添加新用户$ sudo rabbitmqctl add_user username password# 设置用户tag$ sudo rabbitmqctl set_user_tags username administrator# 赋予用户默认vhost的全部操作权限$ sudo rabbitmqctl set_permissions -p &#x2F; username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;# 查看用户的权限$ sudo rabbitmqctl list_user_permissions username 查看日志 erlang故障排除erl -sname testnode().net_adm:names().net_adm:ping(&#39;rabbite@master&#39;). # 确认连上rabbite节点rpc:call(&#39;rabbite@master&#39;,erlang,system_info,[process_count]) # 获得该节点erlang进程数rpc:call(&#39;rabbite@master&#39;,mnesia,info,[])# 退出执行q(). 启动Rabbit web manager sudo rabbitmq-plugins enable rabbitmq_management# 内部测试 外网需要打开防火墙 默认用户名guest密码guest 只支持localhost登录 远程登录需要添加账户curl http:&#x2F;&#x2F;localhost:15672 添加账户 添加延迟队列exchange插件插件列表https://dl.bintray.com/rabbitmq/community-plugins/cd &#x2F;usr&#x2F;lib&#x2F;rabbitmq&#x2F;lib&#x2F;rabbitmq_server-3.6.6&#x2F;pluginswget https:&#x2F;&#x2F;dl.bintray.com&#x2F;rabbitmq&#x2F;community-plugins&#x2F;rabbitmq_delayed_message_exchange-0.0.1.ezrabbitmq-plugins enable rabbitmq_delayed_message_exchange 配置RabbitMQ下载配置模板官网解释 cd &#x2F;etc&#x2F;rabbitmq&#x2F;wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;master&#x2F;docs&#x2F;rabbitmq.conf.examplecp rabbitmq.conf.example rabbitmq.confvim rabbitmq.conf # 开启远程访问&#123;loopback_users, [&quot;username&quot;]&#125;sudo &#x2F;sbin&#x2F;service rabbitmq-server restart 相关链接 rabbitmq官网：http://www.rabbitmq.com/install-rpm.html erlang官网： https://www.erlang-solutions.com/resources/download.html RabbitMQ文档 https://www.rabbitmq.com/documentation.html RabbitMQ服务端配置 https://www.rabbitmq.com/admin-guide.html rabbitmqctl手册 https://www.rabbitmq.com/rabbitmqctl.8.html RabbitMQ web界面操作的命令行工具 https://www.rabbitmq.com/management-cli.html 网易开源镜像站 http://mirrors.163.com/ centos镜像使用 http://mirrors.163.com/.help/centos.html","categories":[],"tags":[]},{"title":"blog/linux/centos安装单机rocketmq","slug":"blog/linux/centos安装单机rocketmq","date":"2020-04-18T07:01:23.082Z","updated":"2020-04-18T07:01:23.082Z","comments":true,"path":"blog/linux/centos安装单机rocketmq/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BArocketmq/","excerpt":"","text":"centos安装单机rocketmq官网下载 curl -O http:&#x2F;&#x2F;tar.matosiki.site&#x2F;zip&#x2F;rocketmq-all-4.3.0-bin-release.zipunzip rocketmq-all-4.3.0-bin-release.zipmv rocketmq-all-4.3.0-bin-release rocketmq-all-4.3.0vi &#x2F;etc&#x2F;profileexport NAMESRV_ADDR&#x3D;0.0.0.0:9876source &#x2F;etc&#x2F;profilecd &#x2F;opt&#x2F;rocketmq-all-4.3.0&#x2F;bin&#x2F;nohup sh mqnamesrv &amp;nohup sh mqbroker -n localhost:9876 &amp; 清理缓存： echo &quot;&quot; &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_cache 查看日志 tail -f ~&#x2F;logs&#x2F;rocketmqlogs&#x2F;namesrv.logtail -f ~&#x2F;logs&#x2F;rocketmqlogs&#x2F;broker.log 关闭服务 sh mqshutdown namesrvsh mqshutdown broker","categories":[],"tags":[]},{"title":"blog/linux/centos安装配置jdk1.8","slug":"blog/linux/centos安装配置jdk1.8","date":"2020-04-18T07:01:23.082Z","updated":"2020-04-18T07:01:23.082Z","comments":true,"path":"blog/linux/centos安装配置jdk1.8/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEjdk1.8/","excerpt":"","text":"centos安装配置jdk1.8清理之前的openjdk yum -y remove java java-1.8.0-openjdk 下载jdk 手动去官网下载 或者使用自己的对象存储地址下载 下载tar或者rpm （jdk-8u181-linux-x64.tar.gz | jdk-8u172-linux-x64.rpm） wget http://tar.matosiki.site/tart/jdk-8u181-linux-x64.tar.gz 如果是rpm使用命令安装 rpm -ivh jdk-8u172-linux-x64.rpm 上传到服务器 解压到固定目录 tar -zvxf jdk-8u181-linux-x64.tar.gz -C /usr/local/ 更改解压后jdk主目录文件夹名称 mv /usr/local/jdk1.8.0_181 /usr/local/jdk1.8 配置环境变量 vi /etc/profile export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8export JAVA_BIN&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8&#x2F;binexport PATH&#x3D;$PATH:$JAVA_HOME&#x2F;binexport CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATHSPH source /etc/profile 测试java java -version 快速安装方式 yum install java-1.8.0-openjdk* -y 自己编写的shell脚本cat &lt;&lt;EOF &gt;install_jdk1.8.shyum install -y wgetyum -y remove java java-1.8.0-openjdkwget http://tar.matosiki.site/tart/jdk-8u181-linux-x64.tar.gztar -zvxf jdk-8u181-linux-x64.tar.gz -C /usr/local/mv /usr/local/jdk1.8.0_181 /usr/local/jdk1.8echo \"请手动在/etc/profile 中添加环境变量 ,source /etc/profie,测试安装是否成功\"EOF","categories":[],"tags":[]},{"title":"blog/linux/centos安装配置kafka","slug":"blog/linux/centos安装配置kafka","date":"2020-04-18T07:01:23.082Z","updated":"2020-04-18T07:01:23.083Z","comments":true,"path":"blog/linux/centos安装配置kafka/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEkafka/","excerpt":"","text":"centos安装配置kafka预装环境： jdk1.8zookeeper curl -O http:&#x2F;&#x2F;tar.matosiki.site&#x2F;tar&#x2F;kafka_2.11-2.0.0.tgztar -zxvf kafka_2.11-2.0.0.tgz -C &#x2F;opt&#x2F;cd &#x2F;opt&#x2F;kafka_2.11-2.0.0&#x2F;# 修改配置vim &#x2F;opt&#x2F;kafka_2.11-2.0.0&#x2F;config&#x2F;server.properties #每台服务器的broker.id都不能相同broker.id&#x3D;101host.name&#x3D;192.168.126.100#监听地址 不能输入0.0.0.0listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;192.168.126.100:9092#在log.retention.hours&#x3D;168 下追加advertised.listeners&#x3D;PLAINTEXT:&#x2F;&#x2F;192.168.126.100:9092message.max.byte&#x3D;5242880default.replication.factor&#x3D;2replica.fetch.max.bytes&#x3D;5242880#设置zookeeper的连接端口zookeeper.connect&#x3D;192.168.126.100:2181,192.168.126.101:2181zookeeper.connection.timeout.ms&#x3D;1000000kafka.metrics.polling.interval.secs&#x3D;5kafka.metrics.reporters&#x3D;kafka.metrics.KafkaCSVMetricsReporterkafka.csv.metrics.dir&#x3D;&#x2F;tmp&#x2F;kafka_metricskafka.csv.metrics.reporter.enabled&#x3D;false 测试环境将内存改小 vim &#x2F;opt&#x2F;kafka_2.11-2.0.0&#x2F;bin&#x2F;kafka-server-start.sh # 1G改成512mexport KAFKA_HEAP_OPTS&#x3D;&quot;-Xmx512m -Xms512m&quot; # 启动&#x2F;opt&#x2F;kafka_2.11-2.0.0&#x2F;bin&#x2F;kafka-server-start.sh -daemon &#x2F;opt&#x2F;kafka_2.11-2.0.0&#x2F;config&#x2F;server.properties # 验证启动jps# 开启防火墙firewall-cmd --zone&#x3D;public --add-port&#x3D;9092&#x2F;tcp --permanentfirewall-cmd --reload #常用命令#创建topicbin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic MyTopic#查看topicbin&#x2F;kafka-topics.sh --list --zookeeper localhost:2181# producer生产消息bin&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic MyTopic# consumer 消费消息bin&#x2F;kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic MyTopic --from-beginning","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用redis","slug":"blog/linux/centos安装使用redis","date":"2020-04-18T07:01:23.081Z","updated":"2020-04-18T07:01:23.081Z","comments":true,"path":"blog/linux/centos安装使用redis/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8redis/","excerpt":"","text":"centos安装使用redis参考链接 Quickstart 简单安装 获取安装包 安装rediswget http://download.redis.io/redis-stable.tar.gztar xvzf redis-stable.tar.gzcd redis-stable# 编译make 2 . 解压后会看到redis五大组件 redis-server （核心服务） redis-sentinel （相当于监视器） redis-cli （客户端命令行接口） redis-benchmark （reids 性能检查） redis-check-aof （检查数据故障） 移动redis，将redis 做成可直接命令启动软件 （注意：/user/local/bin 需要在环境变量下也就是 $PATH下） # 将redis-server拷贝到 用户自行安装软件执行位置sudo cp src/redis-server /usr/local/bin/sudo cp src/redis-cli /usr/local/bin/ 暂不配置启动redis-server测试 $ redis-server15153:C 16 Aug 11:39:26.998 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo15153:C 16 Aug 11:39:26.998 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=15153, just started15153:C 16 Aug 11:39:26.999 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf..... 表示启动成功检查redis-server是否可以使用redis-cli pingPONG# 或者直接进入cli$ redis-cli redis 127.0.0.1:6379&gt; pingPONGredis 127.0.0.1:6379&gt; set mykey somevalueOKredis 127.0.0.1:6379&gt; get mykey\"somevalue\" 配置redis 准备redis配置文件夹 sudo mkdir /etc/redissudo mkdir /var/redis 复制配置模板 制作启动服务 sudo cp utils/redis_init_script /etc/init.d/redis_6379# 编辑配置服务sudo vi /etc/init.d/redis_6379 复制redis配置sudo cp redis.conf /etc/redis/6379.confsudo mkdir /var/redis/6379 编辑6379配置文件 设置daemonize为yes 默认为 no （进程守护） 设置pidfile 为 /var/run/redis_6379.pid 改变端口 port 改变日志等级 loglevel 改变日志输出文件地址 logfile= /var/log/redis_6379.log 设置默认目录 /var/redis/6379 设置服务开机启动等级 sudo update-rc.d redis_6379 defaults 或者 chkconfig --add redis_6379echo -e &quot;redis-server &#x2F;etc&#x2F;redis&#x2F;6379.conf\\n&quot; &gt;&gt; &#x2F;etc&#x2F;rc.local 启动服务 sudo /etc/init.d/redis_6379 start 关闭redis服务的三种方式 使用默认开启关闭服务方式/etc/init.d/redis_6379 stop/etc/init.d/redis_6379 start/etc/init.d/redis_6379 restart 如果是通过源码安装的redis，则可以通过redis的客户端程序redis-cli的shutdown命令来重启redisredis-cli -h 127.0.0.1 -p 6379 shutdown 查看进程pid 使用 kill命令杀死 使用终极武器 kill -9netstat -ntlp kill -9 [pid]","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用sonarqube","slug":"blog/linux/centos安装使用sonarqube","date":"2020-04-18T07:01:23.081Z","updated":"2020-04-18T07:01:23.081Z","comments":true,"path":"blog/linux/centos安装使用sonarqube/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8sonarqube/","excerpt":"","text":"centos安装使用sonarqube架构 环境centos 7mysqlsonarqube7.1 下载yum install unzip -ywget http:&#x2F;&#x2F;tar.matosiki.site&#x2F;zip&#x2F;sonarqube-7.3.zipunzip sonarqube-7.3.zipmv sonarqube-7.3 &#x2F;opt&#x2F;sudo groupadd sonarsudo useradd -g sonar sonarchown -R sonar.sonar &#x2F;opt&#x2F;sonarqube-7.3&#x2F; 进入mysql创建数据库CREATE DATABASE sonar CHARACTER SET utf8 COLLATE utf8_general_ci;CREATE USER &#39;sonar&#39;@&#39;%&#39; IDENTIFIED BY &#39;sonar&#39;;GRANT all privileges ON sonar.* TO &#39;sonar&#39;@&#39;%&#39; IDENTIFIED BY &#39;sonar&#39;;flush privileges; cd /opt/sonarqube-7.3/conf/ vi sonar.properties #数据库用户sonar.jdbc.username&#x3D;root#数据库密码sonar.jdbc.password&#x3D;123456sonar.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sonar?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;rewriteBatchedStatements&#x3D;true&amp;useConfigs&#x3D;maxPerformancesonar.web.host&#x3D;0.0.0.0sonar.web.port&#x3D;9000 ##启动su sonar&#x2F;opt&#x2F;sonarqube-7.3&#x2F;bin&#x2F;linux-x86-64&#x2F;sonar.sh start 登录 访问地址http://172.27.82.119:9000/用户名和密码都是admin 然后紧接着官方引导教程 输入name做为tokennmatosiki生成token：6a831d80491fe2e2d43c5d19270741c2b619ac05把token复制保存下来 选择项目得开发语言 java&gt;maven 执行测试mvn sonar:sonar \\ -Dsonar.host.url&#x3D;http:&#x2F;&#x2F;172.27.82.119:9000 \\ -Dsonar.login&#x3D;d81cb0f66e3ec4dd87adb782c6bdc67f0f7fe96c 安装插件安装汉化包Administrator中MarketPlace搜索chineseCheckstyle 重启生效 maven 配置sonar使用配置settings.xml文件&lt;settings&gt; &lt;pluginGroups&gt; &lt;pluginGroup&gt;org.sonarsource.scanner.maven&lt;&#x2F;pluginGroup&gt; &lt;&#x2F;pluginGroups&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;sonar&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;!-- Optional URL to server. Default value is http:&#x2F;&#x2F;localhost:9000 --&gt; &lt;sonar.host.url&gt; http:&#x2F;&#x2F;myserver:9000 &lt;&#x2F;sonar.host.url&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; &lt;&#x2F;profiles&gt;&lt;&#x2F;settings&gt; jenkins 插件使用sonar jenkins安装插件系统管理—&gt;插件管理,搜索一下sonar安装 配置sonar 系统管理—&gt;系统设置，配置name和server url 粘贴保存下的token 配置全局工具下载地址 wget http:&#x2F;&#x2F;tar.matosiki.site&#x2F;zip&#x2F;sonar-scanner-2.8.zipunzip sonar-scanner-2.8.zipmv sonar-scanner-2.8 &#x2F;opt&#x2F;vi &#x2F;opt&#x2F;sonar-scanner-2.8&#x2F;conf&#x2F;sonar-scanner.properties# 编辑配置文件sonar.host.url&#x3D;http:&#x2F;&#x2F;localhost:9000sonar.sourceEncoding&#x3D;UTF-8sonar.jdbc.username&#x3D;sonarsonar.jdbc.password&#x3D;sonarsonar.jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;172.27.82.11:3306&#x2F;sonar?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8# 添加环境变量vi &#x2F;etc&#x2F;profileexport SCANNER_HOME&#x3D;&#x2F;opt&#x2F;sonar-scanner-2.8export PATH&#x3D;$PATH:$SCANNER_HOME&#x2F;bin# 测试是否设置成功source &#x2F;etc&#x2F;profilesonar-scanner -h jekins中配置：global tool configuration &gt; SonarQube Scanner&gt;add&gt; SONAR_RUNNER_HOME&#x3D;&#x2F;opt&#x2F;sonar-scanner-2.8 选择项目 项目构建&gt;配置&gt;构建&gt; Add build step&gt;Execute SonarQube Scannerexecute shellexport MAVEN_HOME&#x3D;&#x2F;opt&#x2F;apache-maven3.5export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bincd $&#123;WORKSPACE&#125;mvn install ###千万不要在Task to run中输入值sonar.projectKey&#x3D;spring-boot-examplesonar.projectName&#x3D;spring-boot-examplesonar.projectVersion&#x3D;1.0sonar.language&#x3D;javasonar.sources&#x3D;$&#123;WORKSPACE&#125;sonar.java.binaries&#x3D;$&#123;WORKSPACE&#125; 在项目中配置 project properties 文件编辑sonar-project.propertiessonar.projectKey&#x3D;org.sonarqube:spring-boot-example#在SonarQube中展示的项目名称sonar.projectName&#x3D;项目名称#在SonarQube中展示的版本号sonar.projectVersion&#x3D;1.0 #设置源代码的路径sonar.sources&#x3D;&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;spring-boot-example&#x2F;spring-boot-email&#x2F;src&#x2F;#设置字节码文件的路径sonar.binaries&#x3D;&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;spring-boot-example&#x2F;spring-boot-email&#x2F;target&#x2F;classessonar.language&#x3D;javasonar.sourceEncoding&#x3D;UTF-8 #设置字报告存放的路径sonar.jacoco.itReportPath&#x3D;&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;workspace&#x2F;spring-boot-example&#x2F;spring-boot-email&#x2F;reports&#x2F;jacoco.exec maven检查代码命令mvn clean verify sonar:sonar或者mvn clean install org.sonarsource.scanner.maven:sonar-maven-plugin:3.5.0.1254:sonar 报错elasticsearch 错误 解决方案查看es日志 cat /opt/sonarqube-7.1/logs/es.log can not run elasticsearch as root 新建sonar用户 和sonar组 sudo groupadd sonarsudo useradd -g sonar sonarchown -R sonar:sonar &#x2F;opt&#x2F;sonarqube-7.1 failed to obtain node locks查看进程 ps aux | grep ‘elastic’ 获取pid kill -9 90123 删除elasticsearch data文件 Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED. 在mysql里设置binlog_format为ROW，此时binlog会增大，但是一般来说对数据复制支持的更好，建议单机高性能环境下使用。 删除初始化得database*sonarvi &#x2F;etc&#x2F;my.confbinlog_format&#x3D;ROW 参考1参考2","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用单机mongodb","slug":"blog/linux/centos安装使用单机mongodb","date":"2020-04-18T07:01:23.081Z","updated":"2020-04-18T07:01:23.081Z","comments":true,"path":"blog/linux/centos安装使用单机mongodb/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E5%8D%95%E6%9C%BAmongodb/","excerpt":"","text":"centos安装使用单机mongodb下载适合的安装包 curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-4.0.2.tgz 或者手动去官网下载Version: RHEL 6 Linux 64-bit x64 版本的tar包 解压tar包 tar -zxvf mongodb-linux-x86_64-rhel62-4.0.2.tgz mv mongodb-linux-x86_64-rhel62-4.0.2/ /usr/local/mongodb 进入mongdb安装目录 cd /usr/local/mongodb 新建数据文件存储目录 （默认mongdb会在根目录下建data文件） mkdir -p data/dbmkdir -p data/backupmkdir -p data/logstouch data/logs/mongodb.log 设置环境变量 pwd=$(pwd) export PATH=$pwd/bin:$PATH vi /etc/profile export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin:$PATH source /etc/profile 启动mongod程序 ./bin/mongod –dbpath=data/db –bind_ip 127.0.0.1 –port 27017 –logpath data/logs/mongodb.log –logappend &amp; 或者 cd bin/ ./mongod –dbpath=/usr/local/mongodb/data/db –bind_ip 127.0.0.1 –port 27017 –logpath /usr/local/mongodb/data/logs/mongodb.log –logappend –fork 关闭数据 mongod –shutdown –dbpath=/usr/local/mongodb/data/db –bind_ip 127.0.0.1 –port 27017 –logpath /usr/local/mongodb/data/logs/mongodb.log –logappend –fork 或者使用kill命令 kill -2 PID 原理：-2表示向mongod进程发送SIGINT信号。或 kill -4 PID 原理：-4表示向mognod进程发送SIGTERM信号。 使用mongo shell连接数据库 ./mongo –host 127.0.0.1 或者指定用户连接 mongo 10.0.0.152/admin 关闭数据库 use admin ;db.shutdownServer() 新建用户 use admin 新建管理员用户 db.createUser({ user: ‘root’, pwd: ‘123456’, roles: [ { role: “userAdminAnyDatabase”, db: “admin” } ] }); use test; db.createUser({user:”testuser”,pwd:”testpass”,roles:[“readWrite”]}); db.auth(“testuser”,”testpass”) mongodb web界面启动方式 ./mongod –dbpath=/data/db –rest 使用配置文件方式管理数据库 cd /usr/local/mongodb/ mkdir -p conf vi conf/mongod.conf 推荐使用systemLog: destination: file path: &quot;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;logs&#x2F;mongodb.log&quot; logAppend: truestorage: journal: enabled: true dbPath: &quot;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;db&quot;processManagement: fork: true pidFilePath: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongod.pid timeZoneInfo: &#x2F;usr&#x2F;share&#x2F;zoneinfonet: port: 27017 bindIp: 0.0.0.0 或者 dbpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;dblogpath&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data&#x2F;logs&#x2F;mongodb.logport&#x3D;27017logappend&#x3D;1fork&#x3D;1 启动mongdb mongod -f mongod.conf 关闭 mongod -f mongod.conf –shutdown 配置mongdb服务 先添加用户 groupadd -g 800 mongod useradd -u 801 -g mongod mongod 设置密码 echo 123456 |passwd –stdin mongod 设置主目录权限 chown -R mongod:mongod /usr/local/mongodb cd /etc/init.d/ touch mongod chmod 777 mongod vi mongod #!/bin/bash#chkconfig: 2345 80 90#description: mongodb#by maotiski#site:http:matosiki.siteMONGODIR=/usr/local/mongodbMONGOD=$MONGODIR/bin/mongodMONGOCONF=$MONGODIR/conf/mongod.confInfoFile=/tmp/start.mongo. /etc/init.d/functions status()&#123; PID=`awk 'NR==2&#123;print $NF&#125;' $InfoFile` Run_Num=`ps -p $PID|wc -l` if [ $Run_Num -eq 2 ]; then echo \"MongoDB is running\" else echo \"MongoDB is shutdown\" return 3 fi&#125;start() &#123; status &amp;&gt;/dev/null if [ $? -ne 3 ];then action \"start mongdb,service running...\" /bin/false exit 2 fi sudo su - mongod -c \"$MONGOD -f $MONGOCONF\" &gt;$InfoFile 2&gt;/dev/null if [ $? -eq 0 ];then action \"start mongdb\" /bin/true else action \"start mongdb\" /bin/false fi&#125;stop() &#123; sudo su - mongod -c \"$MONGOD -f $MONGOCONF --shutdown\" &amp;&gt;/dev/null if [ $? -eq 0 ];then action \"stop mongdb\" /bin/true else action \"stop mongdb\" /bin/false fi &#125;case \"$1\" in start) start ;; stop) stop ;; restart) stop sleep 2 start ;; status) status ;; *)echo $\"Usage: $0 &#123;start|stop|restart|status&#125;\" exit 1esac chkconfig –add mongod chkconfig mongod on service mongod start 错误案例./etc/init.d/functions: Permission denied 注意这行代码 . /etc/init.d/functions 点与斜杠有个空格 或者是权限不够更改权限 chmod a+x /etc/init.d/functions","categories":[],"tags":[]},{"title":"blog/linux/centos安装单机activemq","slug":"blog/linux/centos安装单机activemq","date":"2020-04-18T07:01:23.081Z","updated":"2020-04-18T07:01:23.081Z","comments":true,"path":"blog/linux/centos安装单机activemq/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BAactivemq/","excerpt":"","text":"centos安装单机activemq官网下载http://archive.apache.org/dist/activemq/5.15.6/apache-activemq-5.15.6-bin.tar.gz 解压安装curl -O http:&#x2F;&#x2F;tar.matosiki.site&#x2F;tar&#x2F;apache-activemq-5.15.6-bin.tar.gztar -vxzf apache-activemq-5.15.6-bin.tar.gzmv apache-activemq-5.15.6 &#x2F;opt&#x2F;cd &#x2F;opt&#x2F;apache-activemq-5.15.6# 启动.&#x2F;bin&#x2F;activemq start# 默认端口 activemq服务监控端口 61616 web管理页面端口 8161# 测试 用户名admin 密码admincurl http:&#x2F;&#x2F;localhost:8161 配置添加账号 vim &#x2F;opt&#x2F;apache-activemq-5.15.6&#x2F;conf&#x2F;activemq.xml &lt;simpleAuthenticationPlugin&gt; &lt;users&gt; &lt;authenticationUser username&#x3D;&quot;system&quot; password&#x3D;&quot;manager&quot; groups&#x3D;&quot;users,admins&quot;&#x2F;&gt; &lt;&#x2F;users&gt;&lt;&#x2F;simpleAuthenticationPlugin&gt;","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用postgress","slug":"blog/linux/centos安装使用postgress","date":"2020-04-18T07:01:23.080Z","updated":"2020-04-18T07:01:23.081Z","comments":true,"path":"blog/linux/centos安装使用postgress/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8postgress/","excerpt":"","text":"centos安装使用postgress# 官网下载wget https://ftp.postgresql.org/pub/source/v10.1/postgresql-10.1.tar.gz# 自己的镜像下载wget http://tar.matosiki.site/tar/postgresql-10.1.tar.gz# 安装c语言环境yum -y install gccyum -y install gcc-c++yum -y install readline-devel zlib zlib-devel uuid uuid-devel readline-devel 编译mkdir -p /usr/local/pgsqltar -zxvf postgresql-10.1.tar.gz -C /usr/local/pgsqlcd /usr/local/pgsql/mv postgresql-10.1/* /usr/local/pgsql/./configure LDFLAGS=-L/usr/local/lib CPPFLAGS=-I/usr/local/include --prefix=/usr/local/postgres --with-ossp-uuidmakemake install 添加用户adduser postgres# 设置密码为postgrespasswd postgresmkdir -p /data/postgreschown -R postgres /data/postgreschmod -R 700 /data/postgres 安装插件cd /usr/local/pgsql/contrib/adminpackmakemake installcd /usr/local/pgsql/contrib/uuid-osspmake make install# 为`libuuid.so.16`建立链接ln -s /usr/local/lib/libuuid.so.16 /usr/lib64 完成后检查一下权限，如果出现无法找到该库文件的错误，就是由于该文件的权限引起 初始化数据库su postgrescd /usr/local/postgres/bin./initdb -D /data/postgres 配置数据库vim /data/postgres/postgresql.conf# 更改内容listen_addresses = '*'vim /data/postgres/pg_hba.conf# 最下边添加一行host all all 0.0.0.0/0 md5 启动服务/usr/local/postgres/bin/postgres -D /data/postgres 此时shell被独占，需要重新开启一个shell并切换到postgres账号进行后续操作进入postgres库cd /usr/local/postgres/binsu postgres./psql postgres\\password postgres# 输入新密码# 创建uuid扩展create extension \"uuid-ossp\";# 退出终端\\q 使用root权限 开启5432端口firewall-cmd --add-port=5432/tcp --permanentfirewall-cmd --reload 设置服务自启动创建文件vim /usr/lib/systemd/system/postgres.service 内容[Unit]Description=PostgreSQL database serverAfter=network.target[Service]Type=forkingUser=postgresGroup=postgresPIDFile=/data/postgres/postmaster.pidOOMScoreAdjust=-1000Environment=PGSTARTTIMEOUT=270Environment=PGDATA=/data/postgresExecStart=/usr/local/postgres/bin/pg_ctl start -D $&#123;PGDATA&#125; -s -w -t $&#123;PGSTARTTIMEOUT&#125;ExecStop=/usr/local/postgres/bin/pg_ctl stop -D $&#123;PGDATA&#125; -s -m fastExecReload=/usr/local/postgres/bin/pg_ctl reload -D $&#123;PGDATA&#125; -sTimeoutSec=300[Install]WantedBy=multi-user.target 安装 PostGIs 扩展安装其它依赖yum install -y libxml2 libxml2-devel json-c json-c-devel sqlite-devel 编译安装 proj下载地址：http://download.osgeo.org/proj/官网5.2.0下载地址 https://download.osgeo.org/proj/proj-5.2.0.tar.gz cd ~wget http://tar.matosiki.site/tar/proj-5.2.0.tar.gztar -zxvf proj-5.2.0.tar.gzcd proj-5.2.0./configure --prefix=/usr/local/projmake &amp;&amp; make install 编译安装geos下载地址：http://trac.osgeo.org/geos/官方3.7.1地址 http://download.osgeo.org/geos/geos-3.7.1.tar.bz2wget http://tar.matosiki.site/tar/geos-3.7.1.tar.bz2bzip2 -d geos-3.7.1.tar.bz2tar vxf geos-3.7.1.tarcd geos-3.7.1./configure --prefix=/usr/local/geosmake &amp;&amp; make install 编译安装gdal下载地址：http://download.osgeo.org/gdal/官网2.4下载地 http://download.osgeo.org/gdal/2.4.0/gdal-2.4.0.tar.gztar -zxvf gdal-2.4.0.tar.gzwget http://tar.matosiki.site/tar/gdal-2.4.0.tar.gzcd gdal-2.4.0./configure --prefix=/usr/local/gdalmake &amp;&amp; make install 编译postgishttps://download.osgeo.org/postgis/source/postgis-2.5.1.tar.gzwget http://tar.matosiki.site/tar/postgis-2.5.1.tar.gztar -zxvf postgis-2.5.1.tar.gzcd postgis-2.5.1./configure --with-pgconfig=/usr/local/postgres/bin/pg_config --with-geosconfig=/usr/local/geos/bin/geos-config --with-projdir=/usr/local/proj --with-gdalconfig=/usr/local/gdal/bin/gdal-config --with-jsondir=/usr/include/json-cmake &amp; make install 到postgresql源码目录的contrib/fuzzystrmatch下直接make &amp; make install安装该插件 重启数据库，执行以下查询验证插件是否安装成功 /usr/local/pgsql/contrib/fuzzystrmatch./configure --with-pgconfig=/usr/local/postgres/bin/pg_config --with-geosconfig=/usr/local/geos/bin/geos-config --with-projdir=/usr/local/proj --with-gdalconfig=/usr/local/gdal/bin/gdal-config --with-jsondir=/usr/include/json-cmake &amp; make install select \\* from pg_available_extensions where name like 'postgis%'; 在navicat的查询分析器里执行 CREATE EXTENSION fuzzystrmatch; 解决依赖问题 vim /etc/ld.so.conf.d/postgis.conf 写入以下内容 &#x2F;usr&#x2F;local&#x2F;gdal&#x2F;lib&#x2F;&#x2F;usr&#x2F;local&#x2F;proj&#x2F;lib&#x2F;&#x2F;usr&#x2F;local&#x2F;geos&#x2F;lib&#x2F; 执行ldconfig命令使配置生效 ldconfigsu postgrescd /usr/local/postgres/bin 创建一个用于演示的空间模板数据库 ./createdb template_postgis 对postgis库赋予空间扩展 ./psql -f /usr/local/postgres/share/contrib/postgis-2.5/postgis.sql -d template_postgis./psql -f /usr/local/postgres/share/contrib/postgis-2.5/spatial_ref_sys.sql -d template_postgis 该库不要做任何改动，仅做为库的模板使用，以后要新建有 PostGIS 功能的库就以此为模板即可 库中的spatial_ref_sys表也不要改动或删除 安装PostGIS的座标转换扩展，支持以下座标类型转换 BD2GCJ：百度坐标转火星坐标 GCJ2BD：火星坐标转百度坐标 WGS2GCJ：84（gps）坐标转火星，常用把自己的数据加偏移叠加到高德，谷歌，esri 底图上可用 GCJ2WGS：火星转 84 BD2WGS：百度转 84 WGS2BD：84 转百度 扩展下载地址：https://github.com/FreeGIS/postgis_LayerTransform 将库中的sql文件里的sql语句在template_postgis上执行一次即可。","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用nginx","slug":"blog/linux/centos安装使用nginx","date":"2020-04-18T07:01:23.080Z","updated":"2020-04-18T07:01:23.080Z","comments":true,"path":"blog/linux/centos安装使用nginx/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8nginx/","excerpt":"","text":"centos安装使用nginx预置环境 yum install -y gcc gcc-c++ yum -y install pcre-devel openssl openssl-devel 下载 wget http://tar.matosiki.site/tar/nginx-1.15.0.tar.gz tar -vxzf nginx-1.15.0.tar.gz cd nginx-1.15.0./configure# 如果有fastfds模块 或者 可以使用 ./configure --add-module=/usr/local/fastdfs-nginx-module/srcmake &amp; make install 编辑配置文件 vi /usr/local/nginx/conf/nginx.conf 更改端口 server &#123; listen 8899; server_name localhost; location &#x2F; &#123; root html; index index.html index.htm; &#125;&#125; 静态文件转发# 映射到本地路径 &#x2F;home&#x2F;iki&#x2F;downloadlocation &#x2F;download&#x2F; &#123; root &#x2F;home&#x2F;iki; autoindex on;&#125;# 映射到其他服务器地址location &#x2F;proxy&#x2F; &#123; proxy_pass http:&#x2F;&#x2F;172.27.82.119:9000;&#125; 反向代理 # 配置一个serverserver &#123; listen 8800; server_name matosiki.site; location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;matosiki.site ; &#125; &#125; 负载均衡upstream matosiki.site; &#123; ip_hash; server 172.27.82.119:8080; server 172.27.82.119:8082; server 172.27.82.121; server 172.27.82.112;&#125;location &#x2F; &#123; proxy_pass http:&#x2F;&#x2F;matosiki.site;&#125; 启动# 调试配置文件是否成功&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -t# 启动&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx# 重启&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload# 停止&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop# 强制关闭pkill nginx# 查看nginx 启动用户ps aux | grep &quot;nginx: worker process&quot; | awk &#39;&#123;print $1&#125;&#39; 配置开机启动更改下面配置文件# 启动应用路径nginx=\"/usr/local/nginx/sbin/nginx\"# 文件配置NGINX_CONF_FILE=\"/usr/local/nginx/conf/nginx.conf\" vi /etc/init.d/nginx#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \\# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/local/nginx/sbin/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/usr/local/nginx/conf/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep \"configure arguments:.*--user=\" | sed 's/[^*]*--user=\\([^ ]*\\).*/\\1/g' -` if [ -n \"$user\" ]; then if [ -z \"`grep $user /etc/passwd`\" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d \"=\" -f 2` if [ ! -d \"$value\" ]; then # echo \"creating\" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esac 更改文件权限 chmod a+x /etc/init.d/nginx &#x2F;etc&#x2F;init.d&#x2F;nginx start&#x2F;etc&#x2F;init.d&#x2F;nginx stop # 添加到开机自启中chkconfig --add &#x2F;etc&#x2F;init.d&#x2F;nginx# 启动开机自启chkconfig nginx on 启动服务service nginx startservice nginx stopservice nginx restart","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用jenkins","slug":"blog/linux/centos安装使用jenkins","date":"2020-04-18T07:01:23.078Z","updated":"2020-04-18T07:01:23.078Z","comments":true,"path":"blog/linux/centos安装使用jenkins/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8jenkins/","excerpt":"","text":"centos安装使用jenkins环境jdk1.8 安装mvn 4.5.x 安装 下载jenkins 快速安装方式 wget https://pkg.jenkins.io/redhat-stable/jenkins-2.150.3-1.1.noarch.rpm rpm -ivh jenkins-2.150.3-1.1.noarch.rpm 或者使用yum安装 yum install -y jenkins 设置jenkins端口 vi /etc/sysconfig/jenkins 更改JENKINS_PORT&#x3D;&quot;7788&quot;JENKINS_AJP_PORT&#x3D;&quot;7007&quot;自动安装完成之后： &#x2F;usr&#x2F;lib&#x2F;jenkins&#x2F;jenkins.war # WAR包 &#x2F;etc&#x2F;sysconfig&#x2F;jenkins # 配置文件&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F; # 默认的JENKINS_HOME目录&#x2F;var&#x2F;log&#x2F;jenkins&#x2F;jenkins.log # Jenkins日志文件 启动jenkins systemctl start jenkins 可能出现错误 Job for jenkins.service failed because the control process exited with error code. See &quot;systemctl status jenkins.service&quot; and &quot;journalctl -xe&quot; for details. vi /etc/init.d/jenkins 更改jdk的java路径 &#x2F;etc&#x2F;alternatives&#x2F;java&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0&#x2F;bin&#x2F;java&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jre-1.8.0&#x2F;bin&#x2F;java&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.7.0&#x2F;bin&#x2F;java&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jre-1.7.0&#x2F;bin&#x2F;java&#x2F;usr&#x2F;bin&#x2F;java&#x2F;usr&#x2F;local&#x2F;jdk1.8&#x2F;bin&#x2F;java # 注意添加java的执行路径 再次启动 systemctl start jenkins 连接测试 curl 127.0.0.1:7788 查看密码 cat /var/lib/jenkins/secrets/initialAdminPassword 查看私钥 放入jenkins中 cat .ssh/id_rsa 查看公钥 放入第三方git上 cat .ssh/id_rsa.pub 生成私钥 ssh-keygen -t rsa jenkins忘记密码两种解决方案默认Jenkins的配置目录是/root/.jenkins/ 一、admin 密码更改情况 进入\\Jenkins\\secrets目录，打开initialAdminPassword文件，复制密码； 访问Jenkins页面，输入管理员admin，及刚才的密码； 进入后可更改其他管理员密码； 二、忘记密码，重置密码 删除Jenkins目录下config.xml文件中下面代码，并保存文件。 &lt;useSecurity&gt;true&lt;/useSecurity&gt;&lt;authorizationStrategy class=\"hudson.security.FullControlOnceLoggedInAuthorizationStrategy\"&gt; &lt;denyAnonymousReadAccess&gt;true&lt;/denyAnonymousReadAccess&gt;&lt;/authorizationStrategy&gt;&lt;securityRealm class=\"hudson.security.HudsonPrivateSecurityRealm\"&gt; &lt;disableSignup&gt;true&lt;/disableSignup&gt; &lt;enableCaptcha&gt;false&lt;/enableCaptcha&gt;&lt;/securityRealm&gt; 重启Jenkins服务； 进入首页&gt;“系统管理”&gt;“Configure Global Security”； 勾选“启用安全”； 点选“Jenkins专有用户数据库”，并点击“保存”； 重新点击首页&gt;“系统管理”,发现此时出现“管理用户”； 点击进入展示“用户列表”； 点击右侧进入修改密码页面，修改后即可重新登录","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用mysql mini版","slug":"blog/linux/centos安装使用mysql mini版","date":"2020-04-18T07:01:23.078Z","updated":"2020-04-18T07:01:23.078Z","comments":true,"path":"blog/linux/centos安装使用mysql mini版/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8mysql%20mini%E7%89%88/","excerpt":"","text":"centos安装使用mysql mini版wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm sudo rpm -ivh mysql-community-release-el7-5.noarch.rpmsudo yum install mysql-serversudo chown -R root:root /var/lib/mysqlservice mysqld restartmysqladmin -u root password '123456'# mysqlgrant all privileges on *.* to root@\"%\" identified by \"123456\";","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用maven","slug":"blog/linux/centos安装使用maven","date":"2020-04-18T07:01:23.078Z","updated":"2020-04-18T07:01:23.078Z","comments":true,"path":"blog/linux/centos安装使用maven/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8maven/","excerpt":"","text":"centos安装使用maven下载maven安装包 使用官网下载然后上传到服务器 直接使用命令行下载地址 wget http://tar.matosiki.site/tart/apache-maven-3.5.4-bin.tar.gz 解压到固定目录 tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /opt/ mv /opt/apache-maven-3.5.4 /opt/apache-maven3.5 配置环境变量 vi /etc/profile export MAVEN_HOME&#x3D;&#x2F;opt&#x2F;apache-maven3.5export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin 环境变量生效 source /etc/profile 测试 mvn -version 配置maven本地仓库地址更改setting文件设置本地仓库位置 vim /opt/apache-maven3.5/conf/settings.xml &lt;localRepository&gt;&#x2F;var&#x2F;mvn&#x2F;repo&lt;&#x2F;localRepository&gt; 还可以其他设置私服仓库地址 mkdir -p /var/mvn/repo 新建pom.xml进行下载测试 cd /opt/apache-maven3.5 vi pom.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.matosiki&lt;/groupId&gt; &lt;artifactId&gt;test-mvn&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;test-mvn&lt;/name&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; mvn install 结束！安装脚本cat &lt;&lt;EOF &gt;install_mvn.shwget http:&#x2F;&#x2F;tar.matosiki.site&#x2F;tart&#x2F;apache-maven-3.5.4-bin.tar.gztar -zxvf apache-maven-3.5.4-bin.tar.gz -C &#x2F;opt&#x2F;mv &#x2F;opt&#x2F;apache-maven-3.5.4 &#x2F;opt&#x2F;apache-maven3.5echo &quot;export MAVEN_HOME&#x3D;&#x2F;opt&#x2F;apache-maven3.5&quot; &gt;&gt;&#x2F;etc&#x2F;profileecho &quot;export PATH&#x3D;\\$PATH:\\$MAVEN_HOME&#x2F;bin&quot; &gt;&gt;&#x2F;etc&#x2F;profilesource &#x2F;etc&#x2F;profilemkdir -p &#x2F;var&#x2F;repo&#x2F;mvnmvn -versionecho &quot;需要手动添加本地仓库地址为 &lt;localRepository&gt;&#x2F;var&#x2F;mvn&#x2F;repo&lt;&#x2F;localRepository&gt;&quot; EOF","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用mysql","slug":"blog/linux/centos安装使用mysql","date":"2020-04-18T07:01:23.078Z","updated":"2020-04-24T05:04:21.396Z","comments":true,"path":"blog/linux/centos安装使用mysql/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8mysql/","excerpt":"","text":"centos安装使用mysql下载mysql5.7.x 官网下载地址 安装依赖 yum -y install numactlyum install -y libaio wget http://tar.matosiki.site/tar/mysql-5.7.27-linux-glibc2.12-x86_64.tar.gz 解压到指定目录 tar -zxvf mysql-5.7.27-linux-glibc2.12-x86_64.tar.gz -C /usr/local mv /usr/local/mysql-5.7.27-linux-glibc2.12-x86_64 /usr/local/mysql 添加用户组并添加用户sudo groupadd mysqlsudo useradd -g mysql mysql 配置mysql启动# 新建mysql的data文件夹mkdir -p /usr/local/mysql/data# 给mysql 文件夹赋权限chown -R mysql:mysql /usr/local/mysql 添加配置文件相关信息cat &lt;&lt; EOF &gt; /etc/my.cnf[client]port=3306socket=/usr/local/mysql/mysql.sockdefault-character-set=utf8[mysqld]skip-name-resolveuser=mysqlbasedir=/usr/local/mysql/datadir=/usr/local/mysql/dataport=3306server-id=10socket=/usr/local/mysql/mysql.socklog-bin=/usr/local/mysql/data/mysql-bincharacter-set-server=utf8#skip-grant-tables[mysqld_safe]pid-file=/usr/local/mysql/mysql.pidlog-error=/usr/local/mysql/data/mysql.errEOF 注意配置中的server-id不是server_id 通过mysql命令行设置使用set global server_id=10;这是用的是下划线,一个巨大的坑. # 复制开机配置cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld# 更改启动文件权限chmod 755 /etc/init.d/mysqld 在myslqd启动文件中找到配置并更改(这一步可以不用配置,mysql默认地址跟一下配置一样)basedir=/usr/local/mysqldatadir=/usr/local/mysql/data 初始化数据库 (这里最容易出错 注意这个命令的反斜杠换行)# 5.6版本执行 5.7已废弃/usr/local/mysql/bin/mysql_install_db \\--defaults-file=/etc/my.cnf \\--user=mysql \\--basedir=/usr/local/mysql \\--datadir=/usr/local/mysql/data &amp;# 使用最新安装脚本# 生成自定义密码/usr/local/mysql/bin/mysqld --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data --initialize# 不生成自定义密码/usr/local/mysql/bin/mysqld --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data --initialize-insecure 你会看到没有报错就成功了 启动mysql service mysqld start 配置环境变量echo 'export PATH=/usr/local/mysql/bin:$PATH' &gt;&gt; /etc/profilesource /etc/profile 登录测试注意试着先用mysqladmin 设置密码在登陆 cd /usr/local/mysql/bin 默认注释skip-grant-tables配置需要初始化登录密码 ./mysqladmin -u root password ‘123456’ 或者一行命令(参数-p后面是生成的密码) ./mysqladmin -uroot -pxxxx password 123456 试着用初始化的密码登录 ./mysql -uroot -p123456 mysqladmin更改密码命令格式：mysqladmin -u 用户名 -p 旧密码 password 新密码 添加自启动chkconfig --add mysqldchkconfig mysqld onchkconfig --list mysqld 开启用户外网访问打开防火墙添加特定端口 firewall-cmd –zone=public –add-port=3306/tcp –permanent 查看端口是否添加成功 firewall-cmd –zone=public –query-port=3306/tcp 重新载入规则 firewall-cmd –reload 设置该用户可以外网访问进入mysql ./mysql -uroot -p123456 use mysql 查看mysql用户 select user,password,host from user; 赋予外网访问权限 grant all privileges on . to 用户名@”Ip地址” identified by “密码”;grant all privileges on *.* to root@&quot;%&quot; identified by &quot;123456&quot;; 刷新一下 flush privileges; 连接测试 错误解决 /vmware-install.pl: /user/bin/perl: 坏的解释器:没有那个文件或目录 解决: yum install perl gcc kernel-devel please install the following Perl modules before executing /usr/local/mysql/scripts/mysql_install_db 解决yum -y install autoconf","categories":[],"tags":[]},{"title":"blog/linux/centos安装nexus搭建mvn私服与配置","slug":"blog/linux/centos安装nexus搭建mvn私服与配置","date":"2020-04-18T07:01:23.077Z","updated":"2020-04-18T07:01:23.077Z","comments":true,"path":"blog/linux/centos安装nexus搭建mvn私服与配置/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85nexus%E6%90%AD%E5%BB%BAmvn%E7%A7%81%E6%9C%8D%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"centos安装nexus搭建mvn私服与配置官网下载 wget http://tar.matosiki.site/tar/nexus-3.13.0-01.tar.gztar -vxzf nexus-3.13.0-01.tar.gzmv nexus-3.13.0-01 /opt/mv nexus-3.13.0-01 nexus# 运行前更改端口和启动路径vim /opt/nexus/etc/nexus-default.propertiesapplication-port=5566application-host=0.0.0.0nexus-context-path=/nexus# 运行 首次启动用run命令 之后使用start./opt/nexus/bin/nexus run# 测试 默认用户名admin 密码admin123curl localhost:5566 启动生成后默认会在opt目录下生成sonatype-work文件夹，进入文件夹配置nexus # 运行后再更改配置方式 默认端口8081# 简单配置nexus 更改端口cd &#x2F;opt&#x2F;sonatype-work&#x2F;nexus3&#x2F;etc&#x2F;vim nexus.propertiesapplication-port&#x3D;5566application-host&#x3D;0.0.0.0nexus-context-path&#x3D;&#x2F;nexus 将nexus作为服务 vi /etc/profileexport NEXUS_HOME=\"/opt/nexus\"source /etc/profile# 添加nexus用户groupadd nexususeradd -g nexus nexuschown -R nexus:nexusvi /opt/nexus/bin/nexus.rc run_as_user=\"nexus\"# 建立软连接sudo ln -s $NEXUS_HOME/bin/nexus /etc/init.d/nexuscd /etc/init.dsudo chkconfig --add nexussudo chkconfig --levels 345 nexus onsudo service nexus startcd /etc/init.dsudo update-rc.d nexus defaultssudo service nexus startsudo systemctl daemon-reloadsudo systemctl enable nexus.servicesudo systemctl start nexus.service 如果不能启动试试删除 rm -rf tmp&#x2F;rm -rf cache&#x2F; 查看日志 tail -f &#x2F;opt&#x2F;sonatype-work&#x2F;nexus3&#x2F;log&#x2F;nexus.log setting.xml 文件配置 &lt;settings&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;!--This sends everything else to &#x2F;public --&gt; &lt;id&gt;nexus&lt;&#x2F;id&gt; &lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt; &lt;url&gt;http:&#x2F;&#x2F;localhost:8081&#x2F;repository&#x2F;maven-public&#x2F;&lt;&#x2F;url&gt; &lt;&#x2F;mirror&gt; &lt;&#x2F;mirrors&gt; &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;nexus&lt;&#x2F;id&gt; &lt;!--Enable snapshots for the built in central repo to direct --&gt; &lt;!--all requests to nexus via the mirror --&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;&#x2F;id&gt; &lt;url&gt;http:&#x2F;&#x2F;central&lt;&#x2F;url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt; &lt;&#x2F;repository&gt; &lt;&#x2F;repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;central&lt;&#x2F;id&gt; &lt;url&gt;http:&#x2F;&#x2F;central&lt;&#x2F;url&gt; &lt;releases&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;releases&gt; &lt;snapshots&gt;&lt;enabled&gt;true&lt;&#x2F;enabled&gt;&lt;&#x2F;snapshots&gt; &lt;&#x2F;pluginRepository&gt; &lt;&#x2F;pluginRepositories&gt; &lt;&#x2F;profile&gt; &lt;&#x2F;profiles&gt; &lt;activeProfiles&gt; &lt;!--make the profile active all the time --&gt; &lt;activeProfile&gt;nexus&lt;&#x2F;activeProfile&gt; &lt;&#x2F;activeProfiles&gt;&lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus&lt;&#x2F;id&gt; &lt;username&gt;admin&lt;&#x2F;username&gt; &lt;password&gt;admin123&lt;&#x2F;password&gt; &lt;&#x2F;server&gt; &lt;&#x2F;servers&gt;&lt;&#x2F;settings&gt; pom.xml配置 以便发布jar到仓库 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;&#x2F;id&gt; &lt;name&gt;Releases&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;&#123;your-nexus-ip&#125;&#x2F;repository&#x2F;maven-releases&lt;&#x2F;url&gt; &lt;&#x2F;repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;nexus&lt;&#x2F;id&gt; &lt;name&gt;Snapshot&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;&#123;your-nexus-ip&#125;&#x2F;repository&#x2F;maven-snapshots&lt;&#x2F;url&gt; &lt;&#x2F;snapshotRepository&gt;&lt;&#x2F;distributionManagement&gt; 发布命令 mvn clean deploy 上传第三方jar包到nexus发布不带pom文件的独立jar包：-DrepositoryId的值即为在setttings.xml里面配置的server id。 mvn deploy:deploy-file -DgroupId&#x3D;&lt;group-id&gt; \\ -DartifactId&#x3D;&lt;artifact-id&gt; \\ -Dversion&#x3D;&lt;version&gt; \\ -Dpackaging&#x3D;&lt;type-of-packaging&gt; \\ -Dfile&#x3D;&lt;path-to-file&gt; \\ -DrepositoryId&#x3D;&lt;id-to-map-on-server-section-of-settings.xml&gt; \\ -Durl&#x3D;&lt;url-of-the-repository-to-deploy&gt; 发布带有pom的jar包 mvn deploy:deploy-file -DpomFile&#x3D;&lt;path-to-pom&gt; \\ -Dfile&#x3D;&lt;path-to-file&gt; \\ -DrepositoryId&#x3D;&lt;id-to-map-on-server-section-of-settings.xml&gt; \\ -Durl&#x3D;&lt;url-of-the-repository-to-deploy&gt;","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用docker","slug":"blog/linux/centos安装使用docker","date":"2020-04-18T07:01:23.077Z","updated":"2020-04-18T07:01:23.077Z","comments":true,"path":"blog/linux/centos安装使用docker/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8docker/","excerpt":"","text":"centos安装使用docker卸载老版本sudo yum remove docker \\ docker-common \\ docker-selinux \\ docker-engine 安装仓库 sudo yum install -y yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager \\ --add-repo \\ https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo # 启用edge仓库sudo yum-config-manager --enable docker-ce-edge # 启用test仓库sudo yum-config-manager --enable docker-ce-test 更新yum索引 sudo yum makecache fast 安装docker-ce sudo yum install docker-ce 查看自定版本进行安装yum list docker-ce.x86_64 --showduplicates | sort -r sudo yum install docker-ce- 启动docker sudo systemctl start docker 验证安装是否成功 sudo docker run hello-world 升级docker sudo yum makecache fast shell 一键安装curl -fsSL get.docker.com -o get-docker.sh sudo sh get-docker.sh 常用命令 docker ps 查看当前正在运行的容器docker ps -a 查看所有容器的状态docker start/stop id/name 启动/停止某个容器docker attach id 进入某个容器(使用exit退出后容器也跟着停止运行)docker exec -ti id 启动一个伪终端以交互式的方式进入某个容器（使用exit退出后容器不停止运行）docker images 查看本地镜像docker rm id/name 删除某个容器docker rmi id/name 删除某个镜像docker run --name test -ti ubuntu /bin/bash 复制ubuntu容器并且重命名为test且运行，然后以伪终端交互式方式进入容器，运行bashdocker build -t soar/centos:7.1 . 通过当前目录下的Dockerfile创建一个名为soar/centos:7.1的镜像docker run -d -p 2222:22 --name test soar/centos:7.1 以镜像soar/centos:7.1创建名为test的容器，并以后台模式运行，并做端口映射到宿主机2222端口，P参数重启容器宿主机端口会发生改变","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用fasdfs","slug":"blog/linux/centos安装使用fasdfs","date":"2020-04-18T07:01:23.077Z","updated":"2020-04-18T07:01:23.077Z","comments":true,"path":"blog/linux/centos安装使用fasdfs/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8fasdfs/","excerpt":"","text":"centos安装使用fasdfs 简要准备两台服务器： Tracker Server：跟踪服务器，主要做调度工作 Storage Server：存储服务器，主要提供容量和备份服务 FASDFS采用是卷存储策略，只要能扩展卷，你的存量就可以够大。 FASDFS 上传下载原理：客户端上传将文件发送给TRACKER SERVER ，Tracker 查询可用存储并读取文件信息（文件大小，文件元数据），Tracker 将文件发送给Starage Server 存储，存储文件返回文件ID和路径，Tracker 将文件组路径信息地址返回给客户端。 客户端下载 直接使用文件地址信息去请求Tracker服务，Tracker去查找文件返回给客户端 环境 yum install -y gcc gcc-c++ yum -y install libevent 安装 wget http://tar.matosiki.site/tar/libfastcommon-1.0.7.tar.gz tar -zxvf libfastcommon-1.0.7.tar.gz -C&#x2F;usr&#x2F;localcd &#x2F;usr&#x2F;local&#x2F;libfastcommon-1.0.7&#x2F;#编译.&#x2F;make.sh#安装.&#x2F;make.sh installcd &#x2F;usr&#x2F;lib64ls | grep libfastcommon.socp libfastcommon.so &#x2F;usr&#x2F;lib wget http://tar.matosiki.site/tar/fastdfs-5.05.tar.gz cd &#x2F;home&#x2F;iki&#x2F;downloadtar -vxzf fastdfs-5.05.tar.gz -C &#x2F;usr&#x2F;localcd &#x2F;usr&#x2F;local&#x2F;fastdfs-5.05&#x2F;.&#x2F;make.sh &amp;&amp; .&#x2F;make.sh installcp &#x2F;usr&#x2F;local&#x2F;fastdfs-5.05&#x2F;conf&#x2F;* &#x2F;etc&#x2F;fdfs&#x2F; 配置配置 Tracker cp &#x2F;etc&#x2F;fdfs&#x2F;cp tracker.conf.sample tracker.confvi tracker.conf# 设置base_path&#x3D;&#x2F;home&#x2F;iki&#x2F;fastdfs#配置http端口http.server_port&#x3D;6655 mkdir &#x2F;home&#x2F;iki&#x2F;fastdfs#启动&#x2F;usr&#x2F;bin&#x2F;fdfs_trackerd &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf start 查看日志： tail -f /home/iki/fastdfs/log/trackerd.log 配置 storagecd &#x2F;etc&#x2F;fdfs&#x2F;cp storage.conf.sample storage.confvi storage.conf#配置组名group_name&#x3D;group1 base_path&#x3D;&#x2F;home&#x2F;iki&#x2F;fastdfsstore_path0&#x3D;&#x2F;home&#x2F;iki&#x2F;fastdfs_storagetracker_server&#x3D;172.27.82.119:22122http.server_port&#x3D;5566# 创建存储目录mkdir &#x2F;home&#x2F;iki&#x2F;fastdfs_storage&#x2F;usr&#x2F;bin&#x2F;fdfs_storaged &#x2F;etc&#x2F;fdfs&#x2F;storage.conf start cd /home/iki/fastdfs_storage/data 查看数据 ls 使用fastdfs测试工具 cd &#x2F;etc&#x2F;fdfs&#x2F;cp client.conf.sample client.confvim client.confbase_path&#x3D;&#x2F;home&#x2F;iki&#x2F;fastdfstracker_server&#x3D;172.27.82.119:22122http.tracker_server_port&#x3D;6655# 测试运行cd &#x2F;home&#x2F;iki&#x2F;echo &quot;hollo fastdfs!!&quot; &gt; hello.md&#x2F;usr&#x2F;bin&#x2F;fdfs_test &#x2F;etc&#x2F;fdfs&#x2F;client.conf upload &#x2F;home&#x2F;iki&#x2F;hello.md 可用查看输出日志 访问： http://172.27.82.119/M00/00/00/rBtSd1ukkS-AA5kFAAAAG3Cag0g6276.md http://172.27.82.119/M00/00/00/rBtSd1ukkS-AA5kFAAAAG3Cag0g6276_big.md 安装 fastdfs-nginx-module这里注意去看看nginx安装教程配置对比 wget http://tar.matosiki.site/zip/fastdfs-nginx-module.zip unzip fastdfs-nginx-module.zipmv fastdfs-nginx-module &#x2F;usr&#x2F;local# 关闭原nginx进程pkill nginx# 进入nginx 源码目录cd &#x2F;usr&#x2F;local&#x2F;nginx-1.15.0.&#x2F;configure --add-module&#x3D;&#x2F;usr&#x2F;local&#x2F;fastdfs-nginx-module&#x2F;src 注意查看 模块添加是否成功 make; make install 配置nginx mkdir -p /usr/local/nginx/logs vi /usr/local/nginx/conf/nginx.conf pid &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;nginx.pid; location &#x2F;M00 &#123; root &#x2F;home&#x2F;iki&#x2F;fastdfs&#x2F;data; ngx_fastdfs_module; &#125; location ~&#x2F;group([0-9])&#x2F;M00 &#123; ngx_fastdfs_module; &#125;ln -s &#x2F;home&#x2F;iki&#x2F;fastdfs&#x2F;data &#x2F;home&#x2F;iki&#x2F;fastdfs&#x2F;data&#x2F;M00cp &#x2F;usr&#x2F;local&#x2F;fastdfs-nginx-module&#x2F;src&#x2F;mod_fastdfs.conf &#x2F;etc&#x2F;fdfs&#x2F;mod_fastdfs.conf vi /etc/fdfs/mod_fastdfs.conf url_have_group_name &#x3D; truetracker_server&#x3D;172.27.82.119:22122store_path0&#x3D;&#x2F;home&#x2F;iki&#x2F;fastdfs_storage cp &#x2F;usr&#x2F;local&#x2F;fastdfs-5.05&#x2F;conf&#x2F;http.conf &#x2F;etc&#x2F;fdfs&#x2F;http.conf cp &#x2F;usr&#x2F;local&#x2F;fastdfs-5.05&#x2F;conf&#x2F;mime.types &#x2F;etc&#x2F;fdfs&#x2F;mime.types java API使用 参考链接","categories":[],"tags":[]},{"title":"blog/linux/centos安装使用gitlab","slug":"blog/linux/centos安装使用gitlab","date":"2020-04-18T07:01:23.077Z","updated":"2020-04-18T07:01:23.077Z","comments":true,"path":"blog/linux/centos安装使用gitlab/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gitlab/","excerpt":"","text":"centos安装使用gitlab安装gitlab必要的依赖注： gitlab 非常占内存，鄙人至少使用3g才够用 sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshd# sudo firewall-cmd --permanent --add-service=http# sudo systemctl reload firewalld 安装Postfix发送邮件通知sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 添加gitlab仓库安装包curl https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;gitlab&#x2F;gitlab-ee&#x2F;script.rpm.sh | sudo bash 安装gitlab包# 注意这里的80端口 默认是80端口 如果想改访问端口请在这里配置sudo EXTERNAL_URL&#x3D;&quot;http:&#x2F;&#x2F;gitlab.matosiki.site:80&quot; yum install -y gitlab-ee 浏览主机名并登陆http://192.168.132:80输入初始密码 matosiki使用 root matosiki登录 邮箱配置vi &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rbgitlab_rails[&#39;gitlab_email_from&#39;] &#x3D; &quot;matosiki_hz@163.com&quot;gitlab_rails[&#39;smtp_enable&#39;] &#x3D; truegitlab_rails[&#39;smtp_address&#39;] &#x3D; &quot;smtp.163.com&quot;gitlab_rails[&#39;smtp_port&#39;] &#x3D; 465gitlab_rails[&#39;smtp_user_name&#39;] &#x3D; &quot;matosiki_hz@163.com&quot;gitlab_rails[&#39;smtp_password&#39;] &#x3D; &quot;1234qwer&quot;gitlab_rails[&#39;smtp_authentication&#39;] &#x3D; truegitlab_rails[&#39;smtp_enable_starttls_auto&#39;] &#x3D; truegitlab_rails[&#39;smtp_tls&#39;] &#x3D; true gitlab-ctl reconfiguregitlab-ctl restart GitLab CI/CD 持续集成开发 .gitlab-ci.yml 文件到项目根目录并提交到仓库 配置Runner 进入项目配置 /gitlab-springboot/settings/ci_cd#js-runners-settings 看到手动安装的步骤：注意url :http://192.168.10.137/ 注册令牌 yyNGcR9sqVLKwDqUD4g_进入gitlab机器中输入命令行 # 安装 gitlba Runnercurl -L https:&#x2F;&#x2F;packages.gitlab.com&#x2F;install&#x2F;repositories&#x2F;runner&#x2F;gitlab-runner&#x2F;script.rpm.sh | sudo bashsudo yum install gitlab-ci-multi-runner## 完成测试gitlab-ci-multi-runner##注册 gitlab-ci-multi-runner register# 注意这是填写上面的urlhttp:&#x2F;&#x2F;192.168.10.137&#x2F;## 注意这里填写上面的令牌yyNGcR9sqVLKwDqUD4g_## tags (用逗号分隔)gitlab,runnner,集成,开发,测试## 描述my gitlab runner 一起干活## 选择执行器 选择简单的shellshell## 验证启动是否成功sudo gitlab-runner verify## 启动runner 刷新gtilab网页 下方可以看到刚刚添加的runner sudo gitlab-runner run 参考文档gitlab官方文档 linux手动安装runnner 仓库选择安装runnner runnner-register runnner-executors","categories":[],"tags":[]},{"title":"blog/linux/centos7安装keepalived实现负载均衡","slug":"blog/linux/centos7安装keepalived实现负载均衡","date":"2020-04-18T07:01:23.076Z","updated":"2020-06-04T02:03:57.272Z","comments":true,"path":"blog/linux/centos7安装keepalived实现负载均衡/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos7%E5%AE%89%E8%A3%85keepalived%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","excerpt":"","text":"环境配置 node1 192.168.10.111 node2 192.168.10.112 keeplived + nginx keeplived + nginx 安装keeplivedyum install -y openssl openssl-develwget http://tar.matosiki.site/tar/keepalived-2.0.0.tar.gztar -zxvf keepalived-2.0.0.tar.gz -C /usr/local/cd /usr/local/keepalived-2.0.0/ &amp;&amp; ./configure --prefix=/usr/local/keepalivedmake &amp;&amp; make install keeplived做成服务mkdir -p /etc/keepalivedcp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/cp /usr/local/keepalived-2.0.0/keepalived/etc/init.d/keepalived /etc/init.d/cp /usr/local/keepalived-2.0.0/keepalived/etc/sysconfig/keepalived /etc/sysconfig/ln -s /usr/local/sbin/keepalived /usr/sbin/# ln -s /usr/local/keepalived/sbin/keepalived /sbin/chmod 755 /etc/init.d/keepalivedchkconfig keepalived on 更改节点1配置文件vi &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf global_defs &#123; router_id NODE1 # 更改路由编号&#125;vrrp_script chk_http_port &#123; script \"/etc/keepalived/nginx_check.sh\" # 检查脚本 interval 2 weight -20 # 权重减20&#125;vrrp_instance VI_1 &#123; state MASTER # 主节点为MASTER，备份节点为BACKUP interface ens33 # 网卡名称 virtual_router_id 50 #虚拟路由编号 priority 100 # 优先级配置0-254 advert_int 1 # 组播信息发送间隔，两个节点必须配置一致，默认1s authentication &#123; auth_type PASS auth_pass matosiki # 真实生产环境下对密码进行匹配 &#125; track_script &#123; chk_http_port &#125; virtual_ipaddress &#123; 192.168.10.66/24 # 虚拟ip(vip)，可以指定多个 两个节点保持一直 &#125;&#125; 节点2配置global_defs &#123; router_id NODE2&#125;vrrp_script chk_http_port &#123; script \"/etc/keepalived/nginx_check.sh\" interval 2 weight -20&#125;vrrp_instance VI_1 &#123; state BACKUP interface ens33 virtual_router_id 50 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass matosiki &#125; track_script &#123; chk_http_port &#125; virtual_ipaddress &#123; 192.168.10.66/24 &#125;&#125; 两台机器上编写 nginx_check.sh脚本 vi &#x2F;etc&#x2F;keepalived&#x2F;nginx_check.sh A=`ps -C nginx –no-header |wc -l`if [ $A -eq 0 ];then /usr/local/nginx/sbin/nginx sleep 2 if [ `ps -C nginx --no-header |wc -l` -eq 0 ]; then killall keepalived fifi chmod +x &#x2F;etc&#x2F;keepalived&#x2F;nginx_check.sh service keepalived startip aps -ef | grep nginx ps -ef | grep keepalived 【问题】 在vmware有动态ip也有静态ip设置vip为192.168.10.66 开始可以访问重启keeplived服务后就无法ping通了【解决】vi /etc/keepalived/keepalived.conf注释掉vrrp_strict","categories":[],"tags":[]},{"title":"blog/linux/centos安装docekr镜像仓库habor","slug":"blog/linux/centos安装docekr镜像仓库habor","date":"2020-04-18T07:01:23.076Z","updated":"2020-06-04T02:06:01.639Z","comments":true,"path":"blog/linux/centos安装docekr镜像仓库habor/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%E5%AE%89%E8%A3%85docekr%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93habor/","excerpt":"","text":"centos安装docekr镜像仓库habor预装环境：1.docker2.python-pip3.git yum install python-pip -yyum install git -y curl -O http://tar.matosiki.site/tar/harbor-offline-installer-v1.5.4.tgztar -xvzf harbor-offline-installer-v1.5.4.tgz -C /opt/cd /opt/harbor/vi /opt/harbor/harbor.cfg #设置域名hostname &#x3D; 172.25.210.149#设置访问协议ui_url_protocol &#x3D; http .&#x2F;prepare# 如果启动（harbor-log:v1.5.4 not found ） 手动将v1.5.4版本改成 v1.5.2vi docker-compose.yml# 注意修改nginx端口docker-compose up -ddocker ps# 默认使用admin&#x2F;Harbor12345可以登录curl http:172.25.210.149 启动六个容器 harbor-log harbor-ui registry harbor-db harbor-jobservice nginx docker配置私有仓库访问vi &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service [Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target​[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd --insecure-registry 192.168.10.135ExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s​[Install]WantedBy=multi-user.target","categories":[],"tags":[]},{"title":"blog/linux/centos mini版 解决无法上网","slug":"blog/linux/centos mini版 解决无法上网","date":"2020-04-18T07:01:23.076Z","updated":"2020-06-04T02:04:03.853Z","comments":true,"path":"blog/linux/centos mini版 解决无法上网/","link":"","permalink":"http://www.matosiki.site/blog/linux/centos%20mini%E7%89%88%20%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91/","excerpt":"","text":"安装centos mini版 解决无法上网问题# 更改网卡配置进入/etc/sysconfig/network-scripts目录&gt; cd /etc/sysconfig/network-scripts&gt; vi ifcfg-ens33 将ONBOOT改为 ***ONBOOT=YES***# 重启网络&gt; service network restart 或者&gt; systemctl restart network# 使用yum 安装 ifconfig&gt; yum provides ifconfig# 使用yum 安装网络工具 &gt; yum install net-tools# 更新软件 &gt; yum -y update","categories":[],"tags":[]}]}