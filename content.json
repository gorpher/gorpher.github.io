{"meta":{"title":"大道至简","subtitle":"以不变应万变","description":"不积跬步无以至千里","author":"iki","url":"http://www.matosiki.site"},"pages":[{"title":"","date":"2020-05-08T01:49:32.484Z","updated":"2020-05-08T01:49:32.484Z","comments":true,"path":"404/404.html","permalink":"http://www.matosiki.site/404/404.html","excerpt":"","text":""},{"title":"","date":"2020-06-04T01:18:32.812Z","updated":"2020-06-04T01:18:32.812Z","comments":true,"path":"404/index.html","permalink":"http://www.matosiki.site/404/index.html","excerpt":"","text":"_ __ _ _ | | / _(_) | | _ __ __ _ __ _ ___ _ __ ___ | |_ | |_ _ _ __ __| || &apos;_ \\ / _` |/ _` |/ _ \\ | &apos;_ \\ / _ \\| __| | _| | &apos;_ \\ / _` || |_) | (_| | (_| | __/ | | | | (_) | |_ | | | | | | | (_| || .__/ \\__,_|\\__, |\\___| |_| |_|\\___/ \\__| |_| |_|_| |_|\\__,_|| | __/ | |_| _ _ |___/_ _ | || | / _ \\| || | | || |_| | | | || |_ |__ _| | | |__ _| | | | |_| | | | |_| \\___/ |_|"},{"title":"个人简历","date":"2020-05-08T01:49:32.490Z","updated":"2020-05-08T01:49:32.490Z","comments":true,"path":"about/index.html","permalink":"http://www.matosiki.site/about/index.html","excerpt":"","text":"我是虾,不皮皮虾的的那种!! 基本介绍 性别男，取向女 geek爱好者，脑洞大，敢尝试，乐意思考，有梦想，爱生活，会运动，敢拼搏，敢说敢做，有爱心，知道人情世故崇尚知行合一的做事方法,喜欢我思故我在的人生态度,实践不积跬步,无以至千里的学习方式,践行终生学习的理念.### 个人广告词- 我思故我在### 曾经 喜欢我☝关注我"}],"posts":[{"title":"","slug":"blog/tools/高效的使用Postman进行API调试","date":"2020-05-08T03:44:42.543Z","updated":"2020-05-08T03:44:42.543Z","comments":true,"path":"blog/tools/高效的使用Postman进行API调试","link":"","permalink":"http://www.matosiki.site/blog/tools/高效的使用Postman进行API调试","excerpt":"","text":"简介在postman使用中,很多接口使用共同的请求地址和相同的参数,这样我们可以定义一些公共的环境变量,每个collection可以使用变量.postman也内置了一些变量,比如生成随机数,生成字符串,生成id,这些变量用于表单测试是非常方便的. 下面我就简简单单定义变量和请求参数自定义装饰器并测试结果. 定义环境变量在postman中可以自定义环境变量,我们可以添加全局变量也可以添加自定义collection的变量,这里我定义了一个,eureka集合的变量,其中包含主机名和端口地址等变量. 使用变量使用变量目前有三种方式: 第一种如图,在表单中添加变量,注意使用 中的变量将会被定义的变量值替换掉 第二种如图, 在使用application/json的方式发送请求时,就没办法使用 形式的变量.此时我们需要在pre-request-Srcipt中手动些装饰器,将替换掉.在这种方式下可分为两种具体实现: 方式一:将使用replace替换 内置变量 方式二:解析json为obj对象,然后更改obj对象的值 json请求值:&#123; &quot;instance&quot;: &#123; &quot;instanceId&quot;: &quot;&#123;&#123;appID&#125;&#125;:11101&quot;, &quot;app&quot;: &quot;&#123;&#123;appID&#125;&#125;&quot;, &quot;appGroutName&quot;: null, &quot;ipAddr&quot;: &quot;127.0.0.1&quot;, &quot;sid&quot;: &quot;na&quot;, &quot;homePageUrl&quot;: null, &quot;statusPageUrl&quot;: null, &quot;healthCheckUrl&quot;: null, &quot;secureHealthCheckUrl&quot;: null, &quot;vipAddress&quot;: &quot;tf-service&quot;, &quot;secureVipAddress&quot;: &quot;tf-service&quot;, &quot;countryId&quot;: 1, &quot;dataCenterInfo&quot;: &#123; &quot;@class&quot;: &quot;com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo&quot;, &quot;name&quot;: &quot;MyOwn&quot; &#125;, &quot;hostName&quot;: &quot;127.0.0.1&quot;, &quot;status&quot;: &quot;UP&quot;, &quot;leaseInfo&quot;: null, &quot;isCoordinatingDiscoveryServer&quot;: false, &quot;lastUpdatedTimestamp&quot;: 1529391461000, &quot;lastDirtyTimestamp&quot;: 1529391461000, &quot;actionType&quot;: null, &quot;asgName&quot;: null, &quot;overridden_status&quot;: &quot;UNKNOWN&quot;, &quot;port&quot;: &#123; &quot;$&quot;: 11102, &quot;@enabled&quot;: &quot;false&quot; &#125;, &quot;securePort&quot;: &#123; &quot;$&quot;: 7002, &quot;@enabled&quot;: &quot;false&quot; &#125;, &quot;metadata&quot;: &#123; &quot;@class&quot;: &quot;java.util.Collections$EmptyMap&quot; &#125; &#125;&#125; pre-request-Srcipt中的内容// 检查请求头是否是jsonfunction isJsonReq()&#123; var header = pm.request.headers; header.each(function(v)&#123; if(v[&apos;key&apos;]==&apos;Content-Type&apos;&amp;&amp;v[&apos;value&apos;]==&quot;application/json&quot;)&#123; return true; &#125; &#125;); return false; &#125; // 方法一: 替换全局变量pm.request.body.raw = replace(pm.request.body.raw);console.log(pm.request)function replace(reqbody)&#123; if(reqbody&amp;&amp;isJsonReq())&#123; var values = pm.environment.values; values.each(function(v)&#123; reqbody = reqbody.replace(new RegExp(&quot;&#123;&#123;&quot;+v[&apos;key&apos;]+&quot;&#125;&#125;&quot;,&apos;g&apos;),v[&apos;value&apos;]) &#125;) &#125; return reqbody;&#125; // 方法二: 动态生成编号gen(pm.request.body.raw);console.log(pm.ace)function gen(reqbody)&#123; if(reqbody&amp;&amp;isJsonReq())&#123; var obj = JSON.parse(reqbody) obj = doit(obj) //实现对象属性值替换 pm.request.body.raw = JSON.stringify(obj) &#125;&#125;function doit(obj)&#123; obtuoj[&apos;instance&apos;][&apos;instanceID&apos;]=require(&apos;uuid&apos;)(); // todo 替换变量 console.log(obj) return obj;&#125; 使用高级js库在postman的沙盒环境中,我们可以使用一些高级的js库.我们可以在pre-request-script和end-test中使用. var Ajv = require(&apos;ajv&apos;);var ajv = new Ajv();// 根据schema验证json// var validate = ajv.compile(schema);// var valid = validate(data);// if (!valid) console.log(validate.errors);// atob var atob = require(&apos;atob&apos;);var b64 = &quot;SGVsbG8sIFdvcmxkIQ==&quot;;var bin = atob(b64); // base64转ascii码console.log(bin);var btoa = require(&apos;btoa&apos;);var b64 = btoa(bin);console.log(b64);var should = require(&apos;chai&apos;).should() // BDD/TDD assert 库 , foo = &apos;bar&apos; , beverages = &#123; tea: [ &apos;chai&apos;, &apos;matcha&apos;, &apos;oolong&apos; ] &#125;;foo.should.be.a(&apos;string&apos;);foo.should.equal(&apos;bar&apos;);foo.should.have.lengthOf(3);beverages.should.have.property(&apos;tea&apos;).with.lengthOf(3)var CryptoJS = require(&quot;crypto-js&quot;);console.log(CryptoJS.HmacSHA1(&quot;Message&quot;, &quot;Key&quot;));var moment = require(&apos;moment&apos;);console.log(moment().format())const uuidv1 = require(&apos;uuid&apos;);console.log(uuidv1())const &#123; StringDecoder &#125; = require(&apos;string_decoder&apos;);const decoder = new StringDecoder(&apos;utf8&apos;);const cent = Buffer.from([0xC2, 0xA2]);console.log(decoder.write(cent));const path = require(&apos;path&apos;);console.log(path.basename(&apos;C:\\\\temp\\\\myfile.html&apos;))const assert = require(&apos;assert&apos;);assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, &apos;3&apos;]], 4, 5]);const util = require(&apos;util&apos;);// console.log(require(&apos;lodash&apos;).join([1,24,5],[1234]))var _ = require(&apos;lodash&apos;);console.log(_.random(5, true)) //生成随机数1-5var abc = function(a,b,c)&#123; return [a,b,c];&#125;var curried = _.curry(abc);console.log(curried(1)(2)(3)) //函数柯里化console.log(_.now()) //获取当前时间搓var timer = require(&apos;timers&apos;)console.log(timer) 测试结果在每次请求后还可以编写断言脚本验证结果 tests[&quot;请求成功&quot;] = responseCode.code === 204;pm.test(&quot;注册新实例成功&quot;, function () &#123; pm.response.to.have.body(&quot;&quot;);&#125;); 参考: postman官方文档-sanbox","categories":[],"tags":[]},{"title":"","slug":"blog/tools/高效的使用Postman进行Mock Server","date":"2020-05-08T03:44:42.543Z","updated":"2020-06-04T01:07:15.090Z","comments":true,"path":"blog/tools/高效的使用Postman进行Mock Server","link":"","permalink":"http://www.matosiki.site/blog/tools/高效的使用Postman进行Mock Server","excerpt":"","text":"1. 添加Example在自己添加的collection中,正常测试完成,将response保存为Example.这样防止API接口断供后,无法获取数据,这样可以从Example中查看到保存的Response. 但是如果你想,根据Example做一个MockServer,这样每次访问接口都能拿到Example中Response的结果了.接下来,第一步将Response保存到Example中. 在弹出的页面中填写好Example的名称,还可以自己调正Response返回的值. 2. 添加mock环境正常情况下有一个collection的环境,但为了mock测试方便,新建一个mock环境.注意: mock环境中有两个变量,x-api-key这个需要在自己的workspace上生成, url这个需要等到mock server 创建时填写. 3.新建mock server在postman中,点击New按钮,选择Mock Server,会看到如下图对话框在第一步中选择 Select an existing collection 选择 eurekacollection,点击Next.第二步,设置mock server,注意选择 eureka mock 环境,并且注意要去自己的workspace生成x-api-key,再点击Next,页面会返回一个URL,这个就是Mock URL,复制这个变量拷贝到mock环境变量中,到这里差不多就快完成了,还有最后 如果找不到Mock Server Url 也可以去workspace中找到. 4.生成API-KEY进入自己的workspace,生成自己的API key,复制Api-key到mock 环境中,完成了mock环境配置. 5.Runner测试最后我们来测试mock server,选择collection,添加Runner,选择环境变量,运行测试.查看测试结果 总结: 如何使用postman进行mock server 对接口进行测试. 参考链接 Postman API Postman Examples","categories":[],"tags":[]},{"title":"","slug":"blog/java/jvm工作原理","date":"2020-05-08T03:44:42.542Z","updated":"2020-06-04T01:06:41.499Z","comments":true,"path":"blog/java/jvm工作原理","link":"","permalink":"http://www.matosiki.site/blog/java/jvm工作原理","excerpt":"","text":"一、 JVM的生命周期 JVM实例对应了一个独立运行的java程序它是进程级别a) 启动。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点b) 运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程c) 消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出 JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的 二、 JVM的体系结构 类装载器（ClassLoader）（用来装载.class文件） 执行引擎（执行字节码，或者执行本地方法） 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈） 三、 JVM类加载器JVM整个类加载过程的步骤： 装载装载过程负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：类名+包名+ClassLoader实例ID。 链接链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。完成校验后，JVM初始化类中的静态变量，并将其值赋为默认值。最后对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。 初始化初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，在四种情况下初始化过程会被触发执行：调用了new；反射调用了类中的方法；子类调用了初始化；JVM启动过程中指定的初始化类。 VM类加载顺序：JVM两种类装载器包括：启动类装载器和用户自定义类装载器。启动类装载器是JVM实现的一部分；用户自定义类装载器则是Java程序的一部分，必须是ClassLoader类的子类。JVM装载顺序： Jvm启动时，由Bootstrap向User-Defined方向加载类； 应用进行ClassLoader时，由User-Defined向Bootstrap方向查找并加载类； Bootstrap ClassLoaderzh这是JVM的根ClassLoader，它是用C++实现的，JVM启动时初始化此ClassLoader，并由此ClassLoader完成$JAVA_HOME中jre/lib/rt.jar（Sun JDK的实现）中所有class文件的加载，这个jar中包含了java规范定义的所有接口以及实现。 Extension ClassLoaderJVM用此classloader来加载扩展功能的一些jar包。 System ClassLoaderJVM用此classloader来加载启动参数中指定的Classpath中的jar包以及目录，在Sun JDK中ClassLoader对应的类名为AppClassLoader。 User-Defined ClassLoaderUser-DefinedClassLoader是Java开发人员继承ClassLoader抽象类自行实现的ClassLoader，基于自定义的ClassLoader可用于加载非Classpath中的jar以及目录。 ClassLoader抽象类的几个关键方法：（1） loadClass 此方法负责加载指定名字的类，ClassLoader的实现方法为先从已经加载的类中寻找，如没有则继续从parent ClassLoader中寻找，如仍然没找到，则从System ClassLoader中寻找，最后再调用findClass方法来寻找，如要改变类的加载顺序，则可覆盖此方法（2） findLoadedClass此方法负责从当前ClassLoader实例对象的缓存中寻找已加载的类，调用的为native的方法。（3） findClass此方法直接抛出ClassNotFoundException，因此需要通过覆盖loadClass或此方法来以自定义的方式加载相应的类。（4） findSystemClass此方法负责从System ClassLoader中寻找类，如未找到，则继续从Bootstrap ClassLoader中寻找，如仍然为找到，则返回null。（5） defineClass此方法负责将二进制的字节码转换为Class对象（6） resolveClass此方法负责完成Class对象的链接，如已链接过，则会直接返回。 四、 JVM执行引擎在执行方法时JVM提供了四种指令来执行：（1）invokestatic：调用类的static方法（2）invokevirtual：调用对象实例的方法（3）invokeinterface：将属性定义为接口来进行调用（4）invokespecial：JVM对于初始化对象（Java构造器的方法为：）以及调用对象实例中的私有方法时。 主要的执行技术有:解释，即时编译，自适应优化、芯片级直接执行（1）解释属于第一代JVM，（2）即时编译JIT属于第二代JVM，（3）自适应优化（目前Sun的HotspotJVM采用这种技术）则吸取第一代JVM和第二代JVM的经验，采用两者结合的方式 开始对所有的代码都采取解释执行的方式，并监视代码执行情况，然后对那些经常调用的方法启动一个后台线程，将其编译为本地代码，并进行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行。 五、 JVM运行时数据区第一块：PC寄存器PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。第二块：JVM栈JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址第三块：堆（Heap）它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。（1） 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的（2） Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配（3） TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。第四块：方法区域（Method Area）（1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。（2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class 对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。第五块：运行时常量池（Runtime Constant Pool）存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。第六块：本地方法堆栈（Native Method Stacks）JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。 六、 JVM垃圾回收GC的基本原理： 将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停（1）对新生代的对象的收集称为minor GC；（2）对旧生代的对象的收集称为Full GC；（3）程序中主动调用System.gc()强制执行的GC为Full GC。不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：（1）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）（3）弱引用：在GC时一定会被GC回收（4）虚引用：由于虚引用只是用来得知对象是否被GC","categories":[],"tags":[]},{"title":"","slug":"blog/java/oauth2-0-深入理解","date":"2020-05-08T03:44:42.542Z","updated":"2020-06-04T01:06:58.155Z","comments":true,"path":"blog/java/oauth2-0-深入理解","link":"","permalink":"http://www.matosiki.site/blog/java/oauth2-0-深入理解","excerpt":"","text":"OAuth2.0是什么用于REST/APIS的代理授权框架（delegatedauthorizetion framework）,基于令牌token的授权，在无需暴露用户密码的情况下，使应用能够对用户数据有效访问权限，充分解耦认证和授权，实际上是标准的安全架构，支持多种应用场景，服务器端WebApp,浏览器单页面SPA，无线原生App,服务器与服务器之间访问。像仆从钥匙，给应用授权优先的访问权限，代表用户访问用户数据。OAoth是系统之间代理授权协议 优点 易实现 安全，服务端不接触用户密码，服务单更容易集中保护。 广泛传播被持续采用 短寿命和封装的token 资源服务器和授权服务器解耦 集中授权简化客户端 HTTP/JSON友好易于请求和传递token 考虑多种客户端架构场景 客户可以具有不同的信任级别 缺点 协议框架太宽泛，造成各种实现的兼容性和互操作性 与OAuth1.0不兼容 OAuth 2.0 不是一个认证协议，OAuth2.0本身并不能告诉你任何用户信息 架构角色1.授权服务 Authorization Service客户应用成功认证并获得授权之后，向客户应用颁发访问令牌。 2.资源服务 Resource Service一个web服务或者web应用，保存用户受保护的数据 3.客户端应用 Client Application通常是一个浏览器或者手机app，它需要用户受保护的数据 4.资源拥有者 owner数据拥有者，想把数据分享给他人使用 客户端应用需要访问资源服务,但是没有认证,此时客户端去授权服务获取认证令牌,拿到令牌后交给资源服务器,资源服务器拿到令牌后也去授权服务比较一次,如果是对的,就认证通过. OAuth2.0语术概念1.客户凭证 Client Credentials客户的clientId和密码用户认证客户 2.令牌 Tokens授权服务器在接收到客户请求后颁发的资源服务器令牌类型 授权码 (Authorization Code Token) 仅用于授权码类型，用于交换获取访问令牌和刷新令牌 刷新令牌 (Refresh Token) 用于去授权服务器获取一个新的token 访问令牌 (Access Token) 代表用户直接访问受保护的资源服务器 Bearer Token 不管谁拿到都可以访问资源 Proof of Prosession Token 可以校验Client是否对Token有明确的权限 3.作用域客户请求访问令牌时，有资源拥有者额外指定的细分权限 应用场景,解决方案一、开放间系统授权1.社交联合登陆 2.开放API平台 二、现代微服务安全1.单页面浏览器APP 2.无线原生APP 3.服务端WebApp 4.微服务和原生API调用 三、企业内部认证授权(IAM,SSO)AOuth Flow推荐两篇文章 https://tools.ietf.org/html/rfc6749 理解OAuth 2.0 - 阮一峰的网络日志 客户端的授权模式1. 授权码模式 授权步骤 A.用户访问客户端,客户端重定向到认证服务器. B.用户选择授权客户端 C.如果用户授权,授权服务器重定向到客户端带来的url并附加一个授权码 D.客户端附带重定向url和授权码后台请求授权服务器申请令牌 E.授权服务器校对授权码和重定向url,确认无误,向客户端发送访问令牌(Access Token)和刷新令牌(Refresh Token) 基于spring security oauth2.0搭建最简授权码模式服务器一、 源码资源服务器和授权服务器一起案例 引入jar包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- OAuth 2.0 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 添加授权服务器配置 //授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) .redirectUris(&quot;http://localhost:9001/callback&quot;) // 授权码模式 .authorizedGrantTypes(&quot;authorization_code&quot;) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125;&#125; 添加资源服务器配置 //资源服务配置@Configuration@EnableResourceServerpublic class OAuth2ResourceServer extends ResourceServerConfigurerAdapter &#123; @Override public void configure(HttpSecurity http) throws Exception &#123; http.authorizeRequests() .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers(&quot;/api/**&quot;); &#125;&#125; 配置添加授权用户 # Spring Security Settingsecurity.user.name=user1security.user.password=passwd1 添加资源服务器api入口 @Controllerpublic class UserController &#123; // 资源API @RequestMapping(&quot;/api/userinfo&quot;) public ResponseEntity&lt;UserInfo&gt; getUserInfo() &#123; User user = (User) SecurityContextHolder.getContext() .getAuthentication().getPrincipal(); String email = user.getUsername() + &quot;@hello.com&quot;; UserInfo userInfo = new UserInfo(); userInfo.setName(user.getUsername()); userInfo.setEmail(email); return ResponseEntity.ok(userInfo); &#125;&#125; 启动服务器 二、实践 获取授权码 请求：打开浏览器 输入地址： http://localhost:8080/oauth/authorize?client_id=clientapp&amp;redirect_uri=http://localhost:9001/callback&amp;response_type=code&amp;scope=read_userinfo 输入用户名和密码，选择授权。 请求：页面会跳转一个callback地址加授权码http://localhost:9001/callback?code=4PFZ2w 获取令牌 请求：curl -X POST --user clientapp:123456 http://localhost:8080/oauth/token -H&quot;content-type: application/x-www-form-urlencoded&quot; -d&quot;code=4PFZ2w&amp;grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9001%2Fcallback&amp;scope=read_userinfo&quot; 响应：&#123;\"access_token\":\"44a572ca-3a05-40ba-a557-35955179e143\",\"token_type\":\"bearer\",\"expires_in\":43199,\"scope\":\"read_userinfo\"&#125; 访问资源，调用API请求： curl -X GET http://localhost:8080/api/userinfo -H &quot;authorization: Bearer 44a572ca-3a05-40ba-a557-35955179e143&quot; 响应： &#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 通过前端渠道客户获取授权码 通过后端渠道,客户使用authorization code 交换access token 或refresh token 假定资源拥有者和客户在不同的设备上 最安全的流程,因为令牌不会传递经过User-Agent 总结: 授权码模式本质上是客户端通过用户名密码发起获取授权码请求,服务端根据回调地址返回授权码,客户端根据授权码访问资源服务器,资源服务器根据授权码拿到授权服务器给的access token返回给客户端,客户端就可以带着这个access token访问资源服务器上的有效资源. 2. 简化模式 授权步骤 客户端重定向用户到认证服务器 用户选择是否授权给客户端 用户授权,授权服务器根据客户端请求参数uri重定向到客户端,并将token放入url的hash部分 资源服务返回一个页面,可以获取hash值 浏览器执行脚本获取令牌 浏览器叫令牌发送给客户端 基于spring security oauth2.0搭建简化模式服务器一、 源码资源服务器和授权服务器一起案例 引入spring security 和 oauth jar包 授权服务器配置 //简化服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) .redirectUris(&quot;http://localhost:9001/callback&quot;) // 授权码模式 //.authorizedGrantTypes(&quot;authorization_code&quot;) // 简化模式 .authorizedGrantTypes(&quot;implicit&quot;) .accessTokenValiditySeconds(120) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125;&#125; 二、操作 获取令牌访问浏览器http://localhost:8080/oauth/authorize?client_id=clientapp&amp;redirect_uri=http://localhost:9001/callback&amp;response_type=token&amp;scope=read_userinfo&amp;state=abc 输入配置的用户和密码，选择授权。响应： http://localhost:9001/callback#access_token=d678754d-752c-46cc-9a9b-d59ae830cddb&amp;token_type=bearer&amp;state=abc&amp;expires_in=119 访问资源，调用API curl -X GET http://localhost:8080/api/userinfo -H &quot;authorization: Bearer d678754d-752c-46cc-9a9b-d59ae830cddb&quot; 响应：&#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 适用于公开的浏览器单页面应用 Access Token 直接从授权服务器返回 不支持Refresh Token 假定资源拥有者和客户在同一设备上 最容易受安全攻击 总结：简化模式，就是没有授权码的授权模式，去掉了授权码这个步骤。 3. 密码模式 Resource Owner Password Credential Grant 授权步骤 用户向客户端提供用户名和密码 客户端将用户名和密码发送给认证服务器去认证授权 认证服务器验证无误，返回给客户端令牌 基于spring security oauth2.0搭建密码模式服务器一、代码授权服务器配置// 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; // 用户认证 @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager); &#125; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) // 密码模式 .authorizedGrantTypes(&quot;password&quot;) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125;&#125; 一、操作 获取令牌 curl -X POST --user clientapp:123456 http://localhost:8080/oauth/token -H &quot;accept: application/json&quot; -H &quot;content-type: application/x-www-form-urlencoded&quot; -d &quot;grant_type=password&amp;username=user1&amp;password=passwd1&amp;scope=read_userinfo&quot; 响应： &#123;&quot;access_token&quot;:&quot;9247e26e-b9d7-488b-88b0-25fb046ac7ce&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;expires_in&quot;:43163,&quot;scope&quot;:&quot;read_userinfo&quot;&#125; 访问资源，调用API curl -X GET http://localhost:8080/api/userinfo -H &quot;authorization: Bearer 9247e26e-b9d7-488b-88b0-25fb046ac7ce&quot; 响应： &#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 使用用户名密码登录的应用,比如桌面应用 使用用户名/密码作为授权方式从授权服务器上获取access token 一般不支持refresh token 假定资源拥有者和公开客户在相同设备上 总结：密码授权模式，是对客户端极度信任的情况下，将用户名和密码交给客户端，客户端去授权服务器获取令牌。 4. 客户端模式 授权步骤 客户端直接向授权服务器发起授权认证，获取令牌 授权服务器校验通过，颁发令牌 基于spring security oauth2.0搭建客户端模式服务器一、代码授权服务器配置// 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientdevops&quot;) // 密码模式 .secret(&quot;123456&quot;) .authorizedGrantTypes(&quot;client_credentials&quot;) .scopes(&quot;devops&quot;); &#125;&#125; 二、操作 获取令牌 curl -X POST &quot;http://localhost:8080/oauth/token&quot; --user clientdevops:123456 -d&quot;grant_type=client_credentials&amp;scope=devops&quot; 响应： &#123;&quot;access_token&quot;:&quot;ab5e2936-7463-456b-9ded-aac79d9311e1&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;expires_in&quot;:43199,&quot;scope&quot;:&quot;devops&quot;&#125; 访问资源，调用API curl -X GET http://localhost:8080/api/userinfo -H &quot;authorization: Bearer ab5e2936-7463-456b-9ded-aac79d9311e1&quot; 响应：&#123;&quot;name&quot;:&quot;user1&quot;,&quot;email&quot;:&quot;user1@hello.com&quot;&#125; 特点 适用于服务间通信,机器代表用户或者它自己 只有后端渠道,使用客户凭证获取一个access token 因为客户凭证可以使用对称或者非对称加密,该方式支持共享密码或者证书 刷新令牌 一、代码//授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter &#123; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.inMemory() .withClient(&quot;clientapp&quot;) .secret(&quot;123456&quot;) .redirectUris(&quot;http://localhost:9001/callback&quot;) // 密码模式 .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;) .accessTokenValiditySeconds(120) .refreshTokenValiditySeconds(60) .scopes(&quot;read_userinfo&quot;, &quot;read_contacts&quot;); &#125; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager); endpoints.userDetailsService(userDetailsService); &#125;&#125; 安全配置@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true) //启用方法级的权限认证public class SecurityConfiguration extends WebSecurityConfigurerAdapter &#123; @Bean @Override protected UserDetailsService userDetailsService() &#123; InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); manager.createUser(User.withUsername(&quot;user1&quot;).password(&quot;passwd1&quot;).authorities(&quot;USER&quot;).build()); manager.createUser(User.withUsername(&quot;root&quot;).password(&quot;root&quot;).authorities(&quot;USER&quot;).build()); return manager; &#125; @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception &#123; return super.authenticationManagerBean(); &#125;&#125; 二、操作获取令牌curl -i -X POST --user clientapp:123456 http://localhost:8080/oauth/token -H &quot;accept: application/json&quot; -H &quot;content-type: application/x-www-form-urlencoded&quot; -d &quot;grant_type=refresh_token&amp;refresh_token=dda1413c-86e8-4612-8e13-e9044e530c66&quot; 响应： HTTP/1.1 200X-Content-Type-Options: nosniffX-XSS-Protection: 1; mode=blockCache-Control: no-cache, no-store, max-age=0, must-revalidatePragma: no-cacheExpires: 0X-Frame-Options: DENYX-Application-Context: applicationCache-Control: no-storePragma: no-cacheContent-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Fri, 12 Jul 2019 07:43:15 GMT&#123;&quot;access_token&quot;:&quot;052f2239-6231-4537-bc93-33fce4c58d0c&quot;,&quot;token_type&quot;:&quot;bearer&quot;,&quot;refresh_token&quot;:&quot;dda1413c-86e8-4612-8e13-e9044e530c66&quot;,&quot;expires_in&quot;:119,&quot;scope&quot;:&quot;read_userinfo&quot;&#125; 认证方式选择 授权服务器端点 Authorize Endpoint (/oauth2/authorize) 认证端点 Token Endpoint (/oauth2/token) 令牌端点 Introspection Endpoint (/oauth2/instrospection) 检查端点 Revocation Endpoint (/aouth2/revoke) 吊销端点 Spring Security OAuth2.0架构http://terasolunaorg.github.io/guideline/5.3.0.RELEASE/en/Security/OAuth.html","categories":[],"tags":[]},{"title":"","slug":"blog/terraform/terraform理解入门","date":"2020-05-08T03:44:42.542Z","updated":"2020-06-04T01:07:03.279Z","comments":true,"path":"blog/terraform/terraform理解入门","link":"","permalink":"http://www.matosiki.site/blog/terraform/terraform理解入门","excerpt":"","text":"腾讯云栗子下载-tencentcloud-demo-module.zip Terraform是一种安全有效地构建，更改和版本化基础架构的工具。Terraform用于创建，管理和更新基础架构资源，例如物理机，VM，网络交换机，容器等。几乎任何基础设施类型都可以表示为Terraform中的资源。 四大功能 基础设置代码 执行计划 资源图 自动更新 Terraform使用场景 Heroku应用设置 多层应用 自助服务集群 软件演示 一次性环境 软件定义网络（SDN） 资源调度程序 多云部署 使用terraform安装下载windows版本使用命令验证安装将terraform.exe拷贝到指定目录,并设置path环境变量terraform 设置环境变量 插件缓存目录 set TF_PLUGIN_CACHE_DIR=&quot;%HOME%\\.terraform.d\\plugin-cache&quot; 手动安装插件目录 %APPDATA%\\terraform.d\\plugins 手动安装provider插件aws-provider插件google-provider插件 构建基础架构一.配置provider &quot;aws&quot; &#123; profile = &quot;default&quot; region = &quot;us-east-1&quot;&#125;resource &quot;aws_instance&quot; &quot;example&quot; &#123; ami = &quot;ami-2757f631&quot; instance_type = &quot;t2.micro&quot;&#125; 二.初始化terraform initterraform apply terrafomr show 三.应用更改更改amiresource &quot;aws_instance&quot; &quot;example&quot; &#123; ami = &quot;ami-b374d5a5&quot; instance_type = &quot;t2.micro&quot;&#125; terraform apply terrafomr show # 销毁基础设施terraform destroy 四.资源依赖 隐性依赖Terraform可以自动推断出一个资源何时依赖于另一个资源.Terraform使用此依赖关系信息来确定创建不同资源的正确顺序通过插值表达式的隐式依赖关系是告知Terraform关于这些关系的主要方式，应尽可能使用。 显式依赖depends_on任何资源都接受该参数，并接受资源列表以创建显式依赖项。 depends_on=[google_instance.example] 非资源依赖Terraform将同时执行操作以减少应用更改所需的总时间,非资源依赖与其他资源依赖的可能同时创建. 五.提供负责实例创建完成初始化工作,比如运行shell、触发软件配置等等. 定义提供者 provisioner &quot;local-exec&quot; &#123; command = &quot;echo $&#123;aws_instance.example.public_ip&#125; &gt; ip_address.txt&quot;&#125; terraform可以定义多个提供者 应用配置terraform applycat ip_address.txt 失败的提供者和污点资源 如果资源成功创建但在配置期间失败，则Terraform将发生错误并将资源标记为“受污染”。一个污点资源已被物理创建出来，由于预配失败，将无法被视为安全的使用。 当执行下一个计划时，因为不能保证安全，terraform不会在相同的资源上尝试重启预配置。取代方式是，terraform将移除所有污点资源，然后再创建资源并尝试预配置。 因为违反了执行计划，当执行期间失败时，terraform不会回滚和删除资源。 执行计划只告诉资源的创建，不会有删除资源，如果创建一个污点资源，计划将清除状态，资源将被删除。 销毁provisioners还可以定义仅在销毁操作期间运行的供应商。这些对于执行系统清理，提取数据等非常有用。对于许多资源，建议尽可能使用内置清理机制（例如init脚本），但必要时可以使用配置程序。 provisioners详细文档 输入变量 定义变量创建variables.tf文件 variable &quot;region&quot; &#123; default = &quot;us-east-1&quot;&#125; 引用变量 provider &quot;aws&quot; &#123; region = &quot;$&#123;var.region&#125;&quot;&#125; 分配变量 命令行分配方式 terraform apply -var region=us-east-2 从文件中分配创建目录匹配terraform.tfvars或 .auto.tfvars存在的所有文件，分配变量值。 region = &quot;us-east-2&quot; 指定多个变量文件terraform apply \\ -var-file=&quot;secret.tfvars&quot; \\ -var-file=&quot;production.tfvars&quot; 环境变量Terraform读取TF_VAR_name变量，TF_VAR_region 设置region变量 UI输入如果您terraform apply使用未指定的某些变量执行，Terraform将要求您以交互方式输入其值。 定义list类型变量 # 隐式声明# implicitly by using brackets [...]variable &quot;cidrs&quot; &#123; default = [] &#125;# 显式声明# explicitlyvariable &quot;cidrs&quot; &#123; type = list &#125; terraform.tfvars文件中定义cidrs = [ &quot;10.0.0.0/16&quot;, &quot;10.1.0.0/16&quot; ] 定义map类型变量variable &quot;amis&quot; &#123; type = &quot;map&quot; default = &#123; &quot;us-east-1&quot; = &quot;ami-b374d5a5&quot; &quot;us-west-2&quot; = &quot;ami-4b32be2b&quot; &#125;&#125; resource &quot;aws_instance&quot; &quot;example&quot; &#123; ami = var.amis[var.region] instance_type = &quot;t2.micro&quot;&#125; 命令行分配map类型变量terraform apply -var &apos;amis=&#123; us-east-1 = &quot;foo&quot;, us-west-2 = &quot;bar&quot; &#125;&apos; 栗子variables.tfvariable &quot;region&quot; &#123;&#125;variable &quot;amis&quot; &#123; type = &quot;map&quot;&#125; terraform.tfvarsamis = &#123; &quot;us-east-1&quot; = &quot;ami-abc123&quot; &quot;us-west-2&quot; = &quot;ami-def456&quot;&#125; main.tfresource &quot;aws_instance&quot; &quot;example&quot; &#123; # ami = &quot;ami-b374d5a5&quot; ami = &quot;$&#123;var.amis[var.region]&#125;&quot; instance_type = &quot;t2.micro&quot;&#125;output &quot;ami&quot; &#123; value = aws_instance.example.ami&#125; cliterraform apply -var region=us-west-2 输出变量 定义输出添加到任何 *.tf 文件中output &quot;ip&quot; &#123; value = aws_eip.ip.public_ip&#125; output可以定义多个块以指定多个输出变量。 2.查看输出命令行 terraform ouput ip 此命令对于脚本提取输出很有用 模块Terraform中的模块是Terraform配置的独立包，可作为一个组进行管理。模块用于创建可重用组件，改进组织，并将基础架构处理为黑盒子。模块文档 使用模块 terraform &#123; required_version = &quot;0.12.5&quot;&#125;provider &quot;aws&quot; &#123; access_key = &quot;AWS ACCESS KEY&quot; secret_key = &quot;AWS SECRET KEY&quot; region = &quot;us-east-1&quot;&#125;module &quot;consul&quot; &#123; source = &quot;hashicorp/consul/aws&quot; num_servers = &quot;3&quot;&#125; 该source属性是模块的唯一必需参数。它告诉Terraform可以检索模块的位置。Terraform会自动为您下载和管理模块。 模块从官方Terraform Registry中检索。Terraform还可以从各种来源检索模块，包括私有模块注册表或直接从Git，Mercurial，HTTP和本地文件。 terraform init 应用更改 terraform apply 模块输出模块输出文档描述了它产生的所有不同值。总的来说，它暴露了它创建的每个资源的id，以及回显一些输入值。 销毁terraform destroy 远程状态存储远程后端文档远程后端允许Terraform使用共享存储空间来存储状态数据，因此团队中的任何成员都可以使用Terraform来管理相同的基础架构。 1. 如何远程状态存储terraform &#123; backend &quot;remote&quot; &#123; organization = &quot;Cloud-Org&quot; workspaces &#123; name = &quot;Dev-QA&quot; &#125; &#125;&#125; 2. 远程状态存储方案3. Terraform Cloud文档它支持执行Terraform运行的两个主要工作流程： VCS驱动的工作流，在将更改提交到配置的VCS存储库时，它会自动对计划进行排队。 API驱动的工作流，CI管道或其他自动化工具可以直接上传配置。 登录terraform cloud console 升级terraform版本到0.11.13以上 在cloud上创建组织 添加组织成员 在cloud上添加access token并配置本机认证文件%APPDATA%\\terraform.rc credentials &quot;app.terraform.io&quot; &#123; token = &quot;REPLACE_ME&quot;&#125; 在配置中开启terraform remote state 配置 terraform &#123; backend &quot;remote&quot; &#123; organization = &quot;max&quot; workspaces &#123; name = &quot;app-max-hello&quot; &#125; &#125;&#125; 重新初始化并运行terraform terraform init 协作查看 查看工作区 工作区锁定 查看状态历史版本 删除工作空间 terraform destroy -auto-approve","categories":[],"tags":[]},{"title":"","slug":"blog/terraform/terraform进阶实践","date":"2020-05-08T03:44:42.542Z","updated":"2020-06-04T01:07:07.290Z","comments":true,"path":"blog/terraform/terraform进阶实践","link":"","permalink":"http://www.matosiki.site/blog/terraform/terraform进阶实践","excerpt":"","text":"架构图 一、导入terraform 用户导入现有的基础结构 二、状态Terraform必须存储有关托管基础架构和配置的状态。Terraform使用此状态将现实世界资源映射到您的配置，跟踪元数据并提高大型基础架构的性能。默认情况下，此状态存储在名为“terraform.tfstate”的本地文件中，但也可以远程存储，这在团队环境中更有效。 Terraform使用此本地状态来创建计划并对您的基础架构进行更改。在任何操作之前，Terraform会进行 刷新以使用真实基础架构更新状态。 terraform state命令，使用CLI对状态进行基本修改。 terraform state目的 映射真实世界 terraform需要某种数据库来将Terraform配置映射到现实世界。 元数据 Terraform通常使用配置来确定依赖顺序，但是，从Terraform配置中删除资源时，Terraform必须知道如何删除该资源。Terraform还出于类似的原因存储其他元数据，例如指向最近在存在多个别名提供程序的情况下与资源一起使用的提供程序配置的指针。 表现Terraform还为状态中的所有资源存储属性值的缓存，terraform plan，Terraform必须知道当前的资源状态，以便有效地确定为达到所需配置而需要进行的更改 同步在默认配置中，Terraform将状态存储在运行Terraform的当前工作目录中的文件中 导入现有资源 锁如果您的后端支持，Terraform将锁定您可以写入状态的所有操作的状态。这可以防止他人获得锁定并可能破坏您的状态。 工作空间每个Terraform配置都有一个关联的后端 ，用于定义操作的执行方式以及存储Terraform状态等持久性数据的位置。 支持工作区有： AzureRM、Consul、GCS、local、manta、pg、remote、S3当前工作区插值 resource &quot;aws_instance&quot; &quot;example&quot; &#123; count = &quot;$&#123;terraform.workspace == &quot;default&quot; ? 5 : 1&#125;&quot; # ... other arguments&#125; 远程状态 将状态远程存储起来，Terraform还可以使用 状态锁定来防止Terraform在同一状态下并发运行，从而到达团队协作。 敏感数据使用本地状态时，state存储在纯文本JSON文件中。使用远程状态时，状态仅在Terraform使用时保存在内存中。它可以在静止时加密，但这取决于特定的远程状态后端。远程存储状态可能会为您提供静态加密，具体取决于您选择的后端。 三、提供商云提供商: 亚马逊、谷歌、百度云、阿里云、腾讯云等等。 四、预配器 connect 预配器 provisioner &quot;file&quot; &#123; source = &quot;conf/myapp.conf&quot; destination = &quot;/etc/myapp.conf&quot; connection &#123; type = &quot;ssh&quot; user = &quot;root&quot; password = &quot;$&#123;var.root_password&#125;&quot; &#125;&#125;# Copies the file as the Administrator user using WinRMprovisioner &quot;file&quot; &#123; source = &quot;conf/myapp.conf&quot; destination = &quot;C:/App/myapp.conf&quot; // connection块来覆盖这些默认值 connection &#123; type = &quot;winrm&quot; user = &quot;Administrator&quot; password = &quot;$&#123;var.admin_password&#125;&quot; host = &quot;192.168.0.1&quot; timeout = &quot;30s&quot; script_path = &quot;path&quot; //用于复制脚本的路径，用于远程执行。 &#125;&#125; 没有资源的预配器null_resource被视为普通资源 chefchef预配安装，配置和运行上的远程资源的厨师客户端该chef预配有特定的连接类型的一些先决条件： 对于ssh类型连接，cURL必须在远程主机上可用。 对于winrm连接，PowerShell 2.0必须在远程主机上可用。 文件预配器该file预配用于从执行Terraform到新创建的资源的机器复制文件或目录。 resource &quot;aws_instance&quot; &quot;web&quot; &#123; # ... # Copies the myapp.conf file to /etc/myapp.conf provisioner &quot;file&quot; &#123; source = &quot;conf/myapp.conf&quot; destination = &quot;/etc/myapp.conf&quot; &#125;&#125; habitathabitat预配装的Habitat管理者和配置加载服务先决条件：对于ssh类型连接，我们假设在远程主机上有一些工具可用： curl tee setsid- 仅在使用unmanaged服务类型时 local-exec在local-exec创建资源后供应者调用本地可执行文件。 Puppet 预配器先决条件： 对于ssh类型连接，cURL必须在远程主机上可用。对于winrm连接，PowerShell 2.0必须在远程主机上可用。 remote-execremote-exec供应方的远程资源调用的脚本在创建后。 salt-masterlesssalt-masterlessTerraform供应方规定的机器使用内置Terraform salt的状态，而无需连接到salt-masterless 五、模块 发布来源terraform registry 上发布模块公共的模块 自己实现api 来源类型在module块中source参数告诉terraform从哪里找到子module有如下方式： 本地路径 terraform registry github bitbucket 公共git仓库 http urls s3 bucket gcs bucket 模块组成依赖性倒置有条件地创建对象多云抽象仅数据模块 核心: 定义 main.tf 资源定义值文件 outputs.tf 输出变量,用于其他模块引用 aliables.tf 输入变量,用于获取外部变量. 引用使用外部module 六、后端后端的作用,可以团队工作、保持磁盘上的敏感信息和远程操作。后端初始化配置好后端使用配置进行terraform init terraform &#123; backend &quot;consul&quot; &#123; address = &quot;demo.consul.io&quot; scheme = &quot;https&quot; path = &quot;example_app/terraform_state&quot; &#125;&#125; 后端负责存储状态并提供状态锁定API手动推拉从远程状态中检索状态 七、插件Terraform供应商插件提供。gong’kai特定服务和配置程序。安装插件将插件放入%APPDATA%\\terraform.d\\plugins目录下。开发插件package mainimport ( &quot;github.com/hashicorp/terraform/plugin&quot;)func main() &#123; plugin.Serve(new(MyPlugin)) //实现Provider或Provisioner&#125; provider插件插件提供者负责资源的生命周期：创建、读取、更新和删除。提供插件 import ( &quot;github.com/hashicorp/terraform/helper/schema&quot; &quot;github.com/hashicorp/terraform/terraform&quot;)//这是提供程序本身的配置架构 func Provider() terraform.ResourceProvider &#123; return &amp;schema.Provider&#123; DataSourcesMap: map[string]*schema.Resource&#123; &quot;template_file&quot;: dataSourceFile(), &quot;template_cloudinit_config&quot;: dataSourceCloudinitConfig(), &#125;, ResourcesMap: map[string]*schema.Resource&#123; &quot;template_file&quot;: schema.DataSourceResourceShim( &quot;template_file&quot;, dataSourceFile(), ), &quot;template_cloudinit_config&quot;: schema.DataSourceResourceShim( &quot;template_cloudinit_config&quot;, dataSourceCloudinitConfig(), ), &quot;template_dir&quot;: resourceDir(), &#125;, &#125;&#125; 部分状态改变操作 func resourceUpdate(d *schema.ResourceData, meta interface&#123;&#125;) error &#123; // Enable partial state mode d.Partial(true) if d.HasChange(&quot;tags&quot;) &#123; // 如果tags属性值变化了进行其他操作 // If an error occurs, return with an error, // we didn&apos;t finish updating if err := updateTags(d, meta); err != nil &#123; return err &#125; d.SetPartial(&quot;tags&quot;) &#125; if d.HasChange(&quot;name&quot;) &#123; if err := updateName(d, meta); err != nil &#123; return err &#125; d.SetPartial(&quot;name&quot;) &#125; // We succeeded, disable partial mode d.Partial(false) return nil&#125; 八、内幕调试terraform设置日志打印环境变量中添加 # 打印等级 TRACE，DEBUG，INFO，WARN或ERRORTF_LOG=TRACETF_LOG_PATH=path Terraform崩溃（Go运行时中的“恐慌”），它会保存一个日志文件，其中包含来自会话的调试日志以及恐慌消息和回溯到crash.log 资源图 所有资源组合编排实际在terraform中，组成了一个复杂的资源依赖图，资源图由资源节点、提供者配置节点和资源元节点组成，所以并发构建其实是对图中未依赖的资源节点和依赖的执行节点进行并发创建. terraform是支持并发构建的。让我默认看看terraform资源图创建与遍历原理，来理解terraform并发创建基础设施。图形节点： 资源节点 - 表示单个资源 count设置了元参数，那么每个计数将有一个资源节点 （更改中的资源的配置，差异，状态等附加到此节点。） 提供者配置节点 -表示完全配置提供者的时机，将提供者配置提供给提供者的实际，如aws安全认证3.资源源节点 -表示一组资源，但不代表任何操作构建图形: 根据配置添加资源节点。如果存在diff（计划）或状态，则将该元数据附加到每个资源节点。 如果资源有任何已定义的资源，则映射到资源。必须在创建所有资源节点后执行此操作，以便具有相同配置程序类型的资源可以共享配置程序实现。 depends_on元参数的显式依赖关系用于创建资源边缘。 如果存在状态，则将任何“孤立”资源添加到图形中。孤立资源是配置中不再存在但存在于状态文件中的任何资源。孤儿永远不会有任何与之关联的配置，因为状态文件不存储配置。 资源映射到提供者。为这些提供程序创建提供程序配置节点，并创建边缘，以便资源依赖于正在配置的各自提供程序。 在资源和提供程序配置中解析插值以确定依赖性。对资源属性的引用变为从具有内插的资源到被引用资源的依赖性。 创建根节点。根节点指向所有资源并且已创建，因此依赖关系图中只有一个根。遍历图形时，将忽略根节点。 如果存在diff，则遍历所有资源节点并查找正在销毁的资源。这些资源节点分为两个：一个销毁资源的节点和另一个创建资源的节点（如果正在重新创建）。必须拆分节点的原因是因为销毁顺序通常与创建顺序不同，因此它们不能由单个图节点表示。 验证图表没有周期并且具有单个根节点。遍历图形：遍历图形，采用一个标准的深度优先遍历方式，图的遍历是并行的，一旦遍历所有依赖关系，就运行一个节点。默认图表同时操作10个节点，也可以使用-parallelism参数更改并发数 资源的生命周期 ValidateResource被称为对资源配置进行高级结构验证。 Diff使用当前状态和配置调用。 Apply用当前状态和差异调用。 如果资源刚刚创建且之前不存在，并且应用成功而没有错误，则按顺序执行配置程序。如果任何供应商错误，资源被标记为 污染，以便在下次申请时将其销毁。 资源地址一个资源地址是引用了一个更大的基础设施中的特定资源的字符串。 模块路径 module.A.module.B.module.C... 资源规格 resource_type.resource_name[N] json输出格式状态表示、计划表示、值表示形式、配置表示和更改表示都可以使用json的方式查看。 远程服务发现插件","categories":[],"tags":[]},{"title":"","slug":"blog/java/java分割字符串的三种方式","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:05:00.608Z","comments":true,"path":"blog/java/java分割字符串的三种方式","link":"","permalink":"http://www.matosiki.site/blog/java/java分割字符串的三种方式","excerpt":"","text":"使用java原生String.split()方法String[] splitted = \"peter,james,thomas\".split(\",\"); // 逗号分割String[] splitted = \"car jeep scooter\".split(\" \"); // 空格分割String[] splitted = \"192.168.1.178\".split(\"\\\\.\") // 点分割String[] splitted = \"b a, e, l.d u, n g\".split(\"\\\\s+|,\\\\s*|\\\\.\\\\s*\")); //则这表达式多个分割符 使用工具类Common包下的StringUtils.split()方法String[] splitted = StringUtils.split(\"car jeep scooter\"); //默认空白分割 使用guava工具包的Splitter流List&lt;String&gt; resultList = Splitter.on(',') .trimResults() .omitEmptyStrings() .splitToList(\"car,jeep,, scooter\"); 总结: String成员方法分割字符串处理简单分割比较容易,但是复杂一点使用工具类还是比较方法. 预先善其事必先利其器,多学习一些工具类的使用,提高开发效率也还不错.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java回文数字判断","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:05:04.417Z","comments":true,"path":"blog/java/java回文数字判断","link":"","permalink":"http://www.matosiki.site/blog/java/java回文数字判断","excerpt":"","text":"1. 使用原生java方式public boolean isPalindrome(String text) &#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); int length = clean.length(); int forward = 0; int backward = length - 1; while (backward &gt; forward) &#123; //两边指针同时变动,比较. char forwardChar = clean.charAt(forward++); char backwardChar = clean.charAt(backward--); if (forwardChar != backwardChar) return false; &#125; return true;&#125; 2. 使用字符串reverse比较public boolean isPalindromeReverseTheString(String text) &#123; StringBuilder reverse = new StringBuilder(); String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); char[] plain = clean.toCharArray(); for (int i = plain.length - 1; i &gt;= 0; i--) &#123; reverse.append(plain[i]); &#125; return (reverse.toString()).equals(clean);&#125; 3. 使用stringbuffer 和stringbuilder直接翻转字符串比较public boolean isPalindromeUsingStringBuilder(String text) &#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); StringBuilder plain = new StringBuilder(clean); StringBuilder reverse = plain.reverse(); return (reverse.toString()).equals(clean);&#125; public boolean isPalindromeUsingStringBuffer(String text) &#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); StringBuffer plain = new StringBuffer(clean); StringBuffer reverse = plain.reverse(); return (reverse.toString()).equals(clean);&#125; 4. 使用java8 intStreampublic boolean isPalindromeUsingIntStream(String text) &#123; String temp = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); return IntStream.range(0, temp.length() / 2) .noneMatch(i -&gt; temp.charAt(i) != temp.charAt(temp.length() - i - 1));&#125; 5. 使用递归调用public boolean isPalindromeRecursive(String text)&#123; String clean = text.replaceAll(\"\\\\s+\", \"\").toLowerCase(); return recursivePalindrome(clean,0,clean.length()-1);&#125; private boolean recursivePalindrome(String text, int forward, int backward) &#123; if (forward == backward) &#123; return true; &#125; if ((text.charAt(forward)) != (text.charAt(backward))) &#123; return false; &#125; if (forward &lt; backward + 1) &#123; return recursivePalindrome(text, forward + 1, backward - 1); &#125; return true;&#125; 总结: 回文数验证分两种 一种是移动下标比较 另一种是 翻转 比较,翻转比较性能没有下标比较好,所以建议使用java8 InStreannomatch方法","categories":[],"tags":[]},{"title":"","slug":"blog/java/java字符类型转字符串类型六种方式","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:05:57.725Z","comments":true,"path":"blog/java/java字符类型转字符串类型六种方式","link":"","permalink":"http://www.matosiki.site/blog/java/java字符类型转字符串类型六种方式","excerpt":"","text":"1. 使用String.valueOf()方法@Testpublic void givenChar_whenCallingStringValueOf_shouldConvertToString() &#123; char givenChar = 'x'; String result = String.valueOf(givenChar); assertThat(result).isEqualTo(\"x\");&#125; 2. 使用 Character.toString() 方法@Testpublic void givenChar_whenCallingToStringOnCharacter_shouldConvertToString() &#123; char givenChar = 'x'; String result = Character.toString(givenChar); assertThat(result).isEqualTo(\"x\");&#125; 3. 使用Character的构造方法@Testpublic void givenChar_whenCallingCharacterConstructor_shouldConvertToString() &#123; char givenChar = 'x'; String result = new Character(givenChar).toString(); assertThat(result).isEqualTo(\"x\");&#125; 4. 通过String的隐式转换@Testpublic void givenChar_whenConcatenated_shouldConvertToString() &#123; char givenChar = 'x'; String result = givenChar + \"\"; assertThat(result).isEqualTo(\"x\");&#125; 5.@Testpublic void givenChar_whenFormated_shouldConvertToString() &#123; char givenChar = 'x'; String result = String.format(\"%c\", givenChar); assertThat(result).isEqualTo(\"x\");&#125; 总结: 常用Stirng的隐式转换方式.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java截取字符串的最后一个字符方法","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:06:03.253Z","comments":true,"path":"blog/java/java截取字符串的最后一个字符方法","link":"","permalink":"http://www.matosiki.site/blog/java/java截取字符串的最后一个字符方法","excerpt":"","text":"1. 原生java方式 先判断是否为空public static String removeLastChar(String s) &#123; return (s == null || s.length() == 0) ? null : (s.substring(0, s.length() - 1));&#125; 2. 使用java8public static String removeLastCharOptional(String s) &#123; return Optional.ofNullable(s) .filter(str -&gt; str.length() != 0) .map(str -&gt; str.substring(0, str.length() - 1)) .orElse(s);&#125; 3. 使用 apache common lang StringUtils.substring()String TEST_STRING = \"ACBDEF\";StringUtils.substring(TEST_STRING,0,TEST_STRING.length()-1); 4. 使用 StringUtils.chop()方法 因对边缘场景的情况（empty or null）时StringUtils.chop(TEST_STRING) 5. 使用replaceAll() 的正则表达式方式public static String removeLastCharRegex(String s) &#123; return (s == null) ? null : s.replaceAll(\".$\", \"\");&#125;// java8public static String removeLastCharRegexOptional(String s) &#123; return Optional.ofNullable(s) .map(str -&gt; str.replaceAll(\".$\", \"\")) .orElse(s);&#125; 总结： 以上主要使用substring方法截取字符串，复杂的话建议使用正则表达式方式处理。","categories":[],"tags":[]},{"title":"","slug":"blog/java/java生成随机字符串的五种方式","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:06:09.496Z","comments":true,"path":"blog/java/java生成随机字符串的五种方式","link":"","permalink":"http://www.matosiki.site/blog/java/java生成随机字符串的五种方式","excerpt":"","text":"1. 使用原生java生成无边界字符串@Testpublic void givenUsingPlainJava_whenGeneratingRandomStringUnbounded_thenCorrect() &#123; byte[] array = new byte[7]; // length is bounded by 7 new Random().nextBytes(array); String generatedString = new String(array, Charset.forName(\"UTF-8\")); System.out.println(generatedString);&#125; 2.使用原生java生成右边界字符串@Testpublic void givenUsingPlainJava_whenGeneratingRandomStringBounded_thenCorrect() &#123; int leftLimit = 97; // letter 'a' int rightLimit = 122; // letter 'z' int targetStringLength = 10; Random random = new Random(); StringBuilder buffer = new StringBuilder(targetStringLength); for (int i = 0; i &lt; targetStringLength; i++) &#123; int randomLimitedInt = leftLimit + (int) (random.nextFloat() * (rightLimit - leftLimit + 1)); buffer.append((char) randomLimitedInt); &#125; String generatedString = buffer.toString(); System.out.println(generatedString);&#125; 3.使用 apache common lang 生成有边界字符串(只用字母)@Testpublic void givenUsingApache_whenGeneratingRandomStringBounded_thenCorrect() &#123; int length = 10; boolean useLetters = true; boolean useNumbers = false; String generatedString = RandomStringUtils.random(length, useLetters, useNumbers); System.out.println(generatedString);&#125; 4. 使用 apache common lang 生成有边界字母@Testpublic void givenUsingApache_whenGeneratingRandomAlphabeticString_thenCorrect() &#123; String generatedString = RandomStringUtils.randomAlphabetic(10); System.out.println(generatedString);&#125; 5. 使用 apache common lang 生成有边界字母和数字@Testpublic void givenUsingApache_whenGeneratingRandomAlphanumericString_thenCorrect() &#123; String generatedString = RandomStringUtils.randomAlphanumeric(10); System.out.println(generatedString);&#125; 总结: 使用lang包的生成方式简单,自己原生方式也可以实现.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java的字符串转枚举类型","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:06:15.090Z","comments":true,"path":"blog/java/java的字符串转枚举类型","link":"","permalink":"http://www.matosiki.site/blog/java/java的字符串转枚举类型","excerpt":"","text":"假定一个美酒类型PizzaStatusEnum readyStatus = PizzaStatusEnum.READY; 使用 valueOf(“”)方法@Testpublic void whenConvertedIntoEnum_thenGetsConvertedCorrectly() &#123; String pizzaEnumValue = \"READY\"; PizzaStatusEnum pizzaStatusEnum = PizzaStatusEnum.valueOf(pizzaEnumValue); assertTrue(pizzaStatusEnum == PizzaStatusEnum.READY);&#125; 注意: 如果参数不对,会抛出非法参数异常@Test(expected = IllegalArgumentException.class)public void whenConvertedIntoEnum_thenThrowsException() &#123; String pizzaEnumValue = \"invalid\"; PizzaStatusEnum pizzaStatusEnum = PizzaStatusEnum.valueOf(pizzaEnumValue);&#125;","categories":[],"tags":[]},{"title":"","slug":"blog/java/java统计字符串中字符出现的次数","date":"2020-05-08T03:44:42.541Z","updated":"2020-06-04T01:06:38.678Z","comments":true,"path":"blog/java/java统计字符串中字符出现的次数","link":"","permalink":"http://www.matosiki.site/blog/java/java统计字符串中字符出现的次数","excerpt":"","text":"1. 使用java原生方式for循环String someString = \"elephant\";char someChar = 'e';int count = 0; for (int i = 0; i &lt; someString.length(); i++) &#123; if (someString.charAt(i) == someChar) &#123; count++; &#125;&#125;assertEquals(2, count); 2. 使用java原生递归调用private static int countOccurences( String someString, char searchedChar, int index) &#123; if (index &gt;= someString.length()) &#123; return 0; &#125; int count = someString.charAt(index) == searchedChar ? 1 : 0; return count + countOccurences( someString, searchedChar, index + 1);&#125; 3. 使用正则表达式Pattern pattern = Pattern.compile(\"[^e]*e\");Matcher matcher = pattern.matcher(\"elephant\");int count = 0;while (matcher.find()) &#123; count++;&#125; assertEquals(2, count); 4.使用java8String someString = \"elephant\";long count = someString.chars().filter(ch -&gt; ch == 'e').count();assertEquals(2, count); long count2 = someString.codePoints().filter(ch -&gt; ch == 'e').count();assertEquals(2, count2); 使用外部jar包5. 使用lang包int count = StringUtils.countMatches(\"elephant\", \"e\");assertEquals(2, count); 6. 使用guavaint count = CharMatcher.is('e').countIn(\"elephant\");assertEquals(2, count); 7.使用spring utilsint count = StringUtils.countOccurrencesOf(\"elephant\", \"e\");assertEquals(2, count); 总结: 原生方式简单粗暴,也可以使用其他工具类,但使用java8感觉最优雅.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中字符串转字节流","date":"2020-05-08T03:44:42.540Z","updated":"2020-06-04T01:04:32.221Z","comments":true,"path":"blog/java/java中字符串转字节流","link":"","permalink":"http://www.matosiki.site/blog/java/java中字符串转字节流","excerpt":"","text":"1. 使用chars()方法 返回IntStreamString testString = \"String\";IntStream intStream = testString.chars(); // 获取 数字流 ,所以我们需要转换Stream&lt;Character&gt; characterStream = testString.chars() .mapToObj(c -&gt; (char) c); // 使用mapToObj强转 2. 使用codePoint()方法 得到点码,再强转.Stream&lt;Character&gt; characterStream2 = testString.codePoints() .mapToObj(c -&gt; (char) c);// 也可以转换成单个字符串流Stream&lt;String&gt; stringStream = testString.codePoints() .mapToObj(c -&gt; String.valueOf((char) c)); 总结: 通过字符串转换整型流,也可以转换字节流,还可以转换单个字符串流.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中实用apache Text字符串处理","date":"2020-05-08T03:44:42.540Z","updated":"2020-06-04T01:04:35.828Z","comments":true,"path":"blog/java/java中实用apache Text字符串处理","link":"","permalink":"http://www.matosiki.site/blog/java/java中实用apache Text字符串处理","excerpt":"","text":"首字母大写@Testpublic void whenCapitalized_thenCorrect() &#123; String toBeCapitalized = \"to be capitalized!\"; String result = WordUtils.capitalize(toBeCapitalized); assertEquals(\"To Be Capitalized!\", result);&#125; 判断字符串中存在的字符@Testpublic void whenContainsWords_thenCorrect() &#123; boolean containsWords = WordUtils .containsAllWords(\"String to search\", \"to\", \"search\"); assertTrue(containsWords);&#125; 使用StrSubstitutor建立字符串模板@Testpublic void whenSubstituted_thenCorrect() &#123; Map&lt;String, String&gt; substitutes = new HashMap&lt;&gt;(); substitutes.put(\"name\", \"John\"); substitutes.put(\"college\", \"University of Stanford\"); String templateString = \"My name is $&#123;name&#125; and I am a student at the $&#123;college&#125;.\"; StrSubstitutor sub = new StrSubstitutor(substitutes); String result = sub.replace(templateString); assertEquals(\"My name is John and I am a student at the University of Stanford.\", result);&#125; 使用StrBuilder替代原生StirngBuilder 方便替换字串串内容@Testpublic void whenReplaced_thenCorrect() &#123; StrBuilder strBuilder = new StrBuilder(\"example StrBuilder!\"); strBuilder.replaceAll(\"example\", \"new\"); assertEquals(new StrBuilder(\"new StrBuilder!\"), strBuilder); //清理StrBuilder strBuilder.clear()&#125; 比较字符串不同次数@Testpublic void whenEditScript_thenCorrect() &#123; StringsComparator cmp = new StringsComparator(\"ABCFGH\", \"BCDEFG\"); EditScript&lt;Character&gt; script = cmp.getScript(); int mod = script.getModifications(); assertEquals(4, mod);&#125; 使用text.similarily方便比较字符串的不同程度// 得到相同数量@Testpublic void whenCompare_thenCorrect() &#123; LongestCommonSubsequence lcs = new LongestCommonSubsequence(); int countLcs = lcs.apply(\"New York\", \"New Hampshire\"); assertEquals(5, countLcs);&#125;// 得到不同数量@Testpublic void whenCalculateDistance_thenCorrect() &#123; LongestCommonSubsequenceDistance lcsd = new LongestCommonSubsequenceDistance(); int countLcsd = lcsd.apply(\"New York\", \"New Hampshire\"); assertEquals(11, countLcsd);&#125; 自定义传唤字符串@Testpublic void whenTranslate_thenCorrect() &#123; UnicodeEscaper ue = UnicodeEscaper.above(0); String result = ue.translate(\"ABCD\"); assertEquals(\"\\\\u0041\\\\u0042\\\\u0043\\\\u0044\", result);&#125;","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中将列表转换成字符串","date":"2020-05-08T03:44:42.540Z","updated":"2020-06-04T01:04:41.929Z","comments":true,"path":"blog/java/java中将列表转换成字符串","link":"","permalink":"http://www.matosiki.site/blog/java/java中将列表转换成字符串","excerpt":"","text":"1. 直接打印@Testpublic void whenListToString_thenPrintDefault() &#123; List&lt;Integer&gt; intLIst = Arrays.asList(1, 2, 3); System.out.println(intLIst); //这个方式,对简单类型对象适用&#125; 2. 实用stream方式转换@Testpublic void whenCollectorsJoining_thenPrintCustom() &#123; List&lt;Integer&gt; intList = Arrays.asList(1, 2, 3); String result = intList.stream() .map(n -&gt; String.valueOf(n)) .collect(Collectors.joining(\"-\", \"&#123;\", \"&#125;\")); System.out.println(result);&#125; 3. 实用Common lang 工具@Testpublic void whenStringUtilsJoin_thenPrintCustom() &#123; List&lt;Integer&gt; intList = Arrays.asList(1, 2, 3); System.out.println(StringUtils.join(intList, \"|\"));&#125; 总结: 简单的类型可以直接打印,但是复杂自定义对象建议使用流方式打印.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中将异常栈跟踪信息转字符串","date":"2020-05-08T03:44:42.540Z","updated":"2020-06-04T01:04:46.618Z","comments":true,"path":"blog/java/java中将异常栈跟踪信息转字符串","link":"","permalink":"http://www.matosiki.site/blog/java/java中将异常栈跟踪信息转字符串","excerpt":"","text":"1. 使用原生java代码StringWriter sw = new StringWriter();PrintWriter pw = new PrintWriter(sw);e.printStackTrace(pw); 2. 使用Common lang工具在类String stacktrace = ExceptionUtils.getStacktrace(e); 总结 获取跟踪栈异常默认不能用String,在java9中添加了StackWalking API支持栈异常跟踪","categories":[],"tags":[]},{"title":"","slug":"blog/java/java使用Guava进行字符串处理","date":"2020-05-08T03:44:42.540Z","updated":"2020-06-04T01:04:56.514Z","comments":true,"path":"blog/java/java使用Guava进行字符串处理","link":"","permalink":"http://www.matosiki.site/blog/java/java使用Guava进行字符串处理","excerpt":"","text":"java使用Guava进行字符串处理从字符串中删除特定的字符@Testpublic void whenRemoveSpecialCharacters_thenRemoved()&#123; String input = \"H*el.lo,&#125;12\"; CharMatcher matcher = CharMatcher.JAVA_LETTER_OR_DIGIT; String result = matcher.retainFrom(input); assertEquals(\"Hello12\", result);&#125; 从字符串中删除不是字符串@Testpublic void whenRemoveNonASCIIChars_thenRemoved() &#123; String input = \"あhello₤\"; String result = CharMatcher.ASCII.retainFrom(input); assertEquals(\"hello\", result); result = CharMatcher.inRange('0', 'z').retainFrom(input); assertEquals(\"hello\", result);&#125; 删除不在字符集中的字符@Testpublic void whenRemoveCharsNotInCharset_thenRemoved() &#123; Charset charset = Charset.forName(\"cp437\"); CharsetEncoder encoder = charset.newEncoder(); Predicate&lt;Character&gt; inRange = new Predicate&lt;Character&gt;() &#123; @Override public boolean apply(Character c) &#123; return encoder.canEncode(c); &#125; &#125;; String result = CharMatcher.forPredicate(inRange) .retainFrom(\"helloは\"); assertEquals(\"hello\", result);&#125; 验证字符串@Testpublic void whenValidateString_thenValid()&#123; String input = \"hello\"; boolean result = CharMatcher.JAVA_LOWER_CASE.matchesAllOf(input); assertTrue(result); result = CharMatcher.is('e').matchesAnyOf(input); assertTrue(result); result = CharMatcher.JAVA_DIGIT.matchesNoneOf(input); assertTrue(result);&#125; 去除字符串空格@Testpublic void whenTrimString_thenTrimmed() &#123; String input = \"---hello,,,\"; String result = CharMatcher.is('-').trimLeadingFrom(input); assertEquals(\"hello,,,\", result); result = CharMatcher.is(',').trimTrailingFrom(input); assertEquals(\"---hello\", result); result = CharMatcher.anyOf(\"-,\").trimFrom(input); assertEquals(\"hello\", result);&#125; 折叠字符串@Testpublic void whenCollapseFromString_thenCollapsed() &#123; String input = \" hel lo \"; String result = CharMatcher.is(' ').collapseFrom(input, '-'); assertEquals(\"-hel-lo-\", result); result = CharMatcher.is(' ').trimAndCollapseFrom(input, '-'); assertEquals(\"hel-lo\", result);&#125; 替换字符串@Testpublic void whenReplaceFromString_thenReplaced() &#123; String input = \"apple-banana.\"; String result = CharMatcher.anyOf(\"-.\").replaceFrom(input, '!'); assertEquals(\"apple!banana!\", result); result = CharMatcher.is('-').replaceFrom(input, \" and \"); assertEquals(\"apple and banana.\", result);&#125; 统计字串串出现的次数@Testpublic void whenCountCharInString_thenCorrect() &#123; String input = \"a, c, z, 1, 2\"; int result = CharMatcher.is(',').countIn(input); assertEquals(4, result); result = CharMatcher.inRange('a', 'h').countIn(input); assertEquals(2, result);&#125; 总结: 使用CharMatcher处理字符串,简单方便.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java使用apache common工具类","date":"2020-05-08T03:44:42.540Z","updated":"2020-06-04T01:04:51.644Z","comments":true,"path":"blog/java/java使用apache common工具类","link":"","permalink":"http://www.matosiki.site/blog/java/java使用apache common工具类","excerpt":"","text":"查询字符串中出现任意字符String string = \"baeldung.com\";boolean contained1 = StringUtils.containsAny(string, 'a', 'b', 'c');boolean contained2 = StringUtils.containsAny(string, 'x', 'y', 'z');boolean contained3 = StringUtils.containsAny(string, \"abc\");boolean contained4 = StringUtils.containsAny(string, \"xyz\"); assertTrue(contained1);assertFalse(contained2);assertTrue(contained3);assertFalse(contained4);// 忽略大小写String string = \"matosiki.com\";boolean contained = StringUtils.containsIgnoreCase(string, \"MATOSIKI\"); assertTrue(contained); 匹配出现次数方法String string = \"welcome to www.matosiki.com\";int charNum = StringUtils.countMatches(string, 'w');int stringNum = StringUtils.countMatches(string, \"com\"); assertEquals(4, charNum);assertEquals(2, stringNum); 匹配前缀和后缀的方法String string = \"matosiki.com\";String stringWithSuffix = StringUtils.appendIfMissing(string, \".com\");String stringWithPrefix = StringUtils.prependIfMissing(string, \"www.\"); assertEquals(\"matosiki.com\", stringWithSuffix);assertEquals(\"www.matosiki.com\", stringWithPrefix); 改变大小写String originalString = \"matosiki.COM\";String swappedString = StringUtils.swapCase(originalString); assertEquals(\"MATOSIKI.com\", swappedString);// 首字母大写String capitalizedString = StringUtils.capitalize(originalString); assertEquals(\"Matosiki.COM\", capitalizedString);//首字母不大写String uncapitalizedString = StringUtils.uncapitalize(originalString); assertEquals(\"matosiki.COM\", uncapitalizedString); 翻转字符串String originalString = \"matosiki\";String reversedString = StringUtils.reverse(originalString); assertEquals(\"ikisotam\", reversedString);// 分割式翻转String originalString = \"www.matosiki.com\";String reversedString = StringUtils.reverseDelimited(originalString, '.'); assertEquals(\"com.matosiki.www\", reversedString); 使用rotate()方法旋转String originalString = \"matosiki\";String rotatedString = StringUtils.rotate(originalString, 4); assertEquals(\"sikimatos\", rotatedString); 比较不同String tutorials = \"Baeldung Tutorials\";String courses = \"Baeldung Courses\";String diff1 = StringUtils.difference(tutorials, courses);String diff2 = StringUtils.difference(courses, tutorials); assertEquals(\"Courses\", diff1);assertEquals(\"Tutorials\", diff2); 总结: 使用StringUtils对字符串进行一些常用操作","categories":[],"tags":[]},{"title":"","slug":"blog/java/java8新增StringJoiner用法","date":"2020-05-08T03:44:42.539Z","updated":"2020-06-04T01:04:09.841Z","comments":true,"path":"blog/java/java8新增StringJoiner用法","link":"","permalink":"http://www.matosiki.site/blog/java/java8新增StringJoiner用法","excerpt":"","text":"使用java8的StringJoiner连接,附带分割和前缀和后缀1. 添加元素@Testpublic void whenAddingElements_thenJoinedElements() &#123; StringJoiner joiner = new StringJoiner(\",\", PREFIX, SUFFIX); joiner.add(\"Red\") .add(\"Green\") .add(\"Blue\"); assertEquals(joiner.toString(), \"[Red,Green,Blue]\");&#125; 2. 使用for循环添加内容@Testpublic void whenAddingListElements_thenJoinedListElements() &#123; List&lt;String&gt; rgbList = new ArrayList&lt;&gt;(); rgbList.add(\"Red\"); rgbList.add(\"Green\"); rgbList.add(\"Blue\"); StringJoiner rgbJoiner = new StringJoiner( \",\", PREFIX, SUFFIX); for (String color : rgbList) &#123; rgbJoiner.add(color); &#125; assertEquals(rgbJoiner.toString(), \"[Red,Green,Blue]\");&#125; 使用构造方式private String PREFIX = \"[\";private String SUFFIX = \"]\"; @Testpublic void whenEmptyJoinerWithoutPrefixSuffix_thenEmptyString() &#123; StringJoiner joiner = new StringJoiner(\",\"); assertEquals(0, joiner.toString().length());&#125; @Testpublic void whenEmptyJoinerJoinerWithPrefixSuffix_thenPrefixSuffix() &#123; StringJoiner joiner = new StringJoiner( \",\", PREFIX, SUFFIX); assertEquals(joiner.toString(), PREFIX + SUFFIX);&#125; 合并Joiner@Testpublic void whenMergingJoiners_thenReturnMerged() &#123; StringJoiner rgbJoiner = new StringJoiner( \",\", PREFIX, SUFFIX); StringJoiner cmybJoiner = new StringJoiner( \"-\", PREFIX, SUFFIX); rgbJoiner.add(\"Red\") .add(\"Green\") .add(\"Blue\"); cmybJoiner.add(\"Cyan\") .add(\"Magenta\") .add(\"Yellow\") .add(\"Black\"); rgbJoiner.merge(cmybJoiner); assertEquals( rgbJoiner.toString(), \"[Red,Green,Blue,Cyan-Magenta-Yellow-Black]\");&#125; 使用流@Testpublic void whenUsedWithinCollectors_thenJoined() &#123; List&lt;String&gt; rgbList = Arrays.asList(\"Red\", \"Green\", \"Blue\"); String commaSeparatedRGB = rgbList.stream() .map(color -&gt; color.toString()) .collect(Collectors.joining(\",\")); assertEquals(commaSeparatedRGB, \"Red,Green,Blue\");&#125; 总结: 构造一个简单分割的字符串,使用StringJoiner方式很不错,也可以使用流的方式.","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中StringTokenizer使用","date":"2020-05-08T03:44:42.539Z","updated":"2020-06-04T01:04:13.369Z","comments":true,"path":"blog/java/java中StringTokenizer使用","link":"","permalink":"http://www.matosiki.site/blog/java/java中StringTokenizer使用","excerpt":"","text":"使用特殊分割符分割String类型一般使用StringTokenize()1. 使用逗号分割,再用枚举递归public List&lt;String&gt; getTokens(String str) &#123; List&lt;String&gt; tokens = new ArrayList&lt;&gt;(); StringTokenizer tokenizer = new StringTokenizer(str, \",\"); while (tokenizer.hasMoreElements()) &#123; tokens.add(tokenizer.nextToken()); &#125; return tokens;&#125; 2. 使用java8public List&lt;String&gt; getTokensWithCollection(String str) &#123; return Collections.list(new StringTokenizer(str, \",\")).stream() .map(token -&gt; (String) token) // 注意这里返回类型为Object类型需要强转 .collect(Collectors.toList());&#125; 3. 自定义分割符tokens.add(tokenizer.nextToken(\"e\")); 读取CVS文件public List&lt;String&gt; getTokensFromFile( String path , String delim ) &#123; List&lt;String&gt; tokens = new ArrayList&lt;&gt;(); String currLine = \"\"; StringTokenizer tokenizer; try (BufferedReader br = new BufferedReader( new InputStreamReader(Application.class.getResourceAsStream( \"/\" + path )))) &#123; while (( currLine = br.readLine()) != null ) &#123; tokenizer = new StringTokenizer( currLine , delim ); while (tokenizer.hasMoreElements()) &#123; tokens.add(tokenizer.nextToken()); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return tokens;&#125; 测试public class TokenizerTest &#123; private MyTokenizer myTokenizer = new MyTokenizer(); private List&lt;String&gt; expectedTokensForString = Arrays.asList( \"Welcome\" , \"to\" , \"baeldung.com\" ); private List&lt;String&gt; expectedTokensForFile = Arrays.asList( \"1\" , \"IND\" , \"India\" , \"2\" , \"MY\" , \"Malaysia\" , \"3\", \"AU\" , \"Australia\" ); @Test public void givenString_thenGetListOfString() &#123; String str = \"Welcome,to,baeldung.com\"; List&lt;String&gt; actualTokens = myTokenizer.getTokens( str ); assertEquals( expectedTokensForString, actualTokens ); &#125; @Test public void givenFile_thenGetListOfString() &#123; List&lt;String&gt; actualTokens = myTokenizer.getTokensFromFile( \"data.csv\", \"|\" ); assertEquals( expectedTokensForFile , actualTokens ); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中String类型转Integer或int类型","date":"2020-05-08T03:44:42.539Z","updated":"2020-06-04T01:04:18.879Z","comments":true,"path":"blog/java/java中String类型转Integer或int类型","link":"","permalink":"http://www.matosiki.site/blog/java/java中String类型转Integer或int类型","excerpt":"","text":"1. 使用 Integer.parseInt() @Testpublic void givenString_whenParsingInt_shouldConvertToInt() &#123; String givenString = \"42\"; int result = Integer.parseInt(givenString); assertThat(result).isEqualTo(42);&#125; 2. 使用 Integer.valueOf() ,(不建议使用)内部使用缓存机制@Testpublic void givenString_whenCallingIntegerValueOf_shouldConvertToInt() &#123; String givenString = \"42\"; Integer result = Integer.valueOf(givenString); assertThat(result).isEqualTo(new Integer(42));&#125; 3. 使用Integer构造方法@Testpublic void givenString_whenCallingIntegerConstructor_shouldConvertToInt() &#123; String givenString = \"42\"; Integer result = new Integer(givenString); assertThat(result).isEqualTo(new Integer(42));&#125; 4. 使用 Integer.decode()方法@Testpublic void givenString_whenCallingIntegerDecode_shouldConvertToInt() &#123; String givenString = \"42\"; int result = Integer.decode(givenString); assertThat(result).isEqualTo(42);&#125; 以上方法如果转换错误会抛出NumberFormatException异常@Test(expected = NumberFormatException.class)public void givenInvalidInput_whenParsingInt_shouldThrow() &#123; String givenString = \"nan\"; Integer.parseInt(givenString);&#125; 5. 使用guava 工具 ,如果解析失败,会跳过返回空值@Testpublic void givenString_whenTryParse_shouldConvertToInt() &#123; String givenString = \"42\"; Integer result = Ints.tryParse(givenString); assertThat(result).isEqualTo(42);&#125; 总结: 使用java原生方式简单,但每次要考虑到解析异常也挺烦的,建议使用guava 的Ints.tryParse方法","categories":[],"tags":[]},{"title":"","slug":"blog/java/java中十六进制转ASCII编码","date":"2020-05-08T03:44:42.539Z","updated":"2020-06-04T01:04:26.576Z","comments":true,"path":"blog/java/java中十六进制转ASCII编码","link":"","permalink":"http://www.matosiki.site/blog/java/java中十六进制转ASCII编码","excerpt":"","text":"将字符串转换成十六进制 将每个字符串转换成数组 将数组中字符转换成整型 使用Integer.toHexString()方法转换成十六进制 private static String asciiToHex(String asciiStr) &#123; char[] chars = asciiStr.toCharArray(); StringBuilder hex = new StringBuilder(); for (char ch : chars) &#123; hex.append(Integer.toHexString((int) ch)); &#125; return hex.toString();&#125; 截断一个十六进制为两个字符组 使用Integer.parseInt(hex, 16)方法强转字符 把每个字符添加的StringBuilder上 private static String hexToAscii(String hexStr) &#123; StringBuilder output = new StringBuilder(\"\"); for (int i = 0; i &lt; hexStr.length(); i += 2) &#123; String str = hexStr.substring(i, i + 2); output.append((char) Integer.parseInt(str, 16)); &#125; return output.toString();&#125; 测试@Testpublic static void whenHexToAscii() &#123; String asciiString = \"www.matosiki.com\"; String hexEquivalent = \"3737373737373265363236313635366336343735366536373265363336663664\"; assertEquals(asciiString, hexToAscii(hexEquivalent));&#125; @Testpublic static void whenAsciiToHex() &#123; String asciiString = \"www.matosiki.com\"; String hexEquivalent = \"3737373737373265363236313635366336343735366536373265363336663664\"; assertEquals(hexEquivalent, asciiToHex(asciiString));&#125; 总结: 以上同16进制与ascii码相互转换.","categories":[],"tags":[]}]}