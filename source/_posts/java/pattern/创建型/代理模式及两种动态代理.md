代理模式是：一对象代替另外的对象进行操作。需要代理类和被代理类实现同样的接口
```java
/**
* 代理模式 代理类和被代理类需要实现的接口
*
*/
public interface Business {
    void doAction();
}
```
```java
被代理类
/**
 * 被代理类 需要实现接口
 *
 */
public class BusinessImpl implements Business{

	@Override
	public void doAction() {
		System.out.println("被代理类进行 真实操作");
	}
}
```
```java
代理类
/**
 * 代理类 需要现实被代理类相同的接口
 *
 */
public class BusinessImplProxy implements Business{
	private BusinessImpl businessImpl;
	public BusinessImplProxy(){
		businessImpl=new BusinessImpl();
	}
	@Override
	public void doAction() {
		doBefore();
		businessImpl.doAction();
		doAfter();
	}
	public void doBefore(){
		System.out.println("真正操作之前");
	}
	public void doAfter(){
		System.out.println("真正操作之后");
	}
}
```

```java
测试类
public class StaticTest {
	public static void main(String[] args) {
		BusinessImplProxy proxy = new BusinessImplProxy();
		proxy.doAction();
	}
}
```
传统代理用到的很少，用的最多的是动态代理
java最常用的两种动态代理方式
一.java提供基于Proxy、InvocationHandler的动态代理
只支持对接口的的实现。 其实现主要通过java.lang.reflect.Proxy类和java.lang.reflect.InvocationHandler接口。 Proxy类主要用来获取动态代理对象，InvocationHandler接口用来约束调用者实现。
JDK的动态代理用起来非常简单，但它有一个限制，就是使用动态代理的对象必须实现一个或多个接口
```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

//抽象角色：java动态代理的实现目前只支持接口，不支持抽象类  
interface BusinessFoo {
	void foo();
}

interface BusinessBar {
	String bar(String message);
}

// 真实角色：真正实现业务逻辑方法
class BusinessFooImpl implements BusinessFoo {
	public void foo() {
		System.out.println("BusinessFooImpl.foo()");
	}
}

class BusinessBarImpl implements BusinessBar {
	public String bar(String message) {
		System.out.println("BusinessBarImpl.bar()");
		return message;
	}
}

// 动态角色：动态生成代理类
class BusinessDynamicProxy implements InvocationHandler {
	private Object obj;

	BusinessDynamicProxy() {
	}

	BusinessDynamicProxy(Object obj) {
		this.obj = obj;
	}

	public Object invoke(Object proxy, Method method, Object[] args)
			throws Throwable {
		Object result = null;
		doBefore();
		result = method.invoke(obj, args);
		doAfter();
		return result;
	}

	public void doBefore() {
		System.out.println("do something before Business Logic");
	}

	public void doAfter() {
		System.out.println("do something after Business Logic");
	}

	/**
	 * 工厂方法
	 */
	public static Object factory(Object obj) {
		Class<? extends Object> cls = obj.getClass();
		return Proxy.newProxyInstance(cls.getClassLoader(),
				cls.getInterfaces(), new BusinessDynamicProxy(obj));
	}
}

public class DynamicProxy {
	public static void main(String[] args) {
		BusinessFooImpl bfoo = new BusinessFooImpl();
		BusinessFoo bf = (BusinessFoo) BusinessDynamicProxy.factory(bfoo);
		bf.foo();
		System.out.println();
		BusinessBarImpl bbar = new BusinessBarImpl();
		BusinessBar bb = (BusinessBar) BusinessDynamicProxy.factory(bbar);
		String message = bb.bar("Hello,World");
		System.out.println(message);
	}
}
```
二.基于第三方开源框架cglib
cglib官方网站：http://sourceforge.net/projects/cglib/files/
另外cglib依赖于asm（http://asm.ow2.org/）。
Cglib的原理是对指定的目标类动态生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类和final方法进行代理。
参考：http://blog.csdn.net/zhoudaxia/article/details/30591941
```java
import java.lang.reflect.Method;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

public class MethodInterceptorImpl implements MethodInterceptor {

	@Override
	public Object intercept(Object obj, Method method, Object[] args,
			MethodProxy proxy) throws Throwable {
		System.out.println("Before invoke " + method);
		Object result = proxy.invokeSuper(obj, args);
		System.out.println("After invoke" + method);
		return result;
	}
	public Object createProxy(Class<?> targetClass) {   
	    Enhancer enhancer = new Enhancer();  
	    enhancer.setSuperclass(targetClass);  
	    enhancer.setCallback(this);  
	    return enhancer.create();  
	}   
}

public class HelloWorld {
	 public void sayHelloWorld() {
	        System.out.println("HelloWorld!");
	    }
}

public class Test {
	public static void main(String[] args) {
		MethodInterceptorImpl mImpl=new MethodInterceptorImpl();
		HelloWorld helloWorld= (HelloWorld) mImpl.createProxy(HelloWorld.class);
		helloWorld.sayHelloWorld();
	}
}
```

代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
代理模式的结构

　　所谓代理，就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
　　代理模式类图如下：
　　在代理模式中的角色：
　　●　　抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。
　　●　　目标对象角色：定义了代理对象所代表的目标对象。
　　●　　代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。
源代码

抽象对象角色
```java
public	abstract	class AbstractObject {
    //操作publicabstractvoid operation();
}
```
目标对象角色
```java
public	class RealObject extends AbstractObject {
    @Override
    publicvoid operation() {
        //一些操作
        System.out.println("一些操作");
    }
}
```
代理对象角色

```java
public	class ProxyObject extends AbstractObject{
    RealObject realObject = new RealObject();
    @Override
    publicvoid operation() {
        //调用目标对象之前可以做相关操作
        System.out.println("before");        
        realObject.operation();        
        //调用目标对象之后可以做相关操作
        System.out.println("after");
    }
}
```
　　客户端
```java
publicclass Client {

    publicstaticvoid main(String[] args) {
        // TODO Auto-generated method stub
        AbstractObject obj = new ProxyObject();
        obj.operation();
    }

}```